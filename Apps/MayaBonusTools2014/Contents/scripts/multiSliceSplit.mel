// Copyright (C) 1997-2013 Autodesk, Inc., and/or its licensors.
// All rights reserved.
//
// The coded instructions, statements, computer programs, and/or related
// material (collectively the "Data") in these files contain unpublished
// information proprietary to Autodesk, Inc. ("Autodesk") and/or its licensors,
// which is protected by U.S. and Canadian federal copyright law and by
// international treaties.
//
// The Data is provided for use exclusively by You. You have the right to use,
// modify, and incorporate this Data into other products for purposes authorized 
// by the Autodesk software license agreement, without fee.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. AUTODESK
// DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTIES
// INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF NON-INFRINGEMENT,
// MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR ARISING FROM A COURSE 
// OF DEALING, USAGE, OR TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS
// LICENSORS BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL,
// DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK AND/OR ITS
// LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY OR PROBABILITY OF SUCH DAMAGES.

//
// SCRIPT NAME: multiSliceSplit.mel v3.4
// TESTED ON: Maya 4.0
// DESCRIPTION: GLOBAL PROCEDURE CALLED FROM WITHIN THE "drawSplitTool.cpp"
//              PLUGIN, USED FOR PERFORMING "MULTIPLE-SLICE" SPLITS.
//
global proc multiSliceSplit
(
   string $meshName, int $multiSlices, float $multiSliceDropoffPower, int $subdivisions,
   int $originalOrderedEdgeSplitPathIndices[],
   int $originalOrderedVertex0Indices[],
   int $originalOrderedVertexFirstRailPathIndices[],
   int $orderedVertexSecondRailPathIndices[],
   float $orderedEdgeSplitPathDistances[],
   int $firstVertexSnappedEdgeIndex, float $firstVertexSnappedSplitDistance,
   int $lastVertexSnappedEdgeIndex, float $lastVertexSnappedSplitDistance
)
{
   // INITIALIZE ARRAYS USING THE INPUT ARRAY PARAMETERS:
   int $orderedEdgeSplitPathIndices[] = $originalOrderedEdgeSplitPathIndices;
   int $orderedVertex0Indices[] = $originalOrderedVertex0Indices;
   int $orderedVertexFirstRailPathIndices[] = $originalOrderedVertexFirstRailPathIndices;

   // STORE THE SIZE OF AN "EVENLY-SPACED" SPLIT INTERVAL OF A "UNIFORM" MULTI-SLICE SPLIT:
   float $splitIntervalSize=1/(float)($multiSlices+1);

   // FOR EACH MULTI-SLICE, STRING TOGETHER THE APPROPRIATE "polySplit" COMMAND AND "eval" IT:
   for ($i=0; $i<$multiSlices; $i++)
   {
      // THE FIRST THING WE HAVE TO DO BEFORE WE STRING TOGETHER "polySplit", IS TO UPDATE ALL THE ARRAYS USED TO GENERATE THE SPLIT, WHICH ARE ALTERED BY THE *PREVIOUS* SPLIT:
      if ($i)
         for ($j=0; $j<`size $orderedEdgeSplitPathIndices`; $j++)
         {
            // FIND THE NEW VERTEX GENERATED BY THE PREVIOUS SPLIT, AND STORE IT IN THE ARRAY "$orderedVertexFirstRailPathIndices[]":
            string $potentialNewVerts[] = `ls -fl (polyListComponentConversion("-fe", "-tv", ($meshName + ".e[" + $orderedEdgeSplitPathIndices[$j] + "]")))`;
            int $potentialNewVert0Index = `match "[0-9]+$" (substitute ("[\]]", $potentialNewVerts[0], ""))`;
            string $newVert = (($potentialNewVert0Index==$orderedVertexFirstRailPathIndices[$j]) || ($potentialNewVert0Index==$orderedVertexSecondRailPathIndices[$j])) ? $potentialNewVerts[1] : $potentialNewVerts[0];
            $orderedVertexFirstRailPathIndices[$j] = `match "[0-9]+$" (substitute ("[\]]", $newVert, ""))`;

            // FIND THE NEW EDGE TO SPLIT, THAT'S SUBTENDED BETWEEN THE NEW VERTEX GENERATED BY THE PREVIOUS SPLIT, AND THE VERTICES IN "$orderedVertexSecondRailPathIndices[]":
            string $potentialNewSplitEdges[] = `ls -fl (polyListComponentConversion("-fv", "-te", $newVert))`;
            for ($oneEdge in $potentialNewSplitEdges)
            {
               string $newEdgeVerts[] = `ls -fl (polyListComponentConversion("-fe", "-tv", $oneEdge))`;
               int $newEdgeVert0Index = `match "[0-9]+$" (substitute ("[\]]", $newEdgeVerts[0], ""))`;
               int $newEdgeVert1Index = `match "[0-9]+$" (substitute ("[\]]", $newEdgeVerts[1], ""))`;
               if (($newEdgeVert0Index==$orderedVertexSecondRailPathIndices[$j]) || ($newEdgeVert1Index==$orderedVertexSecondRailPathIndices[$j]))
               {
                  $orderedEdgeSplitPathIndices[$j] = `match "[0-9]+$" (substitute ("[\]]", $oneEdge, ""))`;
                  break;
               }
            }

            // DETERMINE WHETHER THE NEW VERTEX IN THE NEW EDGE IS ITS *FIRST* VERTEX (I.E. "VERTEX 0") AND STORE IT, IF SO:
            if ($orderedVertex0Indices[$j]!=$orderedVertexSecondRailPathIndices[$j])
               $orderedVertex0Indices[$j] = $orderedVertexFirstRailPathIndices[$j];
         }

      // STRING TOGETHER "polySplit" COMMAND FOR CURRENT SLICE, AND "eval" IT:
      string $currentSliceSplitCmd = ("polySplit -ch on -s " + $subdivisions) + (($firstVertexSnappedEdgeIndex>-1) ? (" -ep " + $firstVertexSnappedEdgeIndex + " " + $firstVertexSnappedSplitDistance) : "");
      float $previousAbsoluteSplitDistance, $currentAbsoluteSplitDistance, $relativeSplitDistanceFromPreviousSplitPoint;
      for ($k=0; $k<size($orderedEdgeSplitPathIndices); $k++)
      {
         // APPEND EDGE INDEX:
         $currentSliceSplitCmd += (" -ep " + $orderedEdgeSplitPathIndices[$k] + " ");

         // APPEND SPLIT DISTANCE WITH SPACING FROM "CLOSEST ENDPOINT":
         if ($orderedEdgeSplitPathDistances[$k]>0.5)
         {
            if ($orderedVertexFirstRailPathIndices[$k]==$orderedVertex0Indices[$k])
            {
               $previousAbsoluteSplitDistance = 1 - pow((float)($multiSlices-$i+1)*$splitIntervalSize, $multiSliceDropoffPower);
               $currentAbsoluteSplitDistance =  1 - pow((float)($multiSlices-$i)*$splitIntervalSize, $multiSliceDropoffPower);
            }
            else
            {
               $previousAbsoluteSplitDistance = pow((float)$i*$splitIntervalSize, $multiSliceDropoffPower);
               $currentAbsoluteSplitDistance  = pow((float)($i+1)*$splitIntervalSize, $multiSliceDropoffPower);
            }
         }
         else
         {
            if ($orderedVertexFirstRailPathIndices[$k]==$orderedVertex0Indices[$k])
            {
               $previousAbsoluteSplitDistance = pow((float)$i*$splitIntervalSize, $multiSliceDropoffPower);
               $currentAbsoluteSplitDistance  = pow((float)($i+1)*$splitIntervalSize, $multiSliceDropoffPower);
            }
            else
            {
               $previousAbsoluteSplitDistance = 1 - pow((float)($multiSlices-$i+1)*$splitIntervalSize, $multiSliceDropoffPower);
               $currentAbsoluteSplitDistance =  1 - pow((float)($multiSlices-$i)*$splitIntervalSize, $multiSliceDropoffPower);
            }
         }
         $relativeSplitDistanceFromPreviousSplitPoint = abs($currentAbsoluteSplitDistance-$previousAbsoluteSplitDistance) / (1-$previousAbsoluteSplitDistance);
         $currentSliceSplitCmd += ($orderedVertexFirstRailPathIndices[$k]==$orderedVertex0Indices[$k]) ? $relativeSplitDistanceFromPreviousSplitPoint : (1 - $relativeSplitDistanceFromPreviousSplitPoint);
      }
      $currentSliceSplitCmd += (($lastVertexSnappedEdgeIndex>-1) ? (" -ep " + $lastVertexSnappedEdgeIndex + " " + $lastVertexSnappedSplitDistance) : "");
      eval $currentSliceSplitCmd;
   }
}
