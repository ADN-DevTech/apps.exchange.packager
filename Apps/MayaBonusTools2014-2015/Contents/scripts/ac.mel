// Copyright (C) 1997-2013 Autodesk, Inc., and/or its licensors.
// All rights reserved.
//
// The coded instructions, statements, computer programs, and/or related
// material (collectively the "Data") in these files contain unpublished
// information proprietary to Autodesk, Inc. ("Autodesk") and/or its licensors,
// which is protected by U.S. and Canadian federal copyright law and by
// international treaties.
//
// The Data is provided for use exclusively by You. You have the right to use,
// modify, and incorporate this Data into other products for purposes authorized 
// by the Autodesk software license agreement, without fee.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. AUTODESK
// DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTIES
// INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF NON-INFRINGEMENT,
// MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR ARISING FROM A COURSE 
// OF DEALING, USAGE, OR TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS
// LICENSORS BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL,
// DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK AND/OR ITS
// LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY OR PROBABILITY OF SUCH DAMAGES.




//								   XX      XXXX             XXXX
//								  XXXX    XX  XX           XX  XX
//								 XX  XX  XX                    XX
//								 XX  XX  XX                   XX
//								 XXXXXX  XX    X             XX
//								 XX  XX   XX  XX            XX   X
//								 XX  XX    XXXX            XXXXXXX
//
//
//							Attribute Collection 2 - The next Generation
//

/* 
Attribute Collection Version 2.04 
(c) Roland Reyer, Autodesk GmbH, 2010/2011 
19.02.2011 
20:10
*/ 


// -------------------------------------------------------------------------


acSetTypes();

global proc acSetTypes()
{
printTrace( 5, "acSetTypes");


	global string $acTypes[];


//////////---------------TypeName-----------typeDef--------Options (after the label and the Anntotation)
	if (!size($acTypes)) {
		$acTypes = {
						"Window",			"0",            "",
						"Panel",			"0",            "0 1 1",		// tornOff visible active
						"TabLayout",		"1",            "0 2 2 //_pre_select_command",
						"ColumnLayout",     "1",            "0 0",			// adjust Children, rowSpacing
		//              "FormLayout",       "1",            "",
						"VSliderLayout",    "1",            "6 62 5",       				// # of columns, column width, offset
		                "RowLayout",        "1",            "6 0 80 80 80 80 80 80 1 0",	//numRow widthType w1 w2 w3 w4 w5 w6 adjustable offset
						"Group",            "1",            "0 1 etchedIn",
						"Grid",             "1",            "64 64 1 3",
// for controls like attrSlider, colorSlider, etc. and for buttons and icons
//   the LAST entry in the specs is always a list of attribute names
//   - to SET one entry in this string, use acSetConnectionName( $node, $index, $name )
//   - to get the list, use acGetConnectionName( $node, $index )
//   - the function acGetConnections does that too
						"AttrSlider",       "5",            "min max",
						"ColorSlider",      "5",            "",
						"AttrCheckBox",     "5",            "extraLabel",
						"AttrEnum",         "5",            "",
						"Icon",             "6",            "iconAndTextVertical empty.bmp //MEL_Commands\n",
		//              "PoseIcon",         "6",            "iconAndTextVertical empty.bmp //MEL_Commands\n",
						"ButtonRow",        "6",            "1 1 1 1 2 Button1 Button2 Button3 Button4 //MEL_Commands\n //MEL_Commands\n //MEL_Commands\n //MEL_Commands\n",
						"Button",           "6",            "100 170 //MEL_Commands\n",
		//              "PoseButton",       "6",            "",
						"Text",             "9",            "15 center boldLabelFont",
						"Separator",        "9",            "20 in",
						"Reference",        "10",           "//referencedNode"
					   };
	}

// printn("and This is the end of acSetTypes");
// printn("acTypes looks like this:");
// printStrings( $acTypes);
// printn("----------");

endTrace();
}


//----------------------Helpers----------------------------------------


// this Callback is used for all kinds of "Browse.."
global proc acFileCallback( string $uiElem, string $cmd, string $fileName, string $fileType)
{
printTrace( 6, "acFileCallback");



	if (size($fileName)) {
		textFieldButtonGrp -e -text $fileName $uiElem;
		eval $cmd;
	}
endTrace();
}

// -------------------------------------------------------------------------
// this finds a given string in an array of strings and returns the index
// if the item is not in the string array, the the size of the array is returned
// -------------------------------------------------------------------------
global proc int acStringArrayIndex( string $obj, string $array[])
{
printTrace( 6, "acStringArrayIndex");

	int $objIndex;

	for ( $objIndex = 0 ; $objIndex < size( $array) && $array[$objIndex] != $obj ; $objIndex++ );
endTrace();
	return $objIndex;
}


// -------------------------------------------------------------------------
// removes the element at $remove from the array
// -------------------------------------------------------------------------
global proc string[] stringArrayRemoveElement( string $array[], int $remove)
{
printTrace( 6, "stringArrayRemoveElement");

	string $out[];
	for ( $i=0 ; $i<$remove ; $i++ ) $out[$i] = $array[$i];
	for ( $i=$remove+1 ; $i<size($array) ; $i++ ) $out[$i-1] = $array[$i];
endTrace();
	return $out;
}


// -------------------------------------------------------------------------
// removes the element at $index from the array
// -------------------------------------------------------------------------
//global proc string[] acStringArrayRemoveIndex( int $index, string $array[])
//{
//printTrace( 5, "acStringArrayRemoveIndex");
//
//
//	string $new[];
//	for ( $i=0 ; $i < $index && $i < size($array) ; $i++ ) $new[$i] = $array[$i];
//	for ( ; $i < size($array)-1 ; $i++ ) $new[$i] = $array[$i+1];
//	return $new;
//endTrace();
//}


// -------------------------------------------------------------------------
// turns a string array into a string in the form { "elem1", "elem2", "elem3", ...}
// -------------------------------------------------------------------------
global proc string acStringArrayToString( string $array[])
{
printTrace( 6, "acStringArrayToString");

	string $new = "{";
	for ( $s in $array ) $new += "\"" + $s + "\",";
	$new = `substring $new 1 (size($new)-1)`;			// remove the last komma
	$new += "}";
endTrace();
	return $new;
}


// -------------------------------------------------------------------------
// turns a string array into a string in the form "elem1 elem2 elem3"
// -------------------------------------------------------------------------
global proc string acStringArrayToPlainString( string $array[])
{
printTrace( 6, "acStringArrayToPlainString");

	string $new;
	for ( $s in $array ) $new += $s + " ";
	$new = `substring $new 1 (size($new)-1)`;			// remove the last space
endTrace();
	return $new;
}


//------------------------------------------------------------------------
// create a connection from $attr to  ($node + ".connection[" + $index + "]")
//------------------------------------------------------------------------
global proc acConnect( string $node, int $index, string $attr)
{
printTrace( 3, "acConnect " + $node);


	acSetRedrawStack( $node);

	global int $acAllowCleanup;
	$acAllowCleanup = 0;

// bugfix for blendshape attributes
	string $queryOkName = acGetRealAttrName( $attr);

// printn("acConnect: attr " + $attr + " at index " + $index + " on node " + $node);
	string $tmp[];
	tokenize $attr "." $tmp;
	string $obj = $tmp[0];
	tokenize $queryOkName "[" $tmp;
	$attr = $obj + "." + $queryOkName;

	if (`objExists $obj` && `attributeExists $tmp[0] $obj`) {
// hier wird evtl. gar keine Verbindung hergestellt, sondern nur der Name gespeichert
		connectAttr $attr ($node + ".connection["+ $index + "]");

		// if this node is a CONTROL (attrSomething) then
		// save the name of the connection
		// buttons and icons do this by themselves
		// donno if I have to check the type here
		int $typeDef = acTypeDef(acGetNodeType( $node));
		if ($typeDef == 5 || $typeDef == 6) acSetConnectionName( $node, $index, $attr );
		
		// hier wird jetzt eine Verbindung von einem Obj-Attr zur ScriptNode hergestellt, damit man evtuelle
		// Aenderungen in der History ueberwachen kann
		// allerdings muss geprueft werden, ob eine solche Verbindung nicht schon besteht (catch)
//		if (`objectType $obj` != "network" && $tmp[0] != "message") {
//			string $parentScriptNode = acGetParentScriptNode( $node);
//			disconnectAttr -na $attr ($parentScriptNode + ".attribute");
//			connectAttr -na ($attr) ($parentScriptNode + ".attribute");
//		}

	} else {
		catch( `setAttr ($node + ".c[" + $index + "]") 0`);
		catch( error ("Could not connect to Attribute > " + $attr + " <"));
	}
endTrace();
}


//--------------------------------------------------------
// checks all connections of $node and all of its children
// removes empty plugs and redraws those entries
//--------------------------------------------------------
global proc acCleanupConnections( string $node)
{
printTrace( 3, "acCleanupConnections " + $node);

// finds lost Connections on $node and all of its children

	global int $acAllowCleanup;
//printn("this is acCleanupConnections - allow = " + $acAllowCleanup);
	if (`objExists $node` && $acAllowCleanup && (!`reference -isNodeReferenced $node`)) {

		acCleanupNodeData();

		string $redraw[];
		string $nodeList[] = acGetAllChildren( $node);
//		$nodeList = stringArrayCatenate( {$node}, $nodeList);
		string $lc[];		// list of lost Connections
		for ( $n in $nodeList ) {

			string $c[] = acGetIndexConnections( $n);
			for ( $i=0 ; $i<size($c) ; $i++ ) {
				if ($c[$i] == "") {
					// DO NOT cleanup plugs on icons, buttons and buttonRows
					if (acTypeDef( acGetNodeType( $n)) != 6) {
	print("remove plug # " + $i + " on node " + $n + "\n");
						acRemovePlug( $n, $i);
						$redraw[size($redraw)] = $n;
						$c = acGetIndexConnections( $n);
//						$i--;
//acShowEntry( $n);
					} else warning("Broken Connection on Entry \"" + (acGetLabel( $n)) + "\" (" + (acGetNodeType($n)) + ")! Please Check!");
				}
			}

			//check and repair empty ScriptNodes
			if (acTypeDef( acGetNodeType( $n)) == 0				// this is a Panel or window
				&& size( acGetIndexConnections( $n)) == 0		// and it is all allone
				&& acGetOpt( "acPrefRestoreDefaultLayout", 1)) {	// and we always want at least the defaultLayout (TabLayout + ColumnLayout)

				acCreateDefaultLayout( $n);
			}
			
		}
		$redraw = stringArrayRemoveDuplicates( $redraw);
	// redraw all the nodes, where a lost connection was found
	// if there were NO lost connections, it must be an undo operation
	// - in this case, there is no chance to find out, what has to be redrawn, so redraw ALL
		if (size($redraw)) for ( $n in $redraw ) acRedrawEntry( $n);
		else acRedrawEntry( $node);
	}
	$acAllowCleanup = 1;
endTrace();
}


//----------------------------------------------------------------------------------

global proc acCopyEntry( string $node, int $from, int $to)
{
printTrace( 3, "acCopyEntry " + $node);

// copies the values and connection from one entry to another
// used for reordering the entries

	string $toEntry = ($node + ".connection[" + $to + "]");
	string $fromEntry = ($node + ".connection[" + $from + "]");

	acDeletePlug( $node, $to);


// jetzt alle Connections neu aufbauen
	string $attr[] = acGetConnections( $node, $from);

//	if (!size($attr)) setAttr 
	for ( $i=0 ; $i<size($attr) ; $i++ ) acConnect( $node, $to, $attr[$i]);

endTrace();
}

global proc acRemovePlug( string $node, int $index)
{
printTrace( 3, "acRemovePlug " + $node);

// removes a plug and closes the gap
	acSetRedrawStack( $node);

	int $lastPlug = size(`listAttr -m ($node + ".connection")`) - 1;
	for ( $i=$index ; $i<$lastPlug ; $i++ ) acCopyEntry( $node, $i+1, $i);

	acDeletePlug( $node, $lastPlug);
endTrace();
}

global proc acRemoveEntry( string $node, int $cleanup, int $deleteUI)
{
printTrace( 3, "acRemoveEntry " + $node);

// checks, if there's a "remove" function for this specific type


	string $type = acGetNodeType( $node);
	string $parent = acGetParentNode( $node);
	string $editWin = acGetEditWinName( $node);

	acDeleteEditWin( $node);

	if (`exists ("acRemove" + $type + "Entry")`) eval("acRemove" + $type + "Entry(\"" + $node + "\", " + $cleanup + ", " + $deleteUI + ")");
	else acRemoveSimpleEntry( $node, $cleanup, $deleteUI);

	$type = acGetNodeType( $parent);
	if (`exists ("ac" + $type + "ChildDeleted")`) eval("ac" + $type + "ChildDeleted(\"" + $parent + "\", " + $cleanup + ", " + $deleteUI + ")");
	else acChildDeleted( $parent, $cleanup, $deleteUI);

		

endTrace();
}

global proc acRemoveSimpleEntry( string $node, int $cleanup, int $deleteUI)
{
printTrace( 3, "acRemoveSimpleEntry " + $node);

// removes an entry by calling a function "acRemove-TYPE-Entry", where "-TYPE-" is the string "type" of that entry
// that "acRemove...Entry" function should proceed and call acRemoveEntry for all subsequent nodes
// if type is just a simple entry (e.g. a slider) then "acRemove....Entry" shouldn't do anything at all - the entry is removed and the UI is deleted
// if type is a parent type (a layout, e.g. a group or a tab) then the according "acRemove....Entry" function will
//      call acRemoveEntry with $cleanup=0 to remove all children nodes and entries without reordering
//      when the UI of the parent is deleted, all the children are deleted as well

// gibt es diesen Entry?
	string $parent = acGetParentNode( $node);
	int $parentIndex = acGetParentIndex( $node);
	string $type = acGetNodeType( $node);
	string $children[] = acGetNodeChildren( $node);
	string $uiName = acGetUIDeleteName( $node);
	string $parentScriptNode = acGetParentScriptNode( $node);

// removes all children of type "network" or "script"
	for ( $ch in $children) acRemoveEntry( $ch, 0, 0);

// first disconnect everything, otherwise the parent will also be deleted
	disconnectAttr ($node + ".message") ($parent + ".connection[" + $parentIndex + "]");

	delete -hi "none" $node;

	if ($cleanup) acRemovePlug( $parent, $parentIndex);

// delete the UI - first check, if it exists?
// windows are deleted by their script nodes
	if ($deleteUI && $type != "Window") deleteUI $uiName;

endTrace();
}


global proc acDeleteEntry( string $node, int $cleanup, int $deleteUI)
{
printTrace( 3, "acDeleteEntry " + $node);

	// this function is called from the UI (Delete button in Groups and RMB menus)
	// and simply removes an entry PLUS updates EditWin and Hierarchy Win
	string $parent = acGetParentNode( $node);
	acRemoveEntry( $node, $cleanup, $deleteUI);
	acUpdateOtherViews( $parent);
endTrace();
}

global proc acChildDeleted( string $node, int $cleanup, int $deleteUI)
{
printTrace( 3, "acChildDeleted");


endTrace();
}



//--------------------------------------------------------------------------------------------
global proc acSwapEntries( string $node, int $a, int $b)
{
printTrace( 3, "acSwapEntries " + $node);

	string $connectionsA[] = acGetConnections( $node, $a);
	acCopyEntry( $node, $b, $a);
	acDeletePlug( $node, $b);
	for ( $ca in $connectionsA ) acConnect( $node, $b, $ca);
endTrace();
}

//--------------------------------------------------------------------------------------------



global proc int acInsertEntryPlug( string $node, int $index)
{
printTrace( 3, "acInsertEntryPlug " + $node);

// DANGEROUS: this works fine if the entry indicies are continuous
	int $entryNum = `getAttr -s ($node + ".connection")`;
//printn("Insert Entry Plug: Target = " + $index);
//printn("BEFORE: List of Connections:");
//printStrings( (acGetIndexConnections( $node)));
//printn("------------------------------");
	if ($index < 0 || $index > $entryNum) {
endTrace();
		return $entryNum;
	} else {
		for ( $i=$entryNum ; $i>$index ; $i-- ) {
//printn("Insert... moving entry " + ($i-1) + " to " + $i);
			acCopyEntry( $node, $i-1, $i);
		}
//printn("Insert... delete plug: " + $index);
//string $attr[] = acGetConnections( $node, $index);
//for ( $a in $attr ) disconnectAttr $a ($node + ".connection[" + $index + "]");
		acDeletePlug( $node, $index);
//printn("AFTER: List of Connections:");
//printStrings( (acGetIndexConnections( $node)));
//printn("------------------------------");
endTrace();
		return $index;
	}
}


//------------------------------------------------------------------------
//------------------------------------------------------------------------
//------------------------------------------------------------------------
//------------------------------------------------------------------------

// BUGFIX BUGFIX BUGFIX BUGFIX BUGFIX BUGFIX BUGFIX BUGFIX BUGFIX BUGFIX BUGFIX BUGFIX BUGFIX BUGFIX BUGFIX
// BUGFIX BUGFIX BUGFIX BUGFIX BUGFIX BUGFIX BUGFIX BUGFIX BUGFIX BUGFIX BUGFIX BUGFIX BUGFIX BUGFIX BUGFIX
// BUGFIX BUGFIX BUGFIX BUGFIX BUGFIX BUGFIX BUGFIX BUGFIX BUGFIX BUGFIX BUGFIX BUGFIX BUGFIX BUGFIX BUGFIX
// BUGFIX BUGFIX BUGFIX BUGFIX BUGFIX BUGFIX BUGFIX BUGFIX BUGFIX BUGFIX BUGFIX BUGFIX BUGFIX BUGFIX BUGFIX
// BUGFIX BUGFIX BUGFIX BUGFIX BUGFIX BUGFIX BUGFIX BUGFIX BUGFIX BUGFIX BUGFIX BUGFIX BUGFIX BUGFIX BUGFIX
// fix problems in this Node and all it's children
global proc acFixTree( string $node)
{
printTrace( 3, "acFixTree " + $node);

	if ((!`reference -isNodeReferenced $node`)) {

		string $store;
	// BUGFIX
	// remove attributes and restore them as *NOT STORABLE*
	
		string $children[] = acGetAllChildren( $node);
	//	$children = stringArrayCatenate( {$node}, $children);
		for ( $c in $children ) {
// 			$store = `getAttr ($c + ".ui")`;
// 			deleteAttr -at "ui" $c;
// 			addAttr -sn ui -ln uiName -storable 0		-dt "string"    $c;
// 			setAttr -type "string" ($c + ".ui") $store;
// 	
// 			$store = `getAttr ($c + ".ew")`;
// 			deleteAttr -at "ew" $c;
// 			addAttr -sn ew -ln editWinName -storable 0  -dt "string"    $c;
// 			setAttr -type "string" ($c + ".ew") $store;
		}
	}	// else warning( $node + " is a referenced Node and should not be bug-fixed");


endTrace();
}
// BUGFIX BUGFIX BUGFIX BUGFIX BUGFIX BUGFIX BUGFIX BUGFIX BUGFIX BUGFIX BUGFIX BUGFIX BUGFIX BUGFIX BUGFIX
// BUGFIX BUGFIX BUGFIX BUGFIX BUGFIX BUGFIX BUGFIX BUGFIX BUGFIX BUGFIX BUGFIX BUGFIX BUGFIX BUGFIX BUGFIX
// BUGFIX BUGFIX BUGFIX BUGFIX BUGFIX BUGFIX BUGFIX BUGFIX BUGFIX BUGFIX BUGFIX BUGFIX BUGFIX BUGFIX BUGFIX
// BUGFIX BUGFIX BUGFIX BUGFIX BUGFIX BUGFIX BUGFIX BUGFIX BUGFIX BUGFIX BUGFIX BUGFIX BUGFIX BUGFIX BUGFIX
// BUGFIX BUGFIX BUGFIX BUGFIX BUGFIX BUGFIX BUGFIX BUGFIX BUGFIX BUGFIX BUGFIX BUGFIX BUGFIX BUGFIX BUGFIX
//---------------------------------------------------------------------------------------------------------
//---------------------------------------------------------------------------------------------------------
//---------------------------------------------------------------------------------------------------------
//---------------------------------------------------------------------------------------------------------

//---------------------------------------------------------------------------------------------------------
//---------------------------------------------------------------------------------------------------------
// This function *should* make the different versions of AC kompatible
//---------------------------------------------------------------------------------------------------------
//---------------------------------------------------------------------------------------------------------
global proc acCheckVersion( string $node)
{
printTrace( 2, "acCheckVersion " + $node);


	// is there a version attribute?
	if (!`attributeQuery -exists -node $node "version"`) {
// printn(" - this node has NO version attribute");

		if ((!`reference -isNodeReferenced $node`)) {

			// there is NO "version" attribute - this must be an alpha version
			addAttr -ln "redrawBell" -at "long" $node;
			addAttr -ln "redrawPointer" -at "long" $node;
			addAttr -ln "redrawStacksize" -at "long" $node;
// 			addAttr -ln "jobId" -at "long" -dv -1 -storable false $node;
			addAttr -ln "preferences" -sn "prefs" -dt "string" $node;
	
			addAttr -ln version -at double -dv 0 $node;

			deleteAttr -at "uiName" $node;
			deleteAttr -at "editWinName" $node;

			// go through ALL nodes and insert the annotation to the specs
	//		string $allNodes[] = stringArrayCatenate( {$node}, (acGetAllChildren( $node)));
			string $allNodes[] = acGetAllChildren( $node);
			for ( $n in $allNodes ) {
	
				// rebuild the specs for this new version
				string $specs[] = acGetSpecs( $n);								// index 1 is missing here
				string $ann = acGetAnnotation( $n);
				$specs = stringArrayCatenate( {$ann}, $specs);	// put index 1 (now used for the annotation) in front
	
				// check the count of options
				string $options[] = acTypeOptions( acGetNodeType( $n));
	if (size($specs) < size($options)) {
	// 	printn("specs BEFORE compared to default options:");
	// 	printStrings( $specs);
	// 	printn("specs AFTER compared to default options:");
	// 	printStrings( $options);
	// 	printn("------------------");
	}
				if (size($specs) < size($options)) $specs = $options;
	
				acSetSpecs( $n, $specs);					// ok now
				acSetAnnotation( $n, "");
	
			}
//			setAttr ($node + ".version") 1.9;		// beta 1, March 16, 2004 
			setAttr ($node + ".version") 2.01;		// Bug fixing, December 2010 
		} else warning( $node + " cannot be version-checked because it is a reference");
	}


endTrace();
}
//---------------------------------------------------------------------------------------------------------
//---------------------------------------------------------------------------------------------------------



//---------------------- Create Entry Types-------------------------------------------

global proc acCreateEntryPlug( string $nodeName)
{
printTrace( 3, "acCreateEntryPlug " + $nodeName);

//  addAttr -ln entry       -multi  -at compound    -nc 5 $nodeName;
	addAttr -sn t  -ln type							-dt "string"    $nodeName;
// 	addAttr -sn ui -ln uiName -storable 0			-dt "string"    $nodeName;
//	addAttr -sn ui -ln uiName -storable 0	-multi	-dt "string"    $nodeName;
	addAttr -sn cc -ln cCount						-at short       $nodeName;
	addAttr -sn c  -ln connection			-multi	-at message     $nodeName;
	addAttr -sn sp -ln specs				-multi	-dt "string"    $nodeName;

// 	addAttr -sn ew -ln editWinName -storable 0  -dt "string"    $nodeName;
endTrace();
}

//----------------------------Set all Values for an entry ------------------
global proc acMakeEntry( string $node, string $parentNode, int $index, string $type, string $label, string $ann, string $specs[])
{
printTrace( 3, "acMakeEntry " + $node);

// creates a connection to the parent
// sets "type" and "specs" attributes

global string   $acActiveParent;
global string   $acActiveChild;         // the last entry that was created
global string   $acActiveTab;           // the tabLayout
global string   $acActiveGroup;

	acSetNodeType( $node, $type);

	if (size($parentNode)) {
		$index = acInsertEntryPlug( $parentNode, $index);
		acConnect( $parentNode, $index, ($node + ".message"));
	}

	acSetLabel( $node, $label);
	acSetAnnotation( $node, $ann);
	acSetSpecs( $node, $specs);

	$acActiveParent = $parentNode;
	$acActiveChild = $node;
	if (acGetNodeType( $node) == "Group") $acActiveGroup = $node;
	if (acGetNodeType( $parentNode) == "TabLayout") $acActiveTab = $node;

//	acUpdateOtherViews( $parentNode);
endTrace();
}

global proc string acCreateNode( string $parentNode, int $index, string $type, string $label, string $ann, string $specs[])
{
printTrace( 2, "acCreateNode for " + $parentNode);

//printfn("---this is acCreateNode");
	global string   $acActiveParent;
	global string   $acActiveChild;

	string $sel[] = `ls -sl`;

	string $nodeName;
	$nodeName = substituteAllString( $label, ".", "_");
	$nodeName = substituteAllString( $nodeName, "[", "_");
	$nodeName = substituteAllString( $nodeName, "]", "_");
// printn("acCreateNode: specs = >" );
// printStrings( $specs);
// printn("acCreateNode: Label = >" + $specs[0] );
// printn("acCreateNode: neuer Name = >" + $nodeName);

	string $node = `createNode -n ($nodeName) network`;
	setAttr ($node + ".ihi") 0;
	acCreateEntryPlug( $node);
	int $entryNum = acMakeEntry( $node, $parentNode, $index, $type, $label, $ann, $specs);

	if (acTypeDef( $type) < 5) $acActiveParent = $node;
	else $acActiveChild = $node;

	select -r $sel;

endTrace();
	return $node;

}

//--------------------------------------------------------------------------
//--------------------------------------------------------------------------
//--------------------------------------------------------------------------



//------------------------------------------------------------------------
//------------------------------------------------------------------------
//------------------------------------------------------------------------

global proc string[] acGetSelectedAttributes()
{
printTrace( 4, "acGetSelectedAttributes");

	global string $gChannelBoxName;
	string $attrList[];
	int $i = 0;

	string  $objList[] = `channelBox -q -mol $gChannelBoxName`;
	string  $shpList[] = `channelBox -q -sol $gChannelBoxName`;
	string  $hstList[] = `channelBox -q -hol $gChannelBoxName`;
	string  $outList[] = `channelBox -q -ool $gChannelBoxName`;
	string  $attrMList[] = `channelBox -q -sma $gChannelBoxName`;
	string  $attrSList[] = `channelBox -q -ssa $gChannelBoxName`;
	string  $attrHList[] = `channelBox -q -sha $gChannelBoxName`;
	string  $attrOList[] = `channelBox -q -soa $gChannelBoxName`;


	for ($obj in $objList) {
		for ($attr in $attrMList) {
		$attrList[$i++] = $obj + "." + $attr;
		}
	}
	for ($obj in $shpList) {
		for ($attr in $attrSList) {
		$attrList[$i++] = $obj + "." + $attr;
		}
	}
	for ($obj in $hstList) {
		for ($attr in $attrHList) {
		$attrList[$i++] = $obj + "." + $attr;
		}
	}
	for ($obj in $outList) {
		for ($attr in $attrOList) {
		$attrList[$i++] = $obj + "." + $attr;
		}
	}
endTrace();
	return $attrList;
}

global proc string acGetRealAttrName( string $objAttr)
{
printTrace( 6, "acGetRealAttrName " + $objAttr);
endTrace();


// das problem ist, dass es drei Faelle gibt
// 1. kein Alias
// 2. ein User defined Alias
// 3. ein Alias, wie in Blend Shape


// Nummer 2 und 3 sind sehr schwer zu unterscheiden, weil nach dem 1. Aufruf
// von registerAttr bzw. isRegAttr der REALE Name des Attrs gespeichert
// werden soll. d.h. hier kommt der REALE Name an und "ls" wie auch
// "listAttr" zeigen nur das Alias an (bei Blend Shapes)


	string  $tmp[];
	string  $aliasName;


	$tmp = `ls -sn $objAttr`;
	tokenize $tmp[0] "." $tmp;
	string $objName = $tmp[0];
	string $realName = $tmp[1];

// printn("gesucht wird nach >" + $objAttr + "<");
// printn("objName = " + $objName);
	$tmp = `aliasAttr -q $objName`;
	if (!size($tmp)) return $realName;          // no Aliases at all


	$tmp = `listAttr -sn $objAttr`;
	$aliasName = $tmp[0];
	if ($aliasName != $realName) return $realName;  // einfaches User Alias


	$tmp = `aliasAttr -q $objName`;
	for ( $j=0 ; $j<size($tmp) ; $j+=2 ) {
		if ($aliasName == $tmp[$j]) {
			$realName = $tmp[$j+1];
		}
	}
	return $realName;


}

global proc string acConvertAttr( string $attr)
{
printTrace( 6, "acConvertAttr " + $attr);

// converts an aliased attrName to the real obj.attr name

	string $tmp[];
	tokenize $attr "." $tmp;
endTrace();
	if (`objExists $tmp[0]`) return ($tmp[0] + "." + acGetRealAttrName( $attr));
	else return "";
}

global proc acAddSelToNewGroup( string $node, string $name)
{
printTrace( 3, "acAddSelToNewGroup " + $node);

	if (size(acGetSelectedAttributes())) {
		acAddSelectedAttrsToGroup( acCreateGroupEntry( $node, -1, $name), -1);       // oh weh, das ist nicht wirklich richtig
		acUpdateOtherViews( $node);
	}
endTrace();
}

global proc addAttrToGroup( string $node, string $attr, string $attrType, int $index)
{
printTrace( 3, "addAttrToGroup " + $node);


	string $tmp[];
	tokenize $attr "." $tmp;
	string $attrNode = $tmp[0];
	string $attrName = $tmp[1];


// Bugfix: attributeQuery can't handle attributes with alias and also no index

	string $queryOkName = acGetRealAttrName( $attr);
	string $tmp[];
	tokenize $queryOkName "[" $tmp;
	$queryOkName = $tmp[0];

	float $min = 0;
	float $max = 0;
//printn("Attribut: " + $attr);
// Funktion acFindAttrMinMax( string $attrNode, string $attrName)
	if (size(`listAttr -userDefined $attr`)) {
//printn("User defined Attr");
		// this is a user defined (dynamic) attribute
		// I can use "addAttr" to query min/max/softMin/softMax
	}
	if ((int)(`attributeQuery -rangeExists -n $attrNode $queryOkName`)) {
		float $tmp[] = `attributeQuery -range -n $attrNode $queryOkName`;
//printn("Range gefunden: " + $tmp[0] + " - " + $tmp[1]);
		$min = $tmp[0];
		$max = $tmp[1];
	}


	switch ($attrType) {
		case "bool" :
			acCreateAttrCheckBoxEntry( $node, $index, $attr, "");
			break;
		case "doubleLinear" :
			if ($min == 0 && $max == 0) { $min = -20; $max = 20; }
			acCreateAttrSliderEntry( $node, $index, $attr, $min, $max);
			break;
		case "doubleAngle" :
			if ($min == 0 && $max == 0) { $min = -180; $max = 180; }
			acCreateAttrSliderEntry( $node, $index, $attr, $min, $max);
			break;
		case "long" :
		case "double" :
			if ($min == 0 && $max == 0) { $min = -5; $max = 5; }
			acCreateAttrSliderEntry( $node, $index, $attr, $min, $max);
			break;
		case "color" :
			acCreateColorSliderEntry( $node, $index, $attr);
			break;
		case "enum" :
			acCreateAttrEnumEntry( $node, $index, $attr);
			break;
		default:
			acCreateAttrSliderEntry( $node, $index, $attr, $min, $max);
			break;
	}
endTrace();
}

global proc acAddSelectedAttrsToGroup( string $node, int $index)
{
printTrace( 3, "acAddSelectedAttrsToGroup " + $node);


	string $attrList[] = acGetSelectedAttributes();
// printn("------------Liste der Attribute----------------");
// if (acDoPrint()) print $attrList;
// printn("-----------------------------------------------");

	for ( $i=0 ; $i<size($attrList) ; $i++ ) {
		$attr = $attrList[$i];
		string $attrType = `getAttr -type $attr`;
	
		string $tmp[];
		tokenize $attr "." $tmp;
		string $attrNode = $tmp[0];
		string $attrName = $tmp[1];

// is this a color compound?
		if ($attrType == "float"
		  && $i < size($attrList)-2
		  && (toupper(`substring $attr (size($attr)) (size($attr))`) == "R")
		  && (toupper(`substring $attrList[$i+1] (size($attrList[$i+1])) (size($attrList[$i+1]))`) == "G")
		  && (toupper(`substring $attrList[$i+2] (size($attrList[$i+2])) (size($attrList[$i+2]))`) == "B")
		  && (`substring $attr 1 (size($attr)-1)` == `substring $attrList[$i+1] 1 (size($attrList[$i+1])-1)`)
		  && (`substring $attr 1 (size($attr)-1)` == `substring $attrList[$i+2] 1 (size($attrList[$i+2])-1)`)
		  ) {
			$tmp = `attributeQuery -lp -n $attrNode $attrName`;
			string $parentAttr = $tmp[0];
			if (size($parentAttr)) {
				if (`getAttr -type ($attrNode + "." + $parentAttr)` == "float3") {
// printn("HEY, dies ist ein COLOR Attribut!!!");
					$attr = $attrNode + "." + $parentAttr;
					$attrType = "color";
					$i += 2;
				}
			}
		}
		addAttrToGroup( $node, $attr, $attrType, $index);
		if ($index > -1) $index++;
	}
	acRedrawEntry( $node);

endTrace();
}

//--------------------------------------------------
global proc acInsertDirect( string $node, string $type)
{
printTrace( 3, "acInsertDirect " + $node);

	global string $acActiveParent;
	global string $acActiveChild;


	string $parent = acGetParentNode( $node);
	int $index = acGetParentIndex( $node);
	if ((acGetNodeType( $node) == "Group" || acGetNodeType( $node) == "Grid") && !size(acGetNodeChildren( $node))) {
		$parent = $node;
		$index = 0;
	}

	string $label = $type;
	string $specs[] = acTypeOptions( $type);
	string $ann;

// printn("insert new :" + $type);
// if (acDoPrint()) print $specs;
// printn("-----------------");
	string $node = acCreateNode( $parent, $index, $type, $label, $ann, $specs);
	$label = substituteAllString( $node, "_", " ");
	acSetSpecs( $node, $specs);

	int $typeDef = acTypeDef( $type);
	if ($typeDef < 5) $acActiveParent = $node;
	else $acActiveChild = $node;

	acRedrawEntry( $parent);

endTrace();
}




// -------------------------------------------------------------------------
// -------------------------------------------------------------------------
global proc acCheckAutoRedraw()
{
// existiert eine autoRedrawNode?
// gibt's den entspr. scriptJob?
//   finde eine solche node (KEINE referenz)
//   loesche einen evtl. alten scriptJob
//   stelle den ScriptJob her

printTrace( 4, "acCheckAutoRedraw");

	global string $acAutoRedrawNode;
	global int $acAutoRedrawScriptJob;
	global string $acRedrawStack[];
	global int $acStackPointer;			// additional pointer to distinguish between undo and redo


	if (!`objExists $acAutoRedrawNode` || (`reference -isNodeReferenced $acAutoRedrawNode`)) {
printn("there is no autoRedrawNode or it is a reference");
		// there is no atoRedrawNode or it is a reference node
		// delete the scriptJob (if there is one)
		$acAutoRedrawNode = "";

		clear $acRedrawStack;
		$acRedrawPointer = 0;

		if ($acAutoRedrawScriptJob && `scriptJob -exists $acAutoRedrawScriptJob`) scriptJob -kill $acAutoRedrawScriptJob;

		// that was cleanup
		// now find a new autoRedrawNode

		string $scriptNodes[] = acScriptNodes();
		for ( $s in $scriptNodes ) {
			if (!`reference -isNodeReferenced $s`) {
				$acAutoRedrawNode = $s;
				setAttr ($s + ".redrawPointer") 0;
				setAttr ($s + ".redrawStacksize") 0;
				break;
			}
		}
printn("the new autoRedrawNode is now: " + $acAutoRedrawNode);
	}


	if (`objExists $acAutoRedrawNode`) {
		if (!$acAutoRedrawScriptJob || !`scriptJob -exists $acAutoRedrawScriptJob`) {
	printn("create a new scriptJob for autoRedraw");
			$acAutoRedrawScriptJob = `scriptJob -kws -compressUndo 1 -ac ($acAutoRedrawNode + ".redrawBell") "acAutoRedraw()"`;
		}
	}
endTrace();
}


// -------------------------------------------------------------------------
// -------------------------------------------------------------------------
global proc acCheckScriptNode( float $nodeId)
{
printTrace( 2, "acCheckScriptNode " + $nodeId);

	global string $gMainPane;

	global string   $acMasterNode;


	string $node;

// gibt's schon eine Main Node?
// wenn nicht, dann ist diese hier die Main Node
// print("--acCheckScriptNode --------------------\n");

	string $acNodes[] = acScriptNodes();

// finde the acScriptNode with this ID
	for ( $n in $acNodes ) if ($nodeId == (`getAttr ($n + ".nodeId")`)) $node = $n;
printn("acCheckScriptNode: found >" + $node + "<");
	// if this is the first node to check in, then do some cleanup
	// assume that this works ALWAYS
	// set a new ID for that Node (and modify the Checkin Script)
	// to bad, reference nodes should NOT be modified - is it nessessary to KNOW, which one we are working on???
	// (YES, some may be refs, some others may be real)
	acSetNewNodeID( $node);

	// BUGFIX
	// whatever has to be fixed
	acFixTree( $node);

	// check the version of the node and make changes, if nessessary
	acCheckVersion( $node);

	string $specs[] = acGetSpecs( $node);
	if ($specs[2]) {			// is the node active?
	
	// -------------------------------------------------------------------------
	// check if there's a masterNode - if not, use *any* node as master
	// referenced nodes will NOT become masterNodes/autoRedrawNodes, because they cannot be edited
	
		if (!`objExists $acMasterNode`) {
			// there is no masterNode
			$acMasterNode = $node;

		}

		acCheckAutoRedraw();

	// -------------------------------------------------------------------------
	
		acShowAC( $node);
	}

	acCleanupNodeData();

endTrace();
}

global proc acUncheckScriptNode( int $nodeId)
{
printTrace( 2, "acUncheckScriptNode " + $nodeId);

	global string   $acMasterNode;
	global string   $acActiveParent;
	global string   $acActiveTab;
	global string   $acActiveGroup;

// printn("--acUncheckScriptNode --------------------");

	string $thisNode;

	string $acNodes[] = acScriptNodes();

// -------------------------------------------------------------------------
// first find the name of the node, that currently executes *this* script
	for ( $n in $acNodes ) {
		if ($nodeId == (`getAttr ($n + ".nodeId")`)) {
			$thisNode = $n;
		}
	}

	if (!size($thisNode)) error ("Could not find acScript Node with correct ID (\"" + $nodeId + "\")");

// if this is a window, and the window exits - delete it

	if (acGetNodeType( $thisNode) == "Window") {
		string $w = acGetUIName( $thisNode);
		if (`window -exists $w`) deleteUI $w;
	}


	if ($thisNode == $acMasterNode) {
// printn("unset acMasterNode");
		$acMasterNode = "";


		$acActiveParent = "";
		$acActiveTab = "";
		$acActiveGroup = "";

		// find a new masterNode
		for ( $n in $acNodes ) if ($n != $thisNode) $acMasterNode = $n;
// printn("new  acMasterNode is now >" + $acMasterNode + "<");

	}

	string $panelName = acGetUIDeleteName( $thisNode);
	if (`scriptedPanel -exists $panelName`) acClosePanel( $panelName);


	acCleanupNodeData();

	evalDeferred( "acCheckAutoRedraw()");

endTrace();
}

//-------------------------------------------------------------------------------------
global proc acSetMasterNode( string $node)
{
printTrace( 3, "acSetMasterNode " + $node);

	global string $acMasterNode;

// undoInfo -stateWithoutFlush 0;
// 	if ($node != $acMasterNode) {
// 		if (`objExists $acMasterNode`) {
// 			setAttr ($node + ".redrawPointer") (`getAttr  ($acMasterNode + ".redrawPointer")`);
// 			setAttr ($node + ".redrawStacksize") (`getAttr  ($acMasterNode + ".redrawStacksize")`);
// 		} else {
// 			setAttr ($node + ".redrawPointer") 0;
// 			setAttr ($node + ".redrawStacksize") 0;
// 		}
		$acMasterNode = $node;
// 	}
// undoInfo -stateWithoutFlush 1;
endTrace();
}

//-------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------
global proc acCreateDefaultLayout( string $node)
{
printTrace( 3, "acCreateDefaultLayout for " + $node);


	global string   $acActiveParent;

	acCreateTabLayoutEntry( $node, -1, "TabLayout");
	acCreateColumnLayoutEntry( $acActiveParent, -1, "Tab 1", "");
endTrace();
}
	
	
global proc string acCreateMainNode()
{
printTrace( 2, "acCreateMainNode");

	global string $acMasterNode;
	global string $acAutoRedrawNode;		// this node is the ones that has the right stackPointer

	global string $acRedrawStack[];
	global int $acStackPointer;			// additional pointer to distinguish between undo and redo

	string $sel[] = `ls -sl`;

	$node = acCreatePanelNode( "", -1, "Attribute Collection");

	addAttr -ln nodeId -at long $node;
	acSetNewNodeID( $node);				// sets the ID and the before/after script

//	addAttr -ln "pose" -multi -at "message" $node;
	addAttr -ln "redrawBell" -at "long" $node;
	addAttr -ln "redrawPointer" -at "long" $node;
	addAttr -ln "redrawStacksize" -at "long" $node;
// 	addAttr -ln "jobId" -at "long" -dv -1 -storable false $node;
	addAttr -ln "preferences" -sn "prefs" -dt "string" $node;
	if (acGetOpt( "acPrefLockUI", 0)) {
		warning "New Script Node for Attribute Collection created - this unlocks the UI";
		optionVar -iv "acPrefLockUI" 0;
	}
	if (acGetOpt( "acPrefSave", 1)) acSetPrefString( $node, (acSavePrefs()));;

	addAttr -ln version -at double -dv 1.9 $node;

	// do we have a MasterNode?
	if ((!size( $acMasterNode)) || (!`objExists $acMasterNode`)) {
		// there is no $acMasterNode - so this one becomes the masternode
		$acMasterNode = $acAutoRedrawNode = $node;

		clear $acRedrawStack;
		$acRedrawPointer = 0;

		acSetLabel( $node, "Attribute Collection");
	}

	select -r $sel;

	acCheckAutoRedraw();
endTrace();

	return $node;
}

//-------------------------------------------------------------------------------------

global proc string acCreateScriptNode()
// returns the name of the Master Node
// only the master node can live in a panel (all others have to live in windows)
{
printTrace( 2, "acCreateScriptNode");

// printn("Creating a new Script Node");
	string $node = acCreateMainNode();
	acCreateDefaultLayout( $node);


endTrace();
	return $node;
}

//-------------------------------------------------------------------------
//-------------------------------------------------------------------------
//-------------------------------------------------------------------------
//-------------------------------------------------------------------------
//-------------------------------------------------------------------------
//-------------------------------------------------------------------------
//-------------------------------------------------------------------------

global proc ac()
{
printTrace( 1, "ac");

// gibt es schon eine acScript Node (die Master Node)?
	global string $acMasterNode;

	acSetTypes();

	acShowAC( $acMasterNode);

// sind Attribute selektiert? Kann ich die laden?
	string $visTab = acVisibleTab( $acMasterNode);
	if (!acIsLocked( $visTab)) acAddSelToNewGroup( $visTab, "acGroup");

endTrace();
}

//-------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------

// global proc acShowEntry( string $entry)
// {
// printTrace( 6, "acShowEntry");

// 	print ("\n---------Node: " + $entry + "\n");
// 	print (" Type:\t\t" + (`getAttr ($entry + ".type")`) + "\n");
// 	print (" UI Name:\t\t" + (`getAttr ($entry + ".uiName")`) + "\n");
// 	print (" Conn. Count:\t\t" + (`getAttr ($entry + ".cCount")`) + "\n");
// 	print (" List of Connections:\n");
// 	print ( acGetIndexConnections( $entry));
// 	print ("----List of Specs:\n");
// 	print ( acGetSpecs( $entry));
// 	print ("-------------------------------------------------------\n");
// endTrace();
// }






// global proc acCleanup( string $node, int $withChildren)
// {
// printTrace( 4, "acCleanup " + $node);


// 	int $i = 0;
// 	string $plugs[];
// 	while ($i < size(($plugs = `listAttr -m ($node + ".connection")`))) {

// // calculate the index of this plug
// 		string $tmp[];
// 		tokenize $plugs[$i] "[" $tmp;
// 		tokenize $tmp[1] "]" $tmp;
// 		int $index = (int)$tmp[0];


// // check if the plug is empty
// 		if (!size((`listConnections -p true ($node + "." + $plugs[$i])`))) {

// // the plug is empty, remove it
// printn("Removing Plug " + $index + " from " + $node);
// 			acDeletePlug( $node, $index);

// 		} else {
// // the plug is *not* empty, does it have the correct index?
// 			if ($index != $i) {
// printn("Copy plug " + $index + " to " + $i );
// 				acCopyEntry( $node, $index, $i);
// 				acDeletePlug( $node, $index);
// 			}
// 			$i++;
// 		}
// 	}
// 	if ($withChildren) {
// 		string $ch[] = acGetNodeChildren( $node);
// 		for ($c in $ch)  acCleanup( $c, 1);

// 	}

// endTrace();
// }



// -------------------------------------------------------------------------
// acGetOpt gets an optionVar value
// if the identifier can not be found then the default will be returned
// -------------------------------------------------------------------------
global proc int acIsLocked( string $node)
{
printTrace( 5, "acIsLocked");

	int	$lockUI	= acGetOpt( "acPrefLockUI", 0) || (`reference -isNodeReferenced $node`);
	$lockUI = $lockUI && !acGetOpt( "acExpertMode", 0);
//printn("lockUI mode is now: " + $lockUI);

//for testing
//    int	$lockUI	= 0;

endTrace();
    return $lockUI;
}


// -------------------------------------------------------------------------
// acGetOpt gets an optionVar value
// if the identifier can not be found then the default will be returned
// -------------------------------------------------------------------------
global proc int acGetOpt( string $label, int $default)
{
printTrace( 5, "acGetOpt: " + $label);
endTrace();

	if (`optionVar -exists $label`) return `optionVar -q $label`;
	else return $default;

}

// -------------------------------------------------------------------------
// lists all acScriptNodes that have a "nodeId" attribute
// -------------------------------------------------------------------------
global proc string[] acScriptNodes()
{
printTrace( 4, "acScriptNodes");

//ACHTUNG: bei der Kompatibilitaet drauf achten, dass ALTE acScript Nodes nicht mitgezaehlt werden!!!
	string $list1[] = `ls -type script`;
	string $list2[];
	for ( $l in $list1 ) {
		if (`attributeQuery -n $l -ex "nodeId"`) $list2[size($list2)] = $l;
	}
endTrace();
	return ( $list2);
}

// -------------------------------------------------------------------------
// returns the typeDef integer
// -------------------------------------------------------------------------
global proc int acTypeDef( string $type)
{
printTrace( 5, "acTypeDef: " + $type);
endTrace();

// returns the typeDef integer
// 0 = window oder panel
// 1 = controlLayout
// 5 = attrControl
// 6 = buttons and icons
// 9 = text, separator etc

// printn("This is acTypeDef for type " + $type);

	global string $acTypes[];
	for ( $i=0 ; $i<size($acTypes) ; $i+=3 ) {
		if ($acTypes[$i] == $type) return (int)$acTypes[$i+1];
	}
	return -1;
}

//--------------------------------------------------------------
// Sets the Type string of this node
//--------------------------------------------------------------
global proc acSetNodeType( string $node, string $type)
{
printTrace( 5, "acSetNodeType: " + $node);

	setAttr -type "string" ($node + ".type") $type;
endTrace();
}

//--------------------------------------------------------------
// Type string of the entry
//--------------------------------------------------------------
global proc string acGetNodeType( string $node)
{
printTrace( 5, "acGetNodeType: " + $node);
endTrace();

	if (`objExists $node`) return (`getAttr ($node + ".type")`);
	else return "";
}


// -------------------------------------------------------------------------
// returns the default oprtions (specs) of a certain type
// -------------------------------------------------------------------------
global proc string[] acTypeOptions( string $type)
{
printTrace( 5, "acTypeOptions: " + $type);
endTrace();

// liefert die default Optionen dieses Typs

	global string $acTypes[];

	for ( $i=0 ; $i<size($acTypes) ; $i+=3 ) {
		if ($acTypes[$i] == $type) {
			string $tmp[];
			tokenize $acTypes[$i+2] " " $tmp;
			return $tmp;
		}
	}
	return {};
}


// -------------------------------------------------------------------------
// returns wether the node has a connection to the child (at a certain index) or not
// -------------------------------------------------------------------------
global proc int acIsConnected( string $node, int $index)
{
printTrace( 5, "acIsConnected: " + $node);
endTrace();

	if (size(`listConnections -p true ($node + ".connection[" + $index + "]")`)) return 1;
	else return 0;
}


// -------------------------------------------------------------------------
// returns a simple list of child-connections of one certain index (node.attribute)
// -------------------------------------------------------------------------
global proc string[] acGetConnections( string $node, int $index)
{
printTrace( 5, "acGetConnections: " + $node);

	string $tmp[];
	string $c[] = `listConnections -p true ($node + ".connection[" + $index + "]")`;
	if (size($c)) {
		endTrace();
		return $c;
	} else {
		$c[0] = acGetConnectionName( $node, $index);
		$realName = acConvertAttr( $c[0]);

		// separate the objName from the attr - for test on exist
		tokenize $realName "." $tmp;
		string $obj = $tmp[0];
		$tmp[0] = $tmp[1];

		// remove possible indicies from the attrName (e.g. weight[1] in blendShape attrs)
		tokenize $tmp[0] "[" $tmp;
		if (`objExists $obj` && `attributeQuery -n $obj -ex $tmp[0]`) {
			endTrace();
			return $c;
		}
		string $nameSpaces[];
		tokenize $node ":" $nameSpaces;
		$nameSpaces = stringArrayRemoveElement( $nameSpaces, size($nameSpaces)-1);

endTrace();
		$attr = $c[0];
		if (size($nameSpaces)) {
			for ( $i=size($nameSpaces) ; $i>0 ; $i-- ) {
				$c[0] = $attr;
				for ( $j=$i-1 ; $j>=0 ; $j-- ) {
					$c[0] = $nameSpaces[$j] + ":" + $c[0];
				}
				tokenize $c[0] "." $tmp;
				if (`objExists $tmp[0]` && `attributeQuery -n $tmp[0] -ex $tmp[1]`) {
					return $c;
				}

			}
		}

		// no namespaces, check the attr direct
		tokenize $c[0] "." $tmp;
		if (`objExists $tmp[0]` && `attributeQuery -n $tmp[0] -ex $tmp[1]`) return $c;
		else return { };


	}


}


// -------------------------------------------------------------------------
// returns a simple list of ALL child-connections (ALL indicies) (node.attribute)
// -------------------------------------------------------------------------
global proc string[] acGetAllConnections( string $node)
{
printTrace( 5, "acGetAllConnections: " + $node);
endTrace();

// ----------WARNING - this function does NOT reflect any gaps in the indicies
	return (`listConnections -p true ($node + ".connection")`);

}

global proc string acGetConnectionName( string $node, int $index)
{
printTrace( 5, "acGetConnectionName: " + $node);

	string $nodeType = acGetNodeType( $node);
	int $typeDef = acTypeDef( $nodeType);
	if ($typeDef == 5 || $typeDef == 6) {
		int $namesIndex = size( acTypeOptions( $nodeType));
		string $specs[] = acGetSpecs( $node);
		string $attrNames[];
		tokenize $specs[$namesIndex] " " $attrNames;
		endTrace();
		return $attrNames[$index];
	} else {
		endTrace();
		return "";
	}
}

global proc acSetConnectionName( string$node, int $index, string $attr)
{
printTrace( 5, "acSetConnectionName: " + $node);

	string $nodeType = acGetNodeType( $node);
	int $typeDef = acTypeDef( $nodeType);
	if ($typeDef == 5 || $typeDef == 6) {
		int $namesIndex = size( acTypeOptions( $nodeType));
		string $specs[] = acGetSpecs( $node);
		string $attrNames[];
		tokenize $specs[$namesIndex] " " $attrNames;
		$attrNames[$index] = $attr;
		$specs[$namesIndex] = acStringArrayToPlainString( $attrNames);
		acSetSpecs( $node, $specs);
	}
endTrace();
}


//---------------------------------------------------------------
// disconnects the child of $node at $index
// also sets the "connectionName" in the specs
//---------------------------------------------------------------
global proc acDisconnect( string $node, int $index)
{
printTrace( 4, "acDisconnect: " + $node);

	// works only correct, if there are NO multple connections on a single index
	//
	string $c[] = `listConnections -p true ($node + ".connection[" + $index + "]")`;
	if (size($c[0])) {
		acSetConnectionName( $node, $index, $c[0]);
printn("disconnecting attr " + $c[0] + " from node " + $node + " at index " + $index);
		disconnectAttr ($c) ($node + ".connection[" + $index + "]");
	}
endTrace();
}

//---------------------------------------------------------------
// goes through all the children of $node and disconnects entries of typeDef 5 or 6
// this is nessessary before export as reference
//---------------------------------------------------------------
global proc acDisconnectTree( string $node)
{
printTrace( 4, "acDisconnectTree: " + $node);

	string $children[] = acGetAllChildrenTypeDef( $node, 5);
	$children = stringArrayCatenate( $children, acGetAllChildrenTypeDef( $node, 6));

	for ( $c in $children ) {
		// shall I clear all the "connectionNames" first ???
		// no, simply overwrite

		string $connections[] = acGetIndexConnections( $c);
printn("there are " + size($connections) + " connections on node " + $c + ". These are:");
printStrings $connections;
printn("------");
		for ( $i=0 ; $i<size($connections) ; $i++ ) acDisconnect( $c, $i);
	}
endTrace();
}





// -------------------------------------------------------------------------
// returns a true image of child-connections (empty strings are lost connections)
// -------------------------------------------------------------------------
global proc string[] acGetIndexConnections( string $node)
{
printTrace( 5, "acGetIndexConnections: " + $node);

	// this function returns a true image of the connections
	// empty strings in the return array show lost connections
	// this function should NOT be used if there are multiple connections to single indicies
	string $c[];
	int $anz = `getAttr -s ($node + ".connection")`;
	for ( $i=0 ; $i<$anz ; $i++ ) {
		string $tmp[] = acGetConnections( $node, $i);
		$c[$i] = $tmp[0];
	}
endTrace();
	return $c;
}



//-------------------------------------------------------------
//-------------------------------------------------------------
// The Specs are stored in an array of strings
// The first index (0) is always the label
// The second index (1) is always the annotation
//-------------------------------------------------------------

global proc string[] acGetSpecs( string $node)
{
printTrace( 5, "acGetSpecs: " + $node);

	// this function returns only the type specific options of that node
	// the label and the annotation ( 0 & 1) are skipped
	string $specs[];
	string $specsName[] = `listAttr -m ($node + ".specs")`;
	for ( $i=0 ; $i<size($specsName)-2 ; $i++ ) $specs[$i] = (`getAttr ($node + ".specs[" + ($i+2) + "]")`);
endTrace();
	return $specs;

}

global proc string acGetLabel( string $node)
{
printTrace( 5, "acGetLabel: " + $node);

	// returns the label of this entry
endTrace();
	return (`getAttr ($node + ".specs[0]")`);
}

global proc string acGetAnnotation( string $node)
{
printTrace( 5, "acGetAnnotation: " + $node);

	// returns the label of this entry
	if (acGetOpt( "acPrefAnnotation", 1)) {
		string $ann = `getAttr ($node + ".specs[1]")`;
endTrace();
		return ($ann);
	} else {
		endTrace();
		return "";
	}
}

global proc acSetSpecs( string $node, string $specs[])
{
printTrace( 5, "acSetSpecs: " + $node);

	// sets ONLY the type specific options (index 2-)
	for ( $i=0 ; $i<size($specs) ; $i++ ) {

// this is a bugfix --------------------------------
// the setAttr would not work, if one of the specs string is something like "-5"
		if (size($specs[$i])) {
			if ((`substring $specs[$i] 1 1`) == "-") {
				$specs[$i] = " " + $specs[$i];
			}
		}

		setAttr -type "string" ($node + ".specs[" + ($i+2) + "]") $specs[$i];
	}
endTrace();
}

global proc acSetLabel( string $node, string $label)
{
printTrace( 5, "acSetLabel: " + $node);

	// sets the label (.specs[0]) of this entry
	setAttr -type "string" ($node + ".specs[0]") $label;
endTrace();

// 	string $parent = acGetParentNode( $node);
// 	if (acGetNodeType( $parent) == "TabLayout") {
// 		int $index = acGetParentIndex( $node);
// 		string $parentUI = acGetUIName( $parent);
// 		tabLayout -e -tabLabelIndex ($index+1) $label $parentUI;
// 	}
// 	string $type = acGetNodeType( $node);
// 	if (`exists ("acSet" + $type + "Label")`) eval("acSet" + $type + "Label(\"" + $node + "\", \"" + $label + "\");");

}

global proc acSetAnnotation( string $node, string $annotation)
{
printTrace( 5, "acSetAnnotation: " + $node);

	// sets the anntotation (.specs[1]) of this entry
	setAttr -type "string" ($node + ".specs[1]") $annotation;
endTrace();
}

//-------------------------------------------------------------
//-------------------------------------------------------------

//--------------------------------------------------------------
// returns the parent of $node
//--------------------------------------------------------------
global proc string acGetParentNode( string $node)
{
printTrace( 5, "acGetParentNode: " + $node);

// returns the parent node for this node
	string $tmp[] = `listConnections -p true ($node + ".message")`;
	tokenize $tmp[0] "." $tmp;

endTrace();
	return $tmp[0];
}

//--------------------------------------------------------------
// returns the index, where $node is connected to it's parent
//--------------------------------------------------------------
global proc int acGetParentIndex( string $node)
{
printTrace( 5, "acGetParentIndex: " + $node);

// returns the index of this node's connection to the parent
	string $tmp[] = `listConnections -p true ($node + ".message")`;
	tokenize $tmp[0] "[" $tmp;
	tokenize $tmp[1] "]" $tmp;

endTrace();
	return $tmp[0];
}


// wenn uiName eine Liste ist...
// - dann koennte der erste Eintrag der sein, der als Parent fuer eventuelle Children der Parent ist
// - der letzte ist der, der den Entry loescht
// - und alle dazwischen sind "spezielle", also z.B. die einzelnen Buttons einer ButtonRow oder Teile eines GroupLayouts
// der Einfachheit halber koennte das normale Attribut alle Namen speichern, getrennt durch Leerzeichen
//   damit waere es rueckwaerts kompatibel

//--------------------------------------------------------------
//--------------------------------------------------------------
//------------------- UI Names ---------------------------------
//--------------------------------------------------------------
//--------------------------------------------------------------
// returns the top-uiName which deletes the complete Entry from AC (LAST index)
//--------------------------------------------------------------
global proc string acGetUIDeleteName( string $node)
{
printTrace( 5, "acGetUIDeleteName: " + $node);

	global string $acUINames[];

	string $uiName = acGetNodeData( $node, $acUINames);
	string $tmp[];
	tokenize $uiName " " $tmp;
endTrace();
	if (size($tmp)) return strip( $tmp[size($tmp)-1]);
	else return "";
}

//--------------------------------------------------------------
// sets the top-uiName which deletes the complete Entry from AC (LAST index)
//--------------------------------------------------------------
global proc acSetUIDeleteName( string $node, string $uiName)
{
printTrace( 5, "acSetUIDeleteName: " + $node);

	global string $acUINames[];

	string $oldName = acGetNodeData( $node, $acUINames);
	string $tmp[];
	tokenize $oldName " " $tmp;
	$tmp[size($tmp)-1] = $uiName;
	$uiName = "";
	for ( $n in $tmp) $uiName += ($n + " ");
	acSetNodeData( $node, $uiName, $acUINames);
endTrace();

}

//--------------------------------------------------------------
// returns the special UI names of this entry (index 1-(n-2))
//--------------------------------------------------------------
global proc string[] acGetUISpecial( string $node)
{
printTrace( 5, "acGetUISpecial: " + $node);

	global string $acUINames[];

	string $uiName = acGetNodeData( $node, $acUINames);
	string $tmp[];
	tokenize $uiName " " $tmp;
	$tmp = stringArrayRemoveElement( $tmp, 0);
	$tmp = stringArrayRemoveElement( $tmp, size($tmp)-1);
endTrace();
	return $tmp;
}

//--------------------------------------------------------------
// returns the UI names of this entry (index 0)
//--------------------------------------------------------------
global proc string acGetUIName( string $node)
{
printTrace( 5, "acGetUIName: " + $node);

// returns the UI name of this entry
	global string $acUINames[];

	string $uiName = acGetNodeData( $node, $acUINames);
	string $tmp[];
	tokenize $uiName " " $tmp;
endTrace();
	return strip( $tmp[0]);
}

//--------------------------------------------------------------
// returns the special UI names of this entry (index 1-(n-2))
//--------------------------------------------------------------
global proc acSetUIName( string $node, string $uiName[])
{
printTrace( 5, "acSetUIName: " + $node);

	global string $acUINames[];

	string $tmp;
	if (size($uiName)) for ( $n in $uiName) $tmp += ($n + " ");
	else $tmp = "";
	acSetNodeData( $node, $tmp, $acUINames);
endTrace();
}


//--------------------------------------------------------------
// Sets the uiName of the EditWindow of this node (empty if there is no Edit Window open
//--------------------------------------------------------------
global proc acSetEditWinName( string $node, string $win)
{
printTrace( 5, "acSetEditWinName: " + $node);

	global string $acEditWins[];

	acSetNodeData( $node, $win, $acEditWins);
endTrace();

}

//--------------------------------------------------------------
// Returns the uiName of the EditWindow of this node (empty if there is no Edit Window open
//--------------------------------------------------------------
global proc string acGetEditWinName( string $node)
{
printTrace( 5, "acGetEditWinName: " + $node);

	global string $acEditWins[];

endTrace();
	return acGetNodeData( $node, $acEditWins);
}





//--------------------------------------------------------------
// the "NodeData" functions work with global string arrays
// one array is simply a list of nodes ($acNodeList)
// and with the same index it addresses other string arrays, such as $acEditWinName, $acUINames, etc.
// this is pretty easy and allows to store things, that should not be save in the DB
//--------------------------------------------------------------
global proc acSetNodeData( string $node, string $data, string $array[])
{
printTrace( 5, "acSetNodeData: " + $node);

	global string $acNodeList[];

	int $index = acStringArrayIndex( $node, $acNodeList);
	$acNodeList[$index] = $node;        // this is redundant, right?
	$array[$index] = $data;
endTrace();
}

//--------------------------------------------------------------
global proc string acGetNodeData( string $node, string $array[])
{
printTrace( 5, "acGetNodeData: " + $node);

	global string $acNodeList[];

	int $index = acStringArrayIndex( $node, $acNodeList);
endTrace();
	if ($index < size($array) && $acNodeList[$index] == $node) return $array[$index];
	else return "";
}

//--------------------------------------------------------------
//--------------------------------------------------------------
// the cleanup function removes empty elements and elements for deleted objects
//--------------------------------------------------------------
global proc acCleanupNodeData()
{
printTrace( 4, "acCleanupNodeData");

	global string $acNodeList[];
	global string $acEditWins[];
	global string $acUINames[];
	global string $acFLNames[];

	string $nodeList[];
	string $editWins[];
	string $UINames[];
	string $FLNames[];

	for ( $i=0 ; $i<size($acNodeList) ; $i++ ) {
		if (size($acNodeList[$i]) && `objExists $acNodeList[$i]`) {
			$nodeList[size($nodeList)] = $acNodeList[$i];
			$editWins[size($editWins)] = $acEditWins[$i];
			$UINames[size($UINames)]   = $acUINames[$i];
			$FLNames[size($FLNames)]   = $acFLNames[$i];
		}
	}
	$acNodeList = $nodeList;
	$acEditWins = $editWins;
	$acUINames  = $UINames; 
	$acFLNames  = $FLNames; 
endTrace();


}


global proc acReportNodeData()
{
printTrace( 4, "acReportNodeData");

	global string $acNodeList[];
	global string $acEditWins[];
	global string $acUINames[];
	global string $acFLNames[];

	for ( $i=0 ; $i<size($acNodeList) ; $i++ ) {
		print( acFixedLengthStr( $acNodeList[$i], 20) + "       ");
		print( acFixedLengthStr( $acEditWins[$i], 20) + "       ");
		print( acFixedLengthStr( $acUINames[$i], 20) + "       ");
		print( acFixedLengthStr( $acFLNames[$i], 20) + "       \n");
	}
endTrace();
}



//--------------------------------------------------------------
//--------------------------------------------------------------


//--------------------------------------------------------------
// Preferences currently stored in a string attribute on the script node.
// this way the prefs can be set, when acAddPanel is called to build the panel
//--------------------------------------------------------------
global proc string acGetPrefString( string $node)
{
printTrace( 5, "acGetPrefString: " + $node);

	string $prefs = `getAttr ($node + ".prefs")`;
endTrace();
	return $prefs;
}

global proc acSetPrefString( string $node, string $prefs)
{
printTrace( 5, "acSetPrefString: " + $node);

	setAttr -type "string" ($node + ".prefs") $prefs;
endTrace();
}


//--------------------------------------------------------------
// Removes the array instance at $index (cleanup)
//--------------------------------------------------------------
global proc acDeletePlug( string $node, int $index)
{
printTrace( 5, "acDeletePlug: " + $node);

	removeMultiInstance -b true ($node + ".connection[" + $index + "]");
endTrace();
}

//--------------------------------------------------------------
// Returns the top-level script node of this entry
//--------------------------------------------------------------
global proc string acGetParentScriptNode( string $node)
{
printTrace( 4, "acGetParentScriptNode: " + $node);

	int $i = 1000;
	string $parent = $node;
	if ( acTypeDef( acGetNodeType($node)) == 0) {
		endTrace();
		return $node;
	}
	while( acTypeDef( acGetNodeType( $parent = acGetParentNode( $parent))) != 0  && ($i--));
endTrace();
	return $parent;
}

//--------------------------------------------------------
// checks if $child is a child of $parent
//--------------------------------------------------------
global proc int acIsChildOf( string $child, string $parent)
{
printTrace( 5, "acIsChildOf: child = " + $child + ", parent = " + $parent);

//printn("This is acIsChildOf");
	string $allChildren[] = acGetAllChildren( $parent);
	$allChildren = stringArrayRemoveElement( $allChildren, 0);
	if (stringArrayCount( $child, $allChildren)) {
		endTrace();
		return 1;
	} else {
		endTrace();
		return 0;
	}
}

global proc string[] acGetNodeChildren( string $node)
{
printTrace( 5, "acGetNodeChildren: " + $node);

// lists the children of that one node
// only "network" nodes are listed
	string $children[] = `listConnections -s true -p false ($node + ".connection")`;
	$children = `ls -type "network" -type "script" $children`;
endTrace();
	return $children;
}


global proc string[] acGetAllChildren( string $node)
{
printTrace( 5, "acGetAllChildren: " + $node);

// returns the complete tree from that node on (inclusive $node)
// calls itself recoursivly
	string $children[] = `listConnections -s true -p false ($node + ".connection")`;
	$children = `ls -type "network" -type "script" $children`;
	string $allChildren[] = {$node};
	for ( $ch in $children ) {
		string $subCh[] = acGetAllChildren( $ch);
		$allChildren = stringArrayCatenate( $allChildren, $subCh);
	}
endTrace();
	return $allChildren;
}

global proc string[] acGetAllTypeChildren( string $node, string $type)
{
printTrace( 5, "acGetAllTypeChildren: " + $node);

// returns the all the children of a specified type (string)

	string $children[] = acGetAllChildren( $node);
	string $typeCh[]; int $i = 0;
	for ( $ch in $children ) if (acGetNodeType( $ch) == $type) $typeCh[$i++] = $ch;
endTrace();
	return $typeCh;
}


global proc string[] acGetAllChildrenTypeDef( string $node, int $typeDef)
{
printTrace( 5, "acGetAllChildrenTypeDef: " + $node);

// returns the all the children of a specified typeDef (int)
// printn("This is acGetAllChildrenTypeDef");
	string $children[] = acGetAllChildren( $node);
	string $typeDefChildren[];

	for ( $ch in $children )
		if (acTypeDef( acGetNodeType( $ch)) == $typeDef)
			$typeDefChildren[size($typeDefChildren)] = $ch;
endTrace();
	return $typeDefChildren;
}




global proc acUpdateOtherViews( string $node)
{
printTrace( 4, "acUpdateOtherViews: " + $node);

	if (`objExists $node`) {
		evalDeferred("acRedrawTextList( \"" + $node + "\")");
		evalDeferred("acUpdateFLChildren( \"" + $node + "\")");
	}

endTrace();
}


//-----------------------------------------------------------
// Draws a list of children for a parent
// tries to call a custom draw routine
global proc acDrawChildren( string $node, string $children[])
{
printTrace( 3, "acDrawChildren: " + $node);

	string $type = acGetNodeType( $node);
	string $cmd = "ac" + $type + "DrawChildren( \"" + $node + "\", " + acStringArrayToString( $children) + " );";
	if (`exists ("ac" + $type + "DrawChildren")`) eval $cmd;
	else for ( $ch in $children ) acDrawEntry( $ch);

endTrace();
}


global proc acAddDirectInsertMenuItems( string $node)
{
printTrace( 6, "acAddDirectInsertMenuItems: " + $node);

// Creates the "Insert>>" popup menu in the RMB direct menus
// checks the available types in $acTypes (defined in global proc ac()

	global string $acTypes[];
	int $lastType = -1;

	for ( $i=0 ; $i<size($acTypes) ; $i+=3 ) {
		int $type = (int)$acTypes[$i+1];
		if ($type != 0 && $type != 5) {             // no windows, no attrCTRLs
			if ($lastType > 0 && $type != $lastType) menuItem  -divider true ;
			$lastType = $type;
			menuItem -label $acTypes[$i] -c ("acInsertDirect( \"" + $node + "\", \"" + $acTypes[$i] + "\");");
		}
	}
endTrace();
}

//-----------------------------------------------------------------------
//-----------------------------------------------------------------------
global proc setPopupLabel( string $node, string $menuItem)
{
printTrace( 6, "setPopupLabel: " + $node);

// 	string $specs[] = acGetSpecs( $node);
	menuItem -e -label ((acGetLabel( $node)) + " ...") $menuItem;
endTrace();
}


global proc acAddRMBPopup( string $node, string $uiName)
{
printTrace( 5, "acAddRMBPopup: " + $node);


	if (!acIsLocked( $node) && (`layout -q -exists $uiName` || `control -q -exists $uiName`)) {
		$menu = `popupMenu -parent $uiName -button 3`;
		$menuItem = `menuItem -label "Label" -c ("acEditWin( \"" + $node + "\", acNewEditWin(\"\"), {})")`;
		popupMenu -e -postMenuCommand ("setPopupLabel( \"" + $node + "\", \"" + $menuItem + "\")") $menu;
		menuItem -d true;
		menuItem -label "Insert" -subMenu true;
			menuItem -label "...selected Attributes" -c ("acAddSelectedAttrsToGroup( acGetParentNode(\"" + $node + "\"), acGetParentIndex(\"" + $node + "\"));");
			menuItem -d true;
			acAddDirectInsertMenuItems( $node);
		setParent -menu ..;
		menuItem -label "Delete" -c ("acDeleteEntry( \"" + $node + "\", 1, 1);");
	}
endTrace();
}

global proc acAddDDCallback( string $node, string $dragCB, string $dropCB, string $uiName)
{
printTrace( 5, "acAddDDCallback: " + $node);


	string $type = acGetNodeType( $node);
	int $typeDef = acTypeDef( $type);

    if (!acIsLocked( $node) && (`layout -q -exists $uiName` || `control -q -exists $uiName`)) {
		string $cmd = "ac" + $type + "DDCallback( \"" + $node + "\");";
		if (`exists ("ac" + $type + "DDCallback")`) eval $cmd;
		else {
			if ($typeDef < 5) {
				if ($typeDef > 0) layout -e -dragCallback ($dragCB + " \"" + $node + "\"")
											-dropCallback ($dropCB + " \"" + $node + "\"") $uiName;
			} else control -e -dragCallback ($dragCB + " \"" + $node + "\"")
							-dropCallback ($dropCB + " \"" + $node + "\"") $uiName;
		}
	}		// do NOT add D&D callbacks, since the UI is locked or the node is a reference
endTrace();
}


//-----------------------------------------------------------------------
//-----------------------------------------------------------------------
global proc string[] acDrawEntry( string $node)
{
printTrace( 2, "acDrawEntry: " + $node);

	string $parent = acGetParentNode( $node);
	if (size($parent)) setParent (acGetUIName( $parent));
	string $type = acGetNodeType( $node);
	int $typeDef = acTypeDef( $type);
	string $cmd = "acDraw" + $type + "Entry( \"" + $node + "\");";
	string $uiName[] = `eval $cmd`;
	acSetUIName( $node, $uiName);

// cleanup EditWindow Name (e.g. after an undo it might have a value, but the window is gone)
	acCheckEditWinName( $node);
	acRedrawTextList( $node);


	// add drag&drop callbacks

	acAddDDCallback( $node, "acDragDirectCB", "acDropDirectCB", $uiName[0]);

	if ($typeDef > 0) {
		acAddRMBPopup( $node, $uiName[0]);
	}

	// and now for all of its children
	// if this type may have children ...
	string $children[] = acGetNodeChildren( $node);
	acDrawChildren( $node, $children);

// post commands
	if (`exists ("acDraw" + $type + "EntryPost")`) {
		$cmd = "acDraw" + $type + "EntryPost( \"" + $node + "\");";
		eval $cmd;
	}
endTrace();
	return $uiName;
}

global proc acRedrawEntry( string $node)
{
printTrace( 2, "acRedrawEntry: " + $node);


	string $type = acGetNodeType( $node);
	string $uiName= acGetUIName( $node);


// cleanup EditWindow Name (e.g. after an undo it might have a value, but the window is gone)
	acCheckEditWinName( $node);

	if (`window -exists $uiName`) deleteUI $uiName;
	if (`layout -exists $uiName`) {
		string $children[] = `layout -q -ca $uiName`;
// BUGFIX------------------------------------
// don't switch it off, if it is a formLayout
		if (!`objectTypeUI -isType "formLayout" $uiName`) layout -e -vis false $uiName;
//-------------------------------------------
		for ($ch in $children) deleteUI $ch;
		// and now for all of its children
		// if this type may have children ...
		string $children[] = acGetNodeChildren( $node);
		acDrawChildren( $node, $children);

// post commands
		if (`exists ("acDraw" + $type + "EntryPost")`) {
			$cmd = "acDraw" + $type + "EntryPost( \"" + $node + "\");";
			eval $cmd;
		}


//----------------------------------------------------------------------------
// BUGFIX for formLayouts
// if $uiName is a formLayout then the children's connections to the egdes is now lost
if (`objectTypeUI -isType "formLayout" $uiName`) {
	string $ch[] = `formLayout -q -ca $uiName`;
	if (size($ch) == 1) {
		formLayout -e
			-af $ch[0] "top" 0
			-af $ch[0] "left" 0
			-af $ch[0] "right" 0
			-af $ch[0] "bottom" 0
		$uiName;
	}
}
// END BUGFIX
//----------------------------------------------------------------------------
		layout -e -vis true $uiName;

		acUpdateOtherViews( $node);
	} else acDrawChildren( acGetParentNode( $node), {$node});

	acCleanupNodeData();

endTrace();
}

//-------------------------------------------------------
// Redraw Stack
//-------------------------------------------------------


//-----------------------------------------------------------
// this function rings the redraw bell (attribute of the script node, watched by a scriptJob)
//    and add $node to a list of nodes that will be put on the redrawStack
// this function should be used, whenever there's a modification that would require a redraw on undo
//-----------------------------------------------------------
global proc acSetRedrawStack( string $node)
{
printTrace( 3, "acSetRedrawStack: " + $node);

	global string $acAutoRedrawNode;		// this node is the ones that has the right stackPointer
	global string $acSheduleRedraw[];
	global int $acAutoRedraw;
	if (!$acAutoRedraw && `objExists $acAutoRedrawNode`) {
// 		setAttr ((acGetParentScriptNode( $node)) + ".redrawBell") ((int)(`timerX`*1000));
		setAttr ($acAutoRedrawNode + ".redrawBell") ((int)(`timerX`*1000));
		$acSheduleRedraw[size($acSheduleRedraw)] = $node;
	}
endTrace();
}

//-----------------------------------------------------------
// this function puts all the entries in $nodes as one string on the $acRedrawStack
// the function acAutoRedraw calls this push operation
//-----------------------------------------------------------
global proc acPushRedraw( string $nodes[])
{
printTrace( 3, "acPushRedraw" );

	global string $acAutoRedrawNode;		// this node is the ones that has the right stackPointer

	global string $acRedrawStack[];
	global int $acStackPointer;			// additional pointer to distinguish between undo and redo

	// go through all the node and find the parentScriptNodes
	int $acRedrawPointer = `getAttr ($acAutoRedrawNode + ".redrawPointer")`;
	int $acRedrawStacksize = `getAttr ($acAutoRedrawNode + ".redrawStacksize")`;
// printn("This is Push Redraw");
// printn("current Pointer = " + $acRedrawPointer + " -- Size = " + $acRedrawStacksize);
// printn("number of Elements in Stack = " + (size( $acRedrawStack)));
	if ($acRedrawStacksize == 0) {
		clear $acRedrawStack;
		$acRedrawPointer = 0;
	}

	string $final, $n;
	for ( $n in $nodes) $final += ($n + " ");
	$acRedrawStack[$acRedrawPointer] = $final;

	$acRedrawStacksize = min( $acRedrawStacksize+1, 100);
	if (++$acRedrawPointer > 99) $acRedrawPointer = 0;
	$acRedrawStack[$acRedrawPointer] = $final;
// printn("End of Push Redraw");
// printn("New Pointer = " + $acRedrawPointer + " -- Size = " + $acRedrawStacksize);
// printn("number of Elements in Stack = " + (size( $acRedrawStack)) + "\nStack is:");
// printStrings( $acRedrawStack);
// printn("----------------------------");
	setAttr ($acAutoRedrawNode + ".redrawPointer") $acRedrawPointer;
	setAttr ($acAutoRedrawNode + ".redrawStacksize") $acRedrawStacksize;
	$acStackPointer = $acRedrawPointer;
endTrace();
}

//-----------------------------------------------------------
// this function will be called by scriptJobs, that watch every acScript node
// if the acSheduleRedraw array contains something, then these nodes will be put
//   on the $acRedrawStack
// if there's nothing in the array, then we are in an undo or redo operation
//   and the function gets the top entry from the stack and redraws these entries
//-----------------------------------------------------------
global proc acAutoRedraw()
{
printTrace( 3, "acAutoRedraw");

	global string $acAutoRedrawNode;		// this node is the ones that has the right stackPointer

	global string $acRedrawStack[];
	global string $acSheduleRedraw[];
	global int $acStackPointer;
	global int $acAutoRedraw;

	if (`objExists $acAutoRedrawNode`) {
		if (size($acSheduleRedraw)) {
	// printn("+=+=+=+=+=+=+=PUSH Redraw");
			// remove duplicates
			$acSheduleRedraw = stringArrayRemoveDuplicates( $acSheduleRedraw);
	// printStrings( $acSheduleRedraw);
			// remove children if their parents are also in the list
			for ( $i=0 ; $i<size($acSheduleRedraw) ; $i++ ) {
				for ($j=0 ; $i<size($acSheduleRedraw) && $j<size($acSheduleRedraw) ;  ) {
	// printn("=+=+test " + $acSheduleRedraw[$j] + " against parent " + $acSheduleRedraw[$i]);
					if ($i!=$j
						&& (!`objExists $acSheduleRedraw[$j]` || acIsChildOf( $acSheduleRedraw[$j], $acSheduleRedraw[$i]))) {
	// printn("=+=+remove " + $acSheduleRedraw[$j]);
						$acSheduleRedraw = stringArrayRemoveElement( $acSheduleRedraw, $j);
					} else $j++;
				}
			}
			acPushRedraw( $acSheduleRedraw);
			clear $acSheduleRedraw;
		} else {
			$acAutoRedraw = 1;
			int $pointer = `getAttr ($acAutoRedrawNode + ".redrawPointer")`;
			$pointer = min( $pointer, $acStackPointer);
			string $redraw[];
			tokenize $acRedrawStack[$pointer] " " $redraw;
			for ($n in $redraw) acRedrawEntry( $n);
			$acStackPointer = `getAttr ($acAutoRedrawNode + ".redrawPointer")`;
			$acAutoRedraw = 0;
	// printn("+=+=+=+=+=+=+=POP Redraw, pointer: " + $pointer + "\n----redrawStack:");
	// printStrings( $acRedrawStack);
	// printn("-----");
		}
	}			// there is NO acAutoRedrawNode
	clear $acSheduleRedraw;
endTrace();
}
// Kompatibilitaet mit dem alten attrCollection.mel

global string $acTab;
global string $acActiveParent;
global string $acPanelName;

//-----------------------------

global proc string acGetMainTabLayout( )
{
	global string $acMasterNode;
	string $children[] = acGetNodeChildren( $acMasterNode);

	if (acGetNodeType( $children[0]) == "TabLayout") return $children[0];
	else error("Problem with the Tabs while converting old Attribute Collection");
}

//-----------------------------
global proc string acEditBtnGetRowLabel( string $btnSpecs)
{
string	$tmp[];


	tokenize $btnSpecs "|" $tmp;


	return $tmp[0];
}


global proc string[] acEditBtnGetLabels( string $btnSpecs)
{
string	$buttonRowLabel;
string	$buttonLabel[];


string	$tmp[];


	tokenize $btnSpecs "|" $tmp;


	$buttonLabel[0] = $tmp[2];
	$buttonLabel[1] = $tmp[3];
	$buttonLabel[2] = $tmp[4];
	$buttonLabel[3] = $tmp[5];
	return $buttonLabel;
}


global proc int[] acEditBtnGetSpecs( string $btnSpecs)
{
string	$buttonRowLabel;
string	$buttonLabel[];




string	$tmp[];
int	$tmpInt[];


	tokenize $btnSpecs "|" $tmp;


	tokenize $tmp[1] $tmp;
	for ( $i=0 ; $i<11 ; $i++ ) $tmpInt[$i] = $tmp[$i];
	return $tmpInt;
}


global proc string acSetBtnCmd( string $buttonSpecs, int $index, string $cmd)
{
//global string	$acAttr[];		// names of the registered attributes
//global string	$acAttrLabel[];		// additional Labels fot the Attributes
global string	$acCmds[];		// commands for buttons


// BUG FIX: the button specs may not use a " as delimiter
// it will be removed to be compatible


    while( gmatch( $buttonSpecs, "*\"*")) {
	    $buttonSpecs = `substitute "\"" $buttonSpecs "|"`;
    }

// `end bug fix


string	$rowLabel = acEditBtnGetRowLabel( $buttonSpecs);
string	$btnLabel[] = acEditBtnGetLabels( $buttonSpecs);
int	$tmp[] = acEditBtnGetSpecs( $buttonSpecs);


int	$cmdIndex = size( $acCmds);
	$acCmds[$cmdIndex] = $cmd;
	$tmp[$index + 7] = $cmdIndex;


	$buttonSpecs =	$rowLabel + "| " +
			$tmp[0]  + " " +	// $fixedWidht
			$tmp[1]  + " " +	// $btnWidth
			$tmp[2]  + " " +	// $oriantation
			$tmp[3]  + " " +	// $enable[0]
			$tmp[4]  + " " +	// $enable[1]
			$tmp[5]  + " " +	// $enable[2]
			$tmp[6]  + " " +	// $enable[3]
			$tmp[7]  + " " +	// $cmdIndex[0]
			$tmp[8]  + " " +	// $cmdIndex[1]
			$tmp[9]  + " " +	// $cmdIndex[2]
			$tmp[10] + " |" +	// $cmdIndex[3]
			$btnLabel[0] + "|" +
			$btnLabel[1] + "|" +
			$btnLabel[2] + "|" +
			$btnLabel[3];


	return $buttonSpecs;


}


global proc acShow()
{
	global string $acMasterNode;
	global string $acPanelName;
	print("CALL TO ACSHOW!!!!!!!!\n");
	acShowAC( $acMasterNode);
	$acPanelName = acGetUIDeleteName( $acMasterNode);
}

global proc acMakePose( string $name, string $attrValues)
{
printn("---this is acMakePose");
	// do nothing, no poses yet
}

global proc acClearPanel( int $createDefaults)
{
printn("---this is acClearPanel");
// should erase all tabs

	global string   $acMasterNode;
	global string $acTab;

	int $oldStyle = `optionVar -q "acPrefNameStyle"`;
	int $newStyle[] = { 1, 2, 4, 5};
	optionVar -iv "acPrefNameStyle" ($newStyle[$oldStyle]);

	$acTab = acGetUIName( acGetParentNode( acVisibleTab( $acMasterNode)));
printn(">>clearPanel: acTab = " + $acTab);
	string $children[] = acGetNodeChildren( acGetMainTabLayout( ));
printn(">>clearPanel: deleting children");
printStrings( $children);
	for ( $ch in $children) acRemoveEntry( $ch, 1, 0);
printn(">>clearPanel: finished deleting children");
// VERFLUCHT!!!!
// wenn ich die children loesche, dann geht das tabLayout auch davon :(((

}

global proc mkNewTab( string $name, int $force)
{
printn("---this is mkNewTab");

	string $tabLayout = acGetMainTabLayout( );
	string $new = acCreateColumnLayoutEntry( $tabLayout, -1, $name, "");


}

global proc findRegObj( string $label, int $defaultButtons, int $collapse)
{
printn("---this is findRegObj");
	// just create a new group in the latest Tab
	global string $acMasterNode;
	string $tabLayout = acGetMainTabLayout( );
	string $ch[] = acGetNodeChildren( $tabLayout);
	acCreateNode( $ch[size($ch)-1], -1, "Group", $label, "", {(string)$collapse, (string)$defaultButtons, "etchedIn"});
}

global proc registerAttr( string $objAttr, string $group, string $attrLabel, float $attrMin, float $attrMax)
{
printn("---this is registerAttr");
	// creates entries - very straight forward, doesn't look at the group name

	global string $acActiveParent;


	global string	$acCmds[];		// commands for buttons and poses


//global string	$acActiveGroup;


//string	$regObj;
string	$attrType;


int	$special = 0;


	$attrType = substring( $objAttr, 1, 4);
	switch ($attrType) {
		case " sep":
			$special = 1;
			$attrType = "separator";
			break;
		case " but":
			$special = 1;
			$attrType = "buttons";
			break;
		case " scr":
			$special = 1;
			$attrType = "scripted";
			break;
		default:
			$special = 0;
			if (size(`ls $objAttr`) == 0) {
			    warning ("The Attribute " + $objAttr + " could not be found!");
			    $special = 1;
			    $attrType = "broken";
			} else if (size(`ls $objAttr`) > 1) {
			    warning ("The Attribute " + $objAttr + " is not unique!");
			    $special = 1;
			    $attrType = "broken";
			} else $attrType = `getAttr -type $objAttr`;
			break;
	}


// BUG FIX: in the button specs (the label) I may not use a " as a delimiter
// This routine will remove any " for compatibility


	if ($attrType == "buttons" || $attrType == "separator") {
	    while( gmatch( $attrLabel, "*\"*")) {
		    $attrLabel = `substitute "\"" $attrLabel "|"`;
	    }
	}


// end bug fix 



//int	$labelSize = max( 1, acGetOpt( "acPrefLabelSize", 140));
//int	$fieldSize = max( 1, acGetOpt( "acPrefFieldSize", 80));
//int	$sliderSize = max( 1, acGetOpt( "acPrefSliderSize", 160)
//			* acGetOpt( "acPrefEnableSliders", 1));
//int	$totalSize = $labelSize + $fieldSize + $sliderSize;
//
//
//	if ($group == "") $group = acObjFromAttr( $objAttr);
//	if ($acActiveGroup != "") $group = $acActiveGroup;


//	$regObj = acObjFromAttr( $objAttr);
//	if ($special || size( `ls $regObj`)) {
//	    if (findRegObj( $group, 1, 0)) {
//
//
//		if (!isRegAttr( $objAttr, $group, $attrLabel, $attrMin, $attrMax)) {
//
//
//		    if (!$special && ($attrLabel == "" || $attrLabel == acLongLabel($objAttr)))
//			    $attrLabel = acMakeLabel( $objAttr);


		    switch ($attrType) {
			case "separator":

				string	$styles[] = { "none", "single", "double", "singleDash", "doubleDash", "in", "out" };
				int	$sepHeight;
				string	$sepLabel;
				int	$sepStyle;

				string	$tmp[];

				tokenize $attrLabel "|" $tmp;
				$sepLabel = $tmp[0];
				tokenize $tmp[1] " " $tmp;
				$sepStyle = $tmp[0];
				$sepHeight = $tmp[1];

				acCreateNode( $acActiveParent, -1, "Separator", $sepLabel, "", {(string)$sepHeight, $styles[$sepStyle-1]});

				break;
			case "buttons":
			    int	    $specs[] = acEditBtnGetSpecs( $attrLabel);
			    int	    $b1 = $specs[3];
			    int	    $b2 = $specs[4];
			    int	    $b3 = $specs[5];
			    int	    $b4 = $specs[6];
			    int	    $bAnz = $b1 + $b2 + $b3 + $b4;
			    string  $offsCmd = " -columnOffset" + $bAnz;
			    string  $widthCmd = " -columnWidth" + $bAnz;
			    string  $alignCmd = " -columnAlign" + $bAnz;
			    string  $attachCmd = " -columnAttach" + $bAnz;


			    string  $bLabels[] = acEditBtnGetLabels( $attrLabel);
			    string  $rowLabel = acEditBtnGetRowLabel( $attrLabel);


//			    if ($bAnz) {
//				int	$bs;
//				string	$orientation = "left";
//				string	$attachNames[] = { "left", "center", "right"};
//
//
//				if ($specs[0]) {
//					$bs = $specs[1];
//					$orientation = $attachNames[$specs[2]-1];
//				} else $bs = $totalSize / $bAnz;
//
//
				int $offset = 2;
//				int $offset = $totalSize - ($bs * $bAnz);
//				if ($specs[2] == 2) $offset /= 2;
//
//
//				string	$cmd = "rowLayout -h 22 -numberOfColumns " + $bAnz + " ";
//
//
//				for ( $i = 1 ; $i <= $bAnz ; $i++ ) {
//				    $widthCmd += " " + $bs;
//				    $attachCmd += " left";
//				    $alignCmd += " center";
//
//
//				    if ($i==1) $offsCmd += " " + $offset;
//				    else if ($offset < $bs) $offsCmd += " " + $offset;
//				    else $offsCmd += " " + $bs;
//				}
//
//
//				$cmd += $widthCmd + " " + $attachCmd + " " + $alignCmd;
//				if ($specs[2] != 1) $cmd += " " + $offsCmd;
//
//
////				eval( $cmd);
//
//
				string	$acBtnCmds[];

// acCms ist wohl eine globale variable, die von der ScriptNode aus noch gesetzt wird
				for ( $i=0 ; $i<4 ; $i++ )
					if ($specs[$i+7] != -1) $acBtnCmds[$i] = $acCmds[$specs[$i+7]];
					else $acBtnCmds[$i] = "";


//				if ($b1) button -w $bs -h 22 -al "center" -l $bLabels[0] -c $acBtnCmds[0];
//				if ($b2) button -w $bs -h 22 -al "center" -l $bLabels[1] -c $acBtnCmds[1];
//				if ($b3) button -w $bs -h 22 -al "center" -l $bLabels[2] -c $acBtnCmds[2];
//				if ($b4) button -w $bs -h 22 -al "center" -l $bLabels[3] -c $acBtnCmds[3];
//			    }

				acCreateNode( $acActiveParent, -1, "ButtonRow", $rowLabel, "",
																{(string)$b1, (string)$b2, (string)$b3, (string)$b4,
																(string)$offset,
																$bLabels[0], $bLabels[1], $bLabels[2], $bLabels[3],
																$acBtnCmds[0], $acBtnCmds[1], $acBtnCmds[2], $acBtnCmds[3] });
//"ButtonRow",        "6",            "1 1 1 1 2 Button1 Button2 Button3 Button4 //MEL_Commands //MEL_Commands //MEL_Commands //MEL_Commands previousAttrNames",
			    break;
			case "scripted" :
//			    string $scriptedParts[];
//			    tokenize $attrLabel "|" $scriptedParts;
//			    eval( $acCmds[(int)$scriptedParts[1]]);
			    break;
			case "broken":
				print("Broken Attribute connection: >" + $objAttr + "<\n");
			    break;
			default:
				string $attrType = `getAttr -type $objAttr`;
				string $entry;
				switch ($attrType) {
					case "bool" :
						$entry = acCreateAttrCheckBoxEntry( $acActiveParent, -1, $objAttr, "");
						break;
					case "doubleLinear" :
						if ($attrMin == 0 && $attrMax == 0) { $attrMin = -20; $attrMax = 20; }
						$entry = acCreateAttrSliderEntry( $acActiveParent, -1, $objAttr, $attrMin, $attrMax);
						break;
					case "doubleAngle" :
						if ($attrMin == 0 && $attrMax == 0) { $attrMin = -180; $attrMax = 180; }
						$entry = acCreateAttrSliderEntry( $acActiveParent, -1, $objAttr, $attrMin, $attrMax);
						break;
					case "long" :
					case "double" :
						if ($attrMin == 0 && $attrMax == 0) { $attrMin = -5; $attrMax = 5; }
						$entry = acCreateAttrSliderEntry( $acActiveParent, -1, $objAttr, $attrMin, $attrMax);
						break;
					case "color" :
						$entry = acCreateColorSliderEntry( $acActiveParent, -1, $objAttr);
						break;
					case "enum" :
						$entry = acCreateAttrEnumEntry( $acActiveParent, -1, $objAttr);
						break;
					default:
						$entry = acCreateAttrSliderEntry( $acActiveParent, -1, $objAttr, $attrMin, $attrMax);
						break;
				}
				if ($attrLabel != "") acSetLabel( $entry, $attrLabel);

				break;
		    } // end of switch
//		    $acEdited = 1;
//		} // end of "(!isRegAttr"
//	    } // else Object not found
//	} //else object of this attribute doesn't exist
}

global proc acRebuildPoseMenu()
{
	// do nothing
}

global proc acCleanBtnCmds()
{
	acCleanCmds();
}

global proc acCleanCmds()
{
	global string $acMasterNode;
	global string	$acCmds[];		// commands for buttons
	clear $acCmds;

	acRedrawEntry( $acMasterNode);

// now delete old acScript nodes
	acDeleteOldNodesWin( );


}

global proc acDeleteOldNodesWin()
{
	string $scriptNodes[] = `ls -type script`;
	string $oldAC[];
	for ( $s in $scriptNodes ) {
		if (!`attributeQuery -n $s -ex "nodeId"`) {
			string $scr = `getAttr ($s + ".before")`;
			if (size($scr) > 25 && (`substring $scr 1 26`) == "source attrCollection.mel;") $oldAC[size($oldAC)] = $s;
		}
	}
	if (size($oldAC)) {
		string $msg = "\n            ***IMPORTANT***\n\n";
		$msg += ("Found " + size($oldAC) + " old Attribute Collection Node(s)\nin this scene which have been converted\nto the new format.\n\n");
		$msg += "Please check the converted UI carefully.\n\nYou should then delete the node(s)\n\n";
		for ( $s in $oldAC ) $msg += "  " + $s + "\n";
		$msg += "\nwith the \"Delete\" button below.\n";
		$win = `window -mnb 0 -mxb 0 -title "Delete old attrCollection Script Nodes" -wh 270 340 acDelOldACWin`;
			string $deleteCmd = "delete ";
			for ( $s in $oldAC ) $deleteCmd += $s + " ";
			$deleteCmd += "; deleteUI " + $win + ";";
	
			$form = `formLayout -nd 100`;
				$pane = `paneLayout -configuration "single"`;
					scrollField -font "boldLabelFont" -wordWrap false -text $msg -editable false;
				setParent $form;
				$b1 = `button -label "Delete" -c $deleteCmd`;
				$b2 = `button -label "Close" -c ("deleteUI " + $win)`;
	
			formLayout -edit
				-af		$pane	"top"		0
				-af		$pane	"left"		0
				-af		$pane	"right"		0
				-ac		$pane	"bottom"	10 $b1
	
				-an		$b1		"top"
				-af		$b1		"left"		5
				-af		$b1		"bottom"	5
				-ap		$b1		"right"		2 50
	
				-an		$b2		"top"
				-ap		$b2		"left"		2 50
				-af		$b2		"bottom"	5
				-af		$b2		"right"		5
			$form;
	
		showWindow;
	}
}
global proc printfn( string $p)
{
//	print( $p + "\n");
}

global proc printn( string $p)
{
//	print( $p + "\n");
}

global proc printStrings( string $p[])
{
//	print( $p);
}

global proc printFloats( float $p[])
{
//	print( $p);
}

global proc printInts( int $p[])
{
//	print( $p);
}

global proc int acDoPrint()
{
	return 0;
}

global proc printTrace( int $level, string $msg)
{
// 	int $show = 2;
// 	$str = acFixedLengthStr( "", $level);
// 	if ($level <= $show) print( $str + "_TRACE: " + $msg + "\n");
}

global proc endTrace()
{}



//------------------ ButtonRow------------------------------
//-----------------Draw ButtonRow ------------------------------------

global proc string[] acDrawButtonRowEntry( string $node)
{
printTrace( 4, "acDrawButtonRowEntry: " + $node);

	int	$labelSize = max( 1, acGetOpt( "acPrefLabelSize", 140));
	int	$fieldSize = max( 1, acGetOpt( "acPrefFieldSize", 80));
	int	$sliderSize = max( 1, acGetOpt( "acPrefSliderSize", 160) * acGetOpt( "acPrefEnableSliders", 1));
	int $textureButton = acGetOpt( "acPrefEnableColorButtons", 0);
	int	$totalSize = $labelSize + $fieldSize + $sliderSize + ($textureButton * 30);

	string $specs[] = acGetSpecs( $node);
	string $ann = acGetAnnotation( $node);

	int $en[];
	$en[0] = $specs[0];
	$en[1] = $specs[1];
	$en[2] = $specs[2];
	$en[3] = $specs[3];
	int $nb = $en[0] + $en[1] + $en[2] + $en[3];	// number of buttons
	int $offset = $specs[4];

	int $bs = 1;
	int $cs = 1;
	if ($nb) {
		$bs = ($totalSize-($nb*$offset+$offset)) / $nb;	// button size
		$cs = ($totalSize) / $nb;			// column size
	}

	string $a[];
	tokenize $ann "|" $a;
	$a[0] = strip($a[0]);
	$a[1] = strip($a[1]);
	$a[2] = strip($a[2]);
	$a[3] = strip($a[3]);


	string $l[];
	$l[0] = $specs[5];
	$l[1] = $specs[6];
	$l[2] = $specs[7];
	$l[3] = $specs[8];

	string $findCmd = "proc string findConnection( int $index) { return (acFindConnection( \"" + $node + "\", $index)); }\n";
	string $scr[];
	$scr[0] = $findCmd + $specs[9];
	$scr[1] = $findCmd + $specs[10];
	$scr[2] = $findCmd + $specs[11];
	$scr[3] = $findCmd + $specs[12];
	
	string $form = `formLayout -nd 100`;
	string $b[];
	$b0 = $b[0] = `button -label $l[0] -ann $a[0] -w $bs -vis $en[0] -command $scr[0]`;
	$b1 = $b[1] = `button -label $l[1] -ann $a[1] -w $bs -vis $en[1] -command $scr[1]`;
	$b2 = $b[2] = `button -label $l[2] -ann $a[2] -w $bs -vis $en[2] -command $scr[2]`;
	$b3 = $b[3] = `button -label $l[3] -ann $a[3] -w $bs -vis $en[3] -command $scr[3]`;

    if (!acIsLocked( $node)) {
		button -e -dragCallback ("acDragDirectCB \"" + $node + "\"") $b0;
		button -e -dragCallback ("acDragDirectCB \"" + $node + "\"") $b1;
		button -e -dragCallback ("acDragDirectCB \"" + $node + "\"") $b2;
		button -e -dragCallback ("acDragDirectCB \"" + $node + "\"") $b3;
	}

	string $vb[]; int $j = 0;
	for ( $i=0 ; $i<4 ; $i++ ) if ($en[$i]) $vb[$j++] = $b[$i];
	if ($nb) formLayout -e -attachForm $vb[0] "left" $offset $form;
	for ( $i=1 ; $i<$nb ; $i++ ) formLayout -e -attachControl $vb[$i] "left" $offset $vb[$i-1] $form;

endTrace();
	return { $form, $b[0], $b[1], $b[2], $b[3], $form };

	
}




global proc string acFindConnection( string $node, int $index)
{
printTrace( 5, "acFindConnection: " + $node);


//	string $tmp[] = `listConnections -p 1 ($node + ".c[" + $index + "]")`;
	string $tmp[] = acGetConnections( $node, $index);
	if ($tmp[0] == "") {
		string $label = acGetLabel( $node);
		string $specs[] = acGetSpecs( $node);
		string $oldNames[];
		tokenize $specs[13] " " $oldNames;
		endTrace();
		error ("Expression in \"" + $label + "\" -- Could not find Attribute \"" + $oldNames[$index] + "\" (previous Name)");
	} else {
		endTrace();
		return $tmp[0];
	}

}


global proc string acDecodeExpression( string $node, string $text, string $oldNames[])
{
printTrace( 4, "acDecodeExpression: " + $node);

// printn("acDecodeExpression");
	string $c1[] = acGetIndexConnections( $node);
	string $f;
	int $safe = 500;				// counter for safety
	while (size($f = `match "\\(findConnection\\([0-9]+\\)\\)" $text`) && ($safe--)) {
		$f = `substitute "\\(findConnection\\(" $f ""`;
		$f = `substitute "\\)\\)" $f ""`;
		int $num = (int)$f;

// wenn ein index keine connection hat, dann wird der letzte gespeicherte Attributname an diese Stelle gesetzt
		if ($c1[$num] == "") {
			warning ("Could not find a connection to Attribute \"" + $oldNames[$num] + "\" (previous Name)");
			$c1[$num] = $oldNames[$num];
		}
// printn("acDecode: ersetze index " + $num + " durch attribut >>>" + $c1[$num] + "<<<");
		$text = `substitute "\\(findConnection\\([0-9]+\\)\\)" $text ("\"" + $c1[$num] + "\"")`;
	}
endTrace();
	return $text;


}

global proc string[] acEncodeExpression( string $node, string $text)
{
printTrace( 4, "acEncodeExpression: " + $node);

// this function replaces all attribute names with a simple function call
//   it also connects the attributes to $node
//  - it returns the modified text (string0) and a list of attribute names (string1)

	// ----------------leadngSpc -firstChar   -otherChar     -dot  -firstChar  -otherChar     -opt "[" -optSpc -index optSpc opt "]" -Space
	string $regExp = "(\")([a-zA-Z_]+)([a-zA-Z0-9_:]*)(\\.)([a-zA-Z_]+)([a-zA-Z0-9_]*)(((\\[)(\\ *)([0-9]+)(\\ *)(\\]))*)(\")";

	string $c[] = acGetIndexConnections( $node);			// found attr names
	int $start = size( $c);

	string $names;
//	string $nameArray[];
//	tokenize $names " " $nameArray;

	string $found;
	int $safe = 500;
	while (size($found = `match $regExp $text`) && ($safe--)) {

		string $f = $found;
		// strip spaces, brackets etc. at start and end
		$found = `substitute "^[\\ \"()]*" $found ""`;
		$found = `substitute "[\\ \"()]*$" $found ""`;

		// check if the atribute exists and get the real name
		{
			string $objAttr[];
			tokenize $found "." $objAttr;
			if (`objExists $objAttr[0]` && `attributeExists $objAttr[1] $objAttr[0]`) {
				$tmp = `listAttr $found`;
				$found = $objAttr[0] + "." + $tmp[0];
			}
		}

		int $index = acStringArrayIndex( $found, $c);					// is that attribute already there?
		if ($index == size($c)) $names = $names + $found + " ";			// NO, save it as NEW
		$c[$index] = $found;
		// prepare for substitute
		$found = $f;
		$found = substituteAllString( $found, "[", "\\[");
		$found = substituteAllString( $found, "]", "\\]");
		$found = substituteAllString( $found, ".", "\\.");
		$found = substituteAllString( $found, "(", "\\(");
		$found = substituteAllString( $found, ")", "\\)");
		$found = substituteAllString( $found, " ", "");
// printn("---ersetze >>>" + $found + "<<< durch >>>(findConnection(" + $index + "))<<<");



		int $safe1 = 500;
		while (size(`match $found $text`) && ($safe1--)) {
			$text = substitute( $found,  $text,"(findConnection(" + $index + "))");
//				printn($text + "\n");
		}
	}
	for ( $i=$start ; $i<size($c) ; $i++ ) acConnect( $node, $i, $c[$i]);
endTrace();
	return { $text, $names};


}

//------------------- ButtonRow Edit UI---------------------------------------
global proc string acEditButtonRow( string $node, string $control)
{
printTrace( 2, "acEditButtonRow: " + $node);

	string $specs[] = acGetSpecs( $node);

	int $en[];
	$en[0] = $specs[0];
	$en[1] = $specs[1];
	$en[2] = $specs[2];
	$en[3] = $specs[3];

	string $l[];
	$l[0] = $specs[5];
	$l[1] = $specs[6];
	$l[2] = $specs[7];
	$l[3] = $specs[8];

	string $oldNames[];
	tokenize $specs[13] " " $oldNames;
	string $scr[];
	$scr[0] = acDecodeExpression( $node, $specs[9], $oldNames);
	$scr[1] = acDecodeExpression( $node, $specs[10], $oldNames);
	$scr[2] = acDecodeExpression( $node, $specs[11], $oldNames);
	$scr[3] = acDecodeExpression( $node, $specs[12], $oldNames);
	

	setParent $control;
	string $cbg = `checkBoxGrp -label "Enable Button"
						-numberOfCheckBoxes 4 
						-cw 2 60 -cw 3 60 -cw 4 60 -cw 5 60
						-label1 "B1"
						-label2 "B2"
						-label3 "B3"
						-label4 "B4"
						-v1 ((int)$specs[0])
						-v2 ((int)$specs[1])
						-v3 ((int)$specs[2])
						-v4 ((int)$specs[3])`;

	string $ctrl = `intFieldGrp -label "Offset" -numberOfFields 1 -v1 ((int)$specs[4]) -cw 2 50`;
	intFieldGrp -e -cc ("acGetEditValue( \"" + $node + "\", 4, \"intFieldGrp -q -v1 " + $ctrl + "\");") $ctrl;

	separator -h 10 -style "none";

// go up one step for the formLayout - this is not nice
	setParent ..;
	$tab = `tabLayout`;
	for ( $i=0 ; $i<4 ; $i++ ) {
		setParent $tab;
		$subForm = `formLayout -nd 100`;

		$tfg = `textFieldGrp -label "Button Label" -text $l[$i] -cw 1 100`;


//		$color = `colorSliderGrp  -cw 1 100
//					-label "Color"
//					-rgb .5 .5 .5`;

    // das Change Command fuer die TextFields aendert auch gleich das TabLabel
		textFieldGrp -e -cc ("tabLayout -e -tli " + ($i+1) + "((`checkBoxGrp -q -v" + ($i+1) + " " + $cbg + "`) ? (`textFieldGrp -q -text " + $tfg + "`) : \"-.-.-.-\") " + $tab + ";" +
							 "acGetEditValue( \"" + $node + "\", " + ($i+5) + ", \"textFieldGrp -q -text " + $tfg + "\");") $tfg;

		$txt = `text -label "   Command(s):" -align "left"`;

		string $ctrl = `scrollField -h 150 -text $scr[$i]`;
		string $cmd = ("acGetEditValue( \"" + $node + "\", " + ($i+9) + ", encodeString( \"scrollField -q -text " + $ctrl + "\"));");
		scrollField -e -cc $cmd $ctrl;

		formLayout -e
			-attachForm		$tfg	"top"	10
			-attachForm		$tfg	"left"	0
			-attachNone		$tfg	"right"
			-attachNone		$tfg	"bottom"

//			-attachControl	$color	"top"	10 $tfg
//			-attachForm		$color	"left"	0
//			-attachNone		$color	"right"
//			-attachNone		$color	"bottom"
//
//			-attachControl	$txt	"top"	10 $color
			-attachControl	$txt	"top"	10 $tfg
			-attachForm		$txt	"left"	0
			-attachNone		$txt	"right"
			-attachNone		$txt	"bottom"
		
			-attachControl	$ctrl	"top"	10 $txt
			-attachForm		$ctrl	"left"	0
			-attachForm		$ctrl	"right" 0
			-attachForm		$ctrl	"bottom" 0
		$subForm;

// tabLabels setzen
// dabei wird gecheckt, ob der entspr. Button auch an ist
		tabLayout -e -tli ($i+1) ($en[$i] ? $l[$i] : "-.-.-.-")$tab;
	}

// wenn eine von den CheckBoxen angeklickt wird, dann wird auch gleich
// das entsprechende Tablabel geaendert

	checkBoxGrp -e -cc ("string $specs[] = acGetSpecs( \"" + $node + "\");" +
						"tabLayout -e -tli 1 ((`checkBoxGrp -q -v1 " + $cbg + "`) ? $specs[5] : \"-.-.-.-\") " + $tab + ";" +
						"tabLayout -e -tli 2 ((`checkBoxGrp -q -v2 " + $cbg + "`) ? $specs[6] : \"-.-.-.-\") " + $tab + ";" +
						"tabLayout -e -tli 3 ((`checkBoxGrp -q -v3 " + $cbg + "`) ? $specs[7] : \"-.-.-.-\") " + $tab + ";" +
						"tabLayout -e -tli 4 ((`checkBoxGrp -q -v4 " + $cbg + "`) ? $specs[8] : \"-.-.-.-\") " + $tab + ";" +
						"acGetEditValue( \"" + $node + "\", 0, \"checkBoxGrp -q -v1 " + $cbg + "\");" +
						"acGetEditValue( \"" + $node + "\", 1, \"checkBoxGrp -q -v2 " + $cbg + "\");" +
						"acGetEditValue( \"" + $node + "\", 2, \"checkBoxGrp -q -v3 " + $cbg + "\");" +
						"acGetEditValue( \"" + $node + "\", 3, \"checkBoxGrp -q -v4 " + $cbg + "\");") $cbg;

// this return causes the Edit Win to attach the scrollField to the top and bottom
endTrace();
	return $tab;

}

//------------------- ButtonRow Set UI---------------------------------------
global proc acEditButtonRowUI( string $node)
{
printTrace( 4, "acEditButtonRowUI: " + $node);

// printn("ButtonRow Set UI");
	int	$labelSize = max( 1, acGetOpt( "acPrefLabelSize", 140));
	int	$fieldSize = max( 1, acGetOpt( "acPrefFieldSize", 80));
	int	$sliderSize = max( 1, acGetOpt( "acPrefSliderSize", 160)
				* acGetOpt( "acPrefEnableSliders", 1));
	int	$totalSize = $labelSize + $fieldSize + $sliderSize;

	string $specs[] = acGetSpecs( $node);
	string $ann = acGetAnnotation( $node);
	string $uiName = acGetUIName( $node);

	int $en[];
	$en[0] = $specs[0];
	$en[1] = $specs[1];
	$en[2] = $specs[2];
	$en[3] = $specs[3];
	int $nb = $en[0] + $en[1] + $en[2] + $en[3];	// number of buttons
	int $offset = $specs[4];

	int $bs = 1;
	int $cs = 1;
	if ($nb) {
		$bs = ($totalSize-($nb*$offset+$offset)) / $nb;	// button size
		$cs = ($totalSize) / $nb;			// column size
	}

	string $a[];
	tokenize $ann "|" $a;
	$a[0] = strip($a[0]);
	$a[1] = strip($a[1]);
	$a[2] = strip($a[2]);
	$a[3] = strip($a[3]);


	string $l[];
	$l[0] = $specs[5];
	$l[1] = $specs[6];
	$l[2] = $specs[7];
	$l[3] = $specs[8];


//--------------------------------------------------------------------
// hier muessen nun die scripte nach attribut namen durchsucht werden

// die ehemaligen Namen der Attribute
	string $oldNames[];
	tokenize $specs[13] " " $oldNames;
	$specs[13] = "";

// alle connections in ein array laden
	string $c1[] = acGetIndexConnections( $node);
	string $c2[];

// printn("liste der Connections VOR der ERSTEN Runde (anz = " + size($c1) + ") :");
// if (acDoPrint()) print $c1;
// printn("-----------------------------");

// alle vier commands nach "findConnection" durchsuchen, und die gefundenen indizies in ein zweites array

	for ( $i=0 ; $i<4 ; $i++ ) {
		// acEncodeExpression subsitutes the "findConnection" calls with the names of the attributes
		$specs[$i+9] = acDecodeExpression( $node, $specs[$i+9], $oldNames);
	}

// alle connections loeschen
	for ( $i=0 ; $i<size($c1) ; $i++ ) acDeletePlug( $node, $i);
		
// printn("liste der Connections nach dem loeschen:");
// if (acDoPrint()) print (acGetIndexConnections( $node));
// printn("-----------------------------");

// alle vier commands aus den specs nach attribut-namen durchsuchen
// - neu gefundene attribut-namen hinten an das 2. arrays anhaengen und in den specs ersetzen

// --- IMPORTANT!! ONLY those Attribute are found and replaced, which are properly enclosed in Double-Quotes (")

	$specs[13] = "";
	for ( $i=0 ; $i<4 ; $i++ ) {
		string $tmp[] = acEncodeExpression( $node, $specs[$i+9]);
		$specs[$i+9] = $tmp[0];
		$specs[13] = $specs[13] + " " + $tmp[1];

	}
	acSetSpecs( $node, $specs);


// der String im Fenster bleibt, wie er ist

//--------------------------------------------------------------------

	string $findCmd = "proc string findConnection( int $index) { return (acFindConnection( \"" + $node + "\", $index)); }\n";
	string $scr[];
	$scr[0] = $findCmd + $specs[9];
	$scr[1] = $findCmd + $specs[10];
	$scr[2] = $findCmd + $specs[11];
	$scr[3] = $findCmd + $specs[12];

	string $b[] = `formLayout -q -ca $uiName`;
	button -e -label $l[0] -ann $a[0] -w $bs -vis $en[0] -command $scr[0] $b[0];
	button -e -label $l[1] -ann $a[1] -w $bs -vis $en[1] -command $scr[1] $b[1];
	button -e -label $l[2] -ann $a[2] -w $bs -vis $en[2] -command $scr[2] $b[2];
	button -e -label $l[3] -ann $a[3] -w $bs -vis $en[3] -command $scr[3] $b[3];

// erst mal alles "un"attachen, damit sich die Breite des Layouts nicht aendert
	formLayout -e
		-attachNone $b[0] "left"
		-attachNone $b[1] "left"
		-attachNone $b[2] "left"
		-attachNone $b[3] "left"
	$uiName;

	formLayout -e -vis 0 $uiName;
	string $vb[]; int $j = 0;
	for ( $i=0 ; $i<4 ; $i++ ) if ($en[$i]) $vb[$j++] = $b[$i];
	if ($nb) formLayout -e -attachForm $vb[0] "left" $offset $uiName;
	for ( $i=1 ; $i<$nb ; $i++ ) formLayout -e -attachControl $vb[$i] "left" $offset $vb[$i-1] $uiName;

	formLayout -e -vis 1 $uiName;

	
endTrace();
}


global proc acAddFast( string $node)
{
printTrace( 4, "acAddFast: " + $node);

	if (size(acGetSelectedAttributes())) {
		acAddSelectedAttrsToGroup( acCreateGroupEntry( acVisibleTab( $node), -1, "New Group"), -1);       // oh weh, das ist nicht wirklich richtig
	}
endTrace();
}


proc setDefaultButtonSize( string $node, string $col, string $sep, string $but)
{
printTrace( 5, "setDefaultButtonSize: " + $node);

	if (acGetNodeType( acGetParentNode( $node)) == "TabLayout" ) {

		separator -e -style "none" -h 40 $sep;
		button -e -h 30 -label "   Select Attributes in the Channelbox and click here to add a new Group   " $but;

		if (size(acGetNodeChildren( $node))) {
			separator -e -h 5 $sep;
			button -e -h 18 -label " Add to new Group " $but;
		}
		columnLayout -e -vis (!acIsLocked( $node)) $col;
	}
endTrace();
}

// -----------------Draw Children --------------------------------

global proc acColumnLayoutDrawChildren( string $node, string $children[])
{
printTrace( 3, "acColumnLayoutDrawChildren: " + $node);

// printn("this is acColumnLayoutDrawChildren");
	string $ui[] = acGetUISpecial( $node);

	setDefaultButtonSize( $node, $ui[0], $ui[1], $ui[2]);
	for ( $ch in $children ) acDrawEntry( $ch);

endTrace();
}

// -----------------Child Deleted --------------------------------

global proc acColumnLayoutChildDeleted( string $node, int $cleanup, int $deleteUI)
{
printTrace( 4, "acColumnLayoutChildDeleted: " + $node);

// printn("this is acColumnLayoutChildDeleted");
// this function is called, if one of the tablayouts children was just deleted
	string $ui[] = acGetUISpecial( $node);

	setDefaultButtonSize( $node, $ui[0], $ui[1], $ui[2]);

endTrace();
}

//----------------------Column------------------------
global proc string acCreateColumnLayoutEntry( string $parentNode, int $index, string $label, string $ann)
{
printTrace( 3, "acCreateColumnLayoutEntry for node: " + $parentNode);

// specs are:
// - label (used as a tab label)

global string	$acActiveParent;

	string $node = acCreateNode( $parentNode, $index, "ColumnLayout", $label, $ann, acTypeOptions( "ColumnLayout"));

	// set a different label for the new tab
	$label = substituteAllString( $node, "_", " ");
	acSetLabel( $node, $label);

	$acActiveParent = $node;
endTrace();
	return $node;
}

//-----------------Draw ColumnLayout ------------------------------------

global proc string[] acDrawColumnLayoutEntry( string $node)
{
printTrace( 3, "acDrawColumnLayoutEntry: " + $node);

	int	$labelSize = acGetOpt( "acPrefLabelSize", 140);
	int	$fieldSize = acGetOpt( "acPrefFieldSize", 80);
	int	$sliderSize = acGetOpt( "acPrefSliderSize", 160)
				* acGetOpt( "acPrefEnableSliders", 1);
	if ($sliderSize < 1) $sliderSize = 1;
	int $totalWidth = $labelSize + $fieldSize + $sliderSize;

	string $specs[] = acGetSpecs( $node);
	string $ann = acGetAnnotation( $node);

	string $delName = `columnLayout -adj 0`;
	string $colName = `columnLayout -ann $ann -adjustableColumn ((int)$specs[0]) -rs ((int)$specs[1])`;

	setParent $delName;
	string $btnCol = `columnLayout -adj false`;
	string $sep, $but;

	if (acGetNodeType( acGetParentNode( $node)) == "TabLayout" ) {
		$sep = `separator`;
		$but = `button -c ("acAddSelToNewGroup( \"" + $node + "\", \"New Group\");")
						-ann "Select Channels in the Channelbox and click here to add to a new Group"`;
	}

	setDefaultButtonSize( $node, $btnCol, $sep, $but);

endTrace();
	return {$colName, $btnCol, $sep, $but, $delName};
}

global proc acEditColumnLayout( string $node, string $control)
{
printTrace( 4, "acEditColumnLayout: " + $node);

	string $specs[] = acGetSpecs( $node);

	string $cb = `checkBoxGrp -ncb 1 -label "Adjust Children" -v1 ((int)$specs[0])`;
	checkBoxGrp -e -cc ("acGetEditValue( \"" + $node + "\", 0, \"checkBoxGrp -q -v1 " + $cb + "\");") $cb;
	string $rs = `intFieldGrp -numberOfFields 1 -label "Row Spacing" -v1 ((int)$specs[1])`;
	intFieldGrp -e -cc ("acGetEditValue( \"" + $node + "\", 1, \"intFieldGrp -q -v1 " + $rs + "\");") $rs;

endTrace();
}

//--------------Set Group UI (from EditWin)------------------------
global proc acEditColumnLayoutUI( string $node)
{
printTrace( 4, "acEditColumnLayoutUI: " + $node);

	string $specs[] = acGetSpecs( $node);
	string $uiName = acGetUIName( $node);

	columnLayout -e -adjustableColumn ((int)$specs[0]) -rs ((int)$specs[1]) $uiName;
//	acRedrawEntry( acGetParentNode( $node));
endTrace();
}



// replaced by "interToUI"
//proc string acMakeNiceLabel( string $label)
//{
//string	$niceLabel;
//string	$lastChar = "";
//
//
//	for ( $i=1 ; $i < size( $label)+1 ; $i++ ) {
//		$char = `substring $label $i $i`;
//		if ($i == 1) $char = toupper( $char);
//		else if (($char == toupper( $char)) && ($lastChar != toupper( $lastChar))) $char = " " + toupper( $char);
//		$niceLabel += $char;
//		$lastChar = $char;
//	}
//	return $niceLabel;
//}

global proc string acMakeLabel( string $attr)
{
printTrace( 5, "acMakeLabel: " + $attr);
endTrace();

	string $tmp[];
	tokenize $attr "." $tmp;
	string $objName = $tmp[0];
	
	// Label Type
	// 1 = objectName_shortName
	// 2 = shortName
	// 3 = objectName_longName
	// 4 = longName
	// 5 = Nice Name
    switch((int)acGetOpt( "acPrefNameStyle", 3)) {
		case 1 :
			return $attr;
			break;
		case 2 :
			$tmp = `listAttr -sn $attr`;
			return $tmp[0];
			break;
		case 3 :
			$tmp = `listAttr $attr`;
			return ($objName + "." + $tmp[0]);
			break;
		case 4 :
			$tmp = `listAttr $attr`;
			return $tmp[0];
			break;
		case 5 :
			$tmp = `listAttr $attr`;
//			return acMakeNiceLabel( $tmp[0]);
			return interToUI( $tmp[0]);
			break;
		default:
			break;
	}
}

global proc string acAttrAnnotation( string $attr)
{
printTrace( 5, "acAttrAnnotation: " + $attr);
endTrace();

	if (acGetOpt( "acPrefAnnotation", 1) && acGetOpt( "acPrefInitAnnotation", 0)) {
		string $tmp[];
		tokenize $attr "." $tmp;
		string $objName = $tmp[0];
	
		$tmp = `listAttr $attr`;
		return ($objName + "." + $tmp[0]);
	} else return "";
}


//------------------ CREATE ATTR ENUM ------------------------------
global proc string acCreateAttrEnumEntry( string $parentNode, int $index, string $attr)
{
printTrace( 4, "acCreateAttrEnumEntry: " + $parentNode);

// specs are:
// - label

	string $type = "AttrEnum";
	string $label = acMakeLabel( $attr);
	string $ann = acAttrAnnotation( $attr);
	string $specs[] = acTypeOptions( $type);
 	string $node = acCreateNode( $parentNode, $index, $type, $label, $ann, $specs);

	acConnect( $node, 0, $attr);

	$acActiveChild = $node;

endTrace();
	return $node;

}

//------------------ CREATE COLOR SLIDER------------------------------
global proc string acCreateColorSliderEntry( string $parentNode, int $index, string $attr)
{
printTrace( 4, "acCreateColorSliderEntry: " + $parentNode);

// specs are:
// - label

	string $type = "ColorSlider";
	string $label = acMakeLabel( $attr);
	string $ann = acAttrAnnotation( $attr);
	string $specs[] = acTypeOptions( $type);
 	string $node = acCreateNode( $parentNode, $index, $type, $label, $ann, $specs);

	acConnect( $node, 0, $attr);

	$acActiveChild = $node;

endTrace();
	return $node;

}

//------------------ CREATE SLIDER------------------------------
global proc string acCreateAttrSliderEntry( string $parentNode, int $index, string $attr, float $min, float $max)
{
printTrace( 4, "acCreateAttrSliderEntry: " + $parentNode);

// specs are:
// - label
// - min value
// - max value

	string $type = "AttrSlider";
	string $label = acMakeLabel( $attr);
	string $ann = acAttrAnnotation( $attr);
 	string $node = acCreateNode( $parentNode, $index, $type, $label, $ann, {(string)$min, (string)$max});

	acConnect( $node, 0, acConvertAttr( $attr));

	$acActiveChild = $node;

endTrace();
	return $node;

}

//---------------- CREATE AttrCheckBox-----------------------------------------------
global proc string acCreateAttrCheckBoxEntry( string $parentNode, int $index, string $attr, string $extraLabel)
{
printTrace( 4, "acCreateAttrCheckBoxEntry: " + $parentNode);

// specs are:
// - label
// - extraLabel

	string $type = "AttrCheckBox";
	string $label = acMakeLabel( $attr);
	string $ann = acAttrAnnotation( $attr);
 	string $node = acCreateNode( $parentNode, $index, $type, $label, $ann, {$extraLabel});

	acConnect( $node, 0, $attr);

	$acActiveChild = $node;

endTrace();
	return $node;

}



//---------------- CREATE Icon-----------------------------------------------
global proc string acCreateIconEntry( string $parentNode, int $index, string $label, string $iconPath, string $cmd)
{
printTrace( 4, "acCreateIconEntry: " + $parentNode);

// specs are:
// - label
// - style
// - icon path
// - command

	string $type = "Icon";
	string $ann;
 	string $node = acCreateNode( $parentNode, $index, $type, $label, $ann, {"iconAndTextVertical", $iconPath, $cmd});

	$acActiveChild = $node;
endTrace();
	return $node;
}


//---------------- CREATE Separator-----------------------------------------------
global proc string acCreateSeparatorEntry( string $parentNode, int $index, string $label, string $style, int $height)
{
printTrace( 4, "acCreateSeparatorEntry: " + $parentNode);

// specs are:
// - label
// - height
// - style

	string $type = "Separator";
	string $ann;
 	string $node = acCreateNode( $parentNode, $index, $type, $label, $ann, {(string)$height, (string)$style});

	$acActiveChild = $node;
endTrace();
	return $node;

}

//-----------------------------------------------------------------
//-----------------------------------------------------------------
//-----------------------------------------------------------------
//-----------------------------------------------------------------
//-----------------------------------------------------------------
//-----------------------------------------------------------------
//-----------------------------------------------------------------
//-----------------------------------------------------------------
//-----------------Draw Color Slider ------------------------------------

global proc string[] acDrawColorSliderEntry( string $node)
{
printTrace( 4, "acDrawColorSliderEntry: " + $node);

	int	$labelSize = max( 1, acGetOpt( "acPrefLabelSize", 140));
	int	$fieldSize = max( 1, acGetOpt( "acPrefFieldSize", 80));
	int	$sliderSize = max( 1, acGetOpt( "acPrefSliderSize", 160)
				* acGetOpt( "acPrefEnableSliders", 1));
	int $textureButton = acGetOpt( "acPrefEnableColorButtons", 0);

	string $label = acGetLabel( $node);
	string $ann = acGetAnnotation( $node);
	string $specs[] = acGetSpecs( $node);
	string $attrName[] = acGetConnections( $node, 0);

	if ($attrName[0] == "") {
		$attrName[0] = acGetConnectionName( $node, 0);
		endTrace();
		return {((string)`text -align "left" -h 25 -font "boldLabelFont" -label ("Couldn't find Attribute >" + $attrName[0] + "<")`)};
	}

	string $attrSlider = `attrColorSliderGrp -label $label
											-ann $ann
											-at $attrName[0]
											-sb $textureButton
											-cw 1 $labelSize
										    -cw 2 $fieldSize
										    -cw 3 $sliderSize
										    -cw 4 (29 * $textureButton + 1)
										    -cat 1 "right" 10
										    -cat 2 "both" 0
										    -cat 3 "both" 0
										    -cal 3 "center"`;


endTrace();
	return {$attrSlider};
}

//------------------- Color Slider Edit UI---------------------------------------
global proc acEditColorSlider( string $node, string $control)
{
printTrace( 4, "acEditColorSlider: " + $node);

	string $attrName[] = acGetConnections( $node, 0);

	setParent $control;

	// the attribute name
	// if not connected, the user may change this

	if (!acIsConnected( $node, 0)) {
		$attrName[0] = acGetConnectionName( $node, 0);
		$tf = `textFieldGrp -label "Attribute Name" -tx $attrName[0] -ed true`;
		textFieldGrp -e -cc ("string $attr=`textFieldGrp -q -tx " + $tf + "`;"
							+ "acSetConnectionName( \"" + $node + "\", 0, $attr);"
							+ "acRedrawEntry( acGetParentNode( \"" + $node + "\"));") $tf;
	} else 	textFieldGrp -label "Attribute Name" -tx $attrName[0] -ed false;
endTrace();

}

//------------------- Color Slider Set UI---------------------------------------
global proc acEditColorSliderUI( string $node)
{
printTrace( 4, "acEditColorSliderUI: " + $node);

	string $label = acGetLabel( $node);
	string $uiName = acGetUIName( $node);

	attrColorSliderGrp -e -label $label $uiName;
endTrace();
}


//-----------------------------------------------------------------
//-----------------Draw Attr Enum ------------------------------------

global proc string[] acDrawAttrEnumEntry( string $node)
{
printTrace( 4, "acDrawAttrEnumEntry: " + $node);

	int	$labelSize = max( 1, acGetOpt( "acPrefLabelSize", 140));
	int	$fieldSize = max( 1, acGetOpt( "acPrefFieldSize", 80));
	int	$sliderSize = max( 1, acGetOpt( "acPrefSliderSize", 160)
				* acGetOpt( "acPrefEnableSliders", 1));

	string $label = acGetLabel( $node);
	string $ann = acGetAnnotation( $node);
	string $attrName[] = acGetConnections( $node, 0);

	if ($attrName[0] == "") {
		$attrName[0] = acGetConnectionName( $node, 0);
		endTrace();
		return {((string)`text -align "left" -h 25 -font "boldLabelFont" -label ("Could not find Attribute >" + $attrName[0] + "<")`)};
	}

	string $attrSlider = `attrEnumOptionMenuGrp -label $label
											-ann $ann
											-at $attrName[0]
											-cw 1 $labelSize
//										    -cw 2 $fieldSize
										    -cat 1 "right" 10
										    -cat 2 "both" 0`;


endTrace();
	return {$attrSlider};
}

//------------------- Color Slider Edit UI---------------------------------------
global proc acEditAttrEnum( string $node, string $control)
{
printTrace( 4, "acEditAttrEnum: " + $node);

	string $attrName[] = acGetConnections( $node, 0);

	setParent $control;

	// the attribute name
	// if not connected, the user may change this

	if (!acIsConnected( $node, 0)) {
		$attrName[0] = acGetConnectionName( $node, 0);
		$tf = `textFieldGrp -label "Attribute Name" -tx $attrName[0] -ed true`;
		textFieldGrp -e -cc ("string $attr=`textFieldGrp -q -tx " + $tf + "`;"
							+ "acSetConnectionName( \"" + $node + "\", 0, $attr);"
							+ "acRedrawEntry( acGetParentNode( \"" + $node + "\"));") $tf;
	} else 	textFieldGrp -label "Attribute Name" -tx $attrName[0] -ed false;
endTrace();

}

//------------------- Attr Enum Set UI---------------------------------------
global proc acEditAttrEnumUI( string $node)
{
printTrace( 4, "acEditAttrEnumUI: " + $node);

	string $label = acGetLabel( $node);
	string $uiName = acGetUIName( $node);

	attrEnumOptionMenuGrp -e -label $label $uiName;
endTrace();
}


//-----------------------------------------------------------------
//-----------------Draw Slider ------------------------------------

global proc string[] acDrawAttrSliderEntry( string $node)
{
printTrace( 4, "acDrawAttrSliderEntry: " + $node);

	int	$labelSize = max( 1, acGetOpt( "acPrefLabelSize", 140));
	int	$fieldSize = max( 1, acGetOpt( "acPrefFieldSize", 80));
	int	$sliderSize = max( 1, acGetOpt( "acPrefSliderSize", 160)
				* acGetOpt( "acPrefEnableSliders", 1));
	int $textureButton = acGetOpt( "acPrefEnableColorButtons", 0);

	string $label = acGetLabel( $node);
	string $ann = acGetAnnotation( $node);
	string $specs[] = acGetSpecs( $node);
	string $attrName[] = acGetConnections( $node, 0);
	float $min = (float)$specs[0];
	float $max = (float)$specs[1];

	if ($attrName[0] == "") {
		$attrName[0] = acGetConnectionName( $node, 0);
		endTrace();
		return {((string)`text -align "left" -h 25 -font "boldLabelFont" -label ("Could not find Attribute >" + $attrName[0] + "<")`)};
	}

	string $attrSlider;
	if (acGetNodeType( acGetParentNode( $node)) == "VSliderLayout") {
		string $pSpecs[] = acGetSpecs( acGetParentNode( $node));
		int $width = ((int)$pSpecs[1] - (int)$pSpecs[2]);
		$attrSlider = `columnLayout`;
		rowLayout -numberOfColumns 1 -columnAttach 1 "both" (($width - 25) / 2) row;
			floatSlider -ann $ann -h $sliderSize -hr false slider;
			if ($max > $min) floatSlider -e -min $min -max $max ($attrSlider + "|row|slider");
		setParent ..;
		floatField -ann $ann -w $width field;
		text -label $label -ann $ann -w $width -align "center" label;
		connectControl ($attrSlider + "|row|slider") $attrName[0];
		connectControl ($attrSlider + "|field") $attrName[0];
	} else {
//printn("erzeuge Slider fr " + acConvertAttr( $attrName[0]));
		$attrSlider = `attrFieldSliderGrp -label $label
												-ann $ann
												-at (acConvertAttr( $attrName[0]))
//												-hmb (!$textureButton)
												-cw 1 $labelSize
											    -cw 2 $fieldSize
											    -cw 3 $sliderSize
											    -cw 4 (29 * $textureButton + 1)
											    -cat 1 "right" 10
											    -cat 2 "both" 0
											    -cat 3 "both" 0
											    -cal 3 "center"
											    `;

//bug: -sliderMinvalue und -sliderMaxValue scheinen nicht zu gehen
		if ($max > $min) attrFieldSliderGrp -e -min $min -max $max $attrSlider;
	}
endTrace();
	return {$attrSlider};
}

global proc acAttrSliderDDCallback( string $node)
{
printTrace( 5, "acAttrSliderDDCallback: " + $node);

	string $uiName = acGetUIName( $node);
	if (acGetNodeType( acGetParentNode( $node)) == "VSliderLayout") {
		layout -e -dragCallback ("acDragDirectCB \"" + $node + "\"")
					-dropCallback ("acDropDirectCB \"" + $node + "\"") ($uiName );
		layout -e -dragCallback ("acDragDirectCB \"" + $node + "\"") ($uiName + "|row");
		control -e -dragCallback ("acDragDirectCB \"" + $node + "\"") ($uiName + "|row|slider");
		control -e -dragCallback ("acDragDirectCB \"" + $node + "\"") ($uiName + "|label");
	} else {
		control -e -dragCallback ("acDragDirectCB \"" + $node + "\"")
					-dropCallback ("acDropDirectCB \"" + $node + "\"") $uiName;
		control -e -dragCallback ("acDragDirectCB \"" + $node + "\"") ($uiName + "|AFGlabel");
//		control -e -dragCallback ("acDragDirectCB \"" + $node + "\"") ($uiName + "|AFGfield");
		if (`control -exists ($uiName + "|AFGslider")`)
			control -e -dragCallback ("acDragDirectCB \"" + $node + "\"") ($uiName + "|AFGslider");
	}
endTrace();
}

global proc acAttrCheckBoxDDCallback( string $node)
{
printTrace( 5, "acAttrCheckBoxDDCallback: " + $node);

	string $uiName = acGetUIName( $node);
	control -e -dragCallback ("acDragDirectCB \"" + $node + "\"")
				-dropCallback ("acDropDirectCB \"" + $node + "\"") $uiName;
	control -e -dragCallback ("acDragDirectCB \"" + $node + "\"") ($uiName + "|label");
	control -e -dragCallback ("acDragDirectCB \"" + $node + "\"") ($uiName + "|check1");
endTrace();
}

global proc acColorSliderDDCallback( string $node)
{
printTrace( 5, "acColorSliderDDCallback: " + $node);

	string $uiName = acGetUIName( $node);
	control -e -dragCallback ("acDragDirectCB \"" + $node + "\"")
				-dropCallback ("acDropDirectCB \"" + $node + "\"") $uiName;
	control -e -dragCallback ("acDragDirectCB \"" + $node + "\"") ($uiName + "|label");
	control -e -dragCallback ("acDragDirectCB \"" + $node + "\"") ($uiName + "|canvas");
	control -e -dragCallback ("acDragDirectCB \"" + $node + "\"") ($uiName + "|slider");
	control -e -dragCallback ("acDragDirectCB \"" + $node + "\"") ($uiName + "|button");
endTrace();
}

global proc acAttrEnumDDCallback( string $node)
{
printTrace( 5, "acAttrEnumDDCallback: " + $node);

	string $uiName = acGetUIName( $node);
	control -e -dragCallback ("acDragDirectCB \"" + $node + "\"")
				-dropCallback ("acDropDirectCB \"" + $node + "\"") $uiName;
	control -e -dragCallback ("acDragDirectCB \"" + $node + "\"") ($uiName + "|label");
//	control -e -dragCallback ("acDragDirectCB \"" + $node + "\"") ($uiName + "|optionMenu");
endTrace();
}


 
//------------------- Slider Edit UI---------------------------------------
global proc acEditAttrSlider( string $node, string $control)
{
printTrace( 4, "acEditAttrSlider: " + $node);

	string $specs[] = acGetSpecs( $node);
	string $attrName[] = acGetConnections( $node, 0);
	float $min = (float)$specs[0];
	float $max = (float)$specs[1];

	setParent $control;
	if (!acIsConnected( $node, 0)) {
		$attrName[0] = acGetConnectionName( $node, 0);
		$tf = `textFieldGrp -label "Attribute Name" -tx $attrName[0] -ed true`;
		textFieldGrp -e -cc ("string $attr=`textFieldGrp -q -tx " + $tf + "`;"
							+ "acSetConnectionName( \"" + $node + "\", 0, $attr);"
							+ "acRedrawEntry( acGetParentNode( \"" + $node + "\"));") $tf;
	} else 	textFieldGrp -label "Attribute Name" -tx $attrName[0] -ed false;

	$ctrl = `floatFieldGrp -label "Slider Min/Max" -numberOfFields 2 -v1 $min -v2 $max`;
	floatFieldGrp -e -cc ("acGetEditValue( \"" + $node + "\", 0, \"floatFieldGrp -q -v1 " + $ctrl + "\");acGetEditValue( \"" + $node + "\", 1, \"floatFieldGrp -q -v2 " + $ctrl + "\");") $ctrl;
endTrace();
}

//------------------- Slider Set UI---------------------------------------
global proc acEditAttrSliderUI( string $node)
{
printTrace( 4, "acEditAttrSliderUI: " + $node);

	string $label = acGetLabel( $node);
	string $ann = acGetAnnotation( $node);
	string $specs[] = acGetSpecs( $node);
	float $minmax[];
	float $min = $minmax[0] = (float) $specs[0];
	float $max = $minmax[1] = (float) $specs[1];
	string $uiName = acGetUIName( $node);
	int $isVertical = (acGetNodeType( acGetParentNode( $node)) == "VSliderLayout");

	string $attr;
	string $attrNode;
	string $tmp[] = acGetConnections( $node, 0);
	$tmp = `listAttr $tmp[0]`;
	$attr = $tmp[0];
	$tmp = acGetConnections( $node, 0);
	$tmp = `ls -o $tmp[0]`;
	$attrNode = $tmp[0];


// Bugfix: attributeQuery can't handle attributes with alias and also no index

	string $queryOkName = acGetRealAttrName( $attrNode + "." + $attr);
	string $tmp[];
	tokenize $queryOkName "[" $tmp;
	$queryOkName = $tmp[0];

//printn("attribute Name ist : " + $attr);
//printn("attribute Node ist : " + $attrNode);
//printn("queryOkName ist : " + $queryOkName);

	if ($isVertical) {
		text -e -align "center" -label $label -ann $ann ($uiName + "|label");
		floatSlider -e -ann $ann ($uiName + "|row|slider");
		floatField -e -ann $ann ($uiName + "|field");
	} else attrFieldSliderGrp -e -label $label -ann $ann $uiName;
	if ($max > $min) {
		// test if there's a hard range
		if (`attributeQuery -re -n $attrNode $queryOkName`) {		// range exists
//printn("RANGE EXISTS");
			$minmax = `attributeQuery -r -n $attrNode $queryOkName`;
			if ($min < $minmax[0] || $min >= $minmax[1]) {
				warning ("Min Value out of Range of Attribute! Setting Min to " + $minmax[0]);
				$min = $minmax[0];
				$specs[0] = $min;
				acSetSpecs( $node, $specs);
			}
			if ($max > $minmax[1] || $max <= $minmax[0]) {
				warning ("Max Value out of Range of Attribute! Setting Max to " + $minmax[1]);
				$max = $minmax[1];
				$specs[1] = $max;
				acSetSpecs( $node, $specs);
			}
			if ($isVertical) floatSlider -e -min $min -max $max ($uiName + "|row|slider");
			else attrFieldSliderGrp -e -min $min -max $max $uiName;
		} else {		// no hard Range, set a Slider Range
			if ($isVertical) floatSlider -e -min $min -max $max ($uiName + "|row|slider");
			else attrFieldSliderGrp -e -min $min -max $max $uiName;
		}
	} else {	// no min/max set
		if (!$isVertical) {
			catch( "attrFieldSliderGrp -e -min 0 -max 0 $uiName");
//			attrFieldSliderGrp -e -sliderMinValue 0 -sliderMaxValue 0 $uiName;
		}
	}
endTrace();
}



//-----------------Draw CheckBox ------------------------------------
global proc string[] acDrawAttrCheckBoxEntry( string $node)
{
printTrace( 4, "acDrawAttrCheckBoxEntry: " + $node);

	int	$labelSize = max( 1, acGetOpt( "acPrefLabelSize", 140));
	int	$fieldSize = max( 1, acGetOpt( "acPrefFieldSize", 80));
	int	$sliderSize = max( 1, acGetOpt( "acPrefSliderSize", 160)
				* acGetOpt( "acPrefEnableSliders", 1));


	string $label = acGetLabel( $node);
	string $ann = acGetAnnotation( $node);
	string $specs[] = acGetSpecs( $node);
	string $attrName[] = acGetConnections( $node, 0);

	if ($attrName[0] == "") {
		$attrName[0] = acGetConnectionName( $node, 0);
		endTrace();
		return {((string)`text -align "left" -h 25 -font "boldLabelFont" -label ("Could not find Attribute >" + $attrName[0] + "<")`)};
	}

	string $attrCheckBox = `checkBoxGrp -label $label
										-ann $ann
										-label1 $specs[0]
										-ncb 1
										-adj 2
										-cw 1 $labelSize
										-cw 2 $fieldSize
										-cat 1 "right" 10
										-cat 2 "both" 0
										-cal 2 "left"`;
//										-cal 3 "left"`;

	connectControl -index 2 $attrCheckBox $attrName[0];
endTrace();
	return {$attrCheckBox};
}

//-----------------Edit CheckBox UI------------------------------------
global proc acEditAttrCheckBox( string $node, string $control)
{
printTrace( 4, "acEditAttrCheckBox: " + $node);

	string $specs[] = acGetSpecs( $node);
	string $extraLabel = $specs[0];

	setParent $control;

	// the attribute name
	// if not connected, the user may change this
	string $attrName[] = acGetConnections( $node, 0);
	if (!acIsConnected( $node, 0)) {
		$attrName[0] = acGetConnectionName( $node, 0);
		$tf = `textFieldGrp -label "Attribute Name" -tx $attrName[0] -ed true`;
		textFieldGrp -e -cc ("string $attr=`textFieldGrp -q -tx " + $tf + "`;"
							+ "acSetConnectionName( \"" + $node + "\", 0, $attr);"
							+ "acRedrawEntry( acGetParentNode( \"" + $node + "\"));") $tf;
	} else 	textFieldGrp -label "Attribute Name" -tx $attrName[0] -ed false;

	string $ctrl = `textFieldGrp -label "Extra Label" -text $extraLabel`;
	textFieldGrp -e -cc ("acGetEditValue( \"" + $node + "\", 0, \"textFieldGrp -q -text " + $ctrl + "\");") $ctrl;

endTrace();
}

//------------------- AttrCheckBox Set UI---------------------------------------
global proc acEditAttrCheckBoxUI( string $node)
{
printTrace( 4, "acEditAttrCheckBoxUI: " + $node);

	string $label = acGetLabel( $node);
	string $ann = acGetAnnotation( $node);
	string $specs[] = acGetSpecs( $node);
	string $extraLabel = $specs[0];

	string $uiName = acGetUIName( $node);
	checkBoxGrp -e -label $label -ann $ann -l1 $extraLabel $uiName;

endTrace();
}

//-----------------Draw Enum------------------------------------


//-----------------Draw Icon ------------------------------------

global proc string[] acDrawIconEntry( string $node)
{
printTrace( 4, "acDrawIconEntry: " + $node);


	string $label = acGetLabel( $node);
	string $ann = acGetAnnotation( $node);
	string $specs[] = acGetSpecs( $node);

	string $findCmd = "proc string findConnection( int $index) { return (acFindConnection( \"" + $node + "\", $index)); }\n";

	string $icon = `iconTextButton -style $specs[0]
							-label $label
							-ann $ann
							-image1 $specs[1]
							-command ($findCmd + $specs[2])`;
endTrace();
	return {$icon};
}

//------------------- Icon Edit UI---------------------------------------
global proc string acEditIcon( string $node, string $control)
{
printTrace( 4, "acEditIcon: " + $node);

	string $label = acGetLabel( $node);
	string $ann = acGetAnnotation( $node);
	string $specs[] = acGetSpecs( $node);
	string $style = $specs[0];
	string $image = $specs[1];

	string $oldNames[];
	tokenize $specs[3] " " $oldNames;
	string $command = acDecodeExpression( $node, $specs[2], $oldNames);

	setParent $control;
	string $ctrl = `optionMenuGrp -label "Icon Style" -columnAlign 1 "right" -cw 2 120`;
		menuItem -label "iconOnly";
		menuItem -label "textOnly";
		menuItem -label "iconAndTextHorizontal";
		menuItem -label "iconAndTextVertical";
	optionMenuGrp -e -v $style $ctrl;
	optionMenuGrp -e -cc ("acGetEditValue( \"" + $node + "\", 0, \"optionMenuGrp -q -v " + $ctrl + "\");") $ctrl;

	string $ctrl = `textFieldButtonGrp -label "Icon Image File" -text $image -buttonLabel "Browse..." -cw 2 185`;
	string $cmd = ("acGetEditValue( \"" + $node + "\", 1, \"textFieldButtonGrp -q -text " + $ctrl + "\");");
	textFieldButtonGrp -e -buttonCommand ("fileBrowser (\"acFileCallback \\\"" + $ctrl + "\\\" \\\"" + encodeString(encodeString($cmd)) + "\\\" \") \"Icon\" \"image\" 0;") $ctrl;
	textFieldButtonGrp -e -cc $cmd $ctrl;

	separator -style "none" -h 10;
	text -align "left" -label "     Command(s):";

// go up one step for the formLayout - this is not nice
	setParent ..;
	string $ctrl = `scrollField -text $command`;
	string $cmd = ("acGetEditValue( \"" + $node + "\", 2, encodeString(\"scrollField -q -text " + $ctrl + "\"));");
	scrollField -e -cc $cmd $ctrl;

// this return causes the Edit Win to attach the scrollField to the to and bottom
endTrace();
	return $ctrl;
}

//------------------- Icon Set UI---------------------------------------
global proc acEditIconUI( string $node)
{
printTrace( 4, "acEditIconUI: " + $node);


	string $label = acGetLabel( $node);
	string $ann = acGetAnnotation( $node);
	string $specs[] = acGetSpecs( $node);

//--------------------------------------------------------------------
//--------------------------------------------------------------------
//--------------------------------------------------------------------
// hier muessen nun die scripte nach attribut namen durchsucht werden

// die ehemaligen Namen der Attribute
	string $oldNames[];
	tokenize $specs[3] " " $oldNames;
	$specs[3] = "";

// alle connections in ein array laden
	string $c1[] = acGetIndexConnections( $node);

// printn("liste der Connections VOR der ERSTEN Runde (anz = " + size($c1) + ") :");
// if (acDoPrint()) print $c1;
// printn("-----------------------------");

// alle vier commands nach "findConnection" durchsuchen, und die gefundenen indizies in ein zweites array

	// acEncodeExpression subsitutes the "findConnection" calls with the names of the attributes
	$specs[2] = acDecodeExpression( $node, $specs[2], $oldNames);

// alle connections loeschen
	for ( $i=0 ; $i<size($c1) ; $i++ ) acDeletePlug( $node, $i);
		

// --- IMPORTANT!! ONLY those Attribute are found and replaced, which are properly enclosed in Double-Quotes (")

	$specs[3] = "";
	string $tmp[] = acEncodeExpression( $node, $specs[2]);
	$specs[2] = $tmp[0];
	$specs[3] = $specs[3] + " " + $tmp[1];

	acSetSpecs( $node, $specs);


// der String im Fenster bleibt, wie er ist

//--------------------------------------------------------------------
//--------------------------------------------------------------------
//--------------------------------------------------------------------

	string $findCmd = "proc string findConnection( int $index) { return (acFindConnection( \"" + $node + "\", $index)); }\n";

	string $uiName = acGetUIName( $node);
	iconTextButton -e -label $label
					-ann $ann
					-style $specs[0]
					-image1 $specs[1]
					-command ($findCmd + $specs[2]) $uiName;

endTrace();
}


//-----------------Draw ButtonRow ------------------------------------



//-----------------Draw Text ------------------------------------
global proc string[] acDrawTextEntry( string $node)
{
printTrace( 4, "acDrawTextEntry: " + $node);

	string $label = acGetLabel( $node);
	string $ann = acGetAnnotation( $node);
	string $specs[] = acGetSpecs( $node);
	string $uiName = `text -label $label -ann $ann -h ((int)$specs[0]) -align $specs[1] -font $specs[2]`;
endTrace();
	return {$uiName};
}
//------------------- Text Edit UI---------------------------------------
global proc acEditText( string $node, string $control)
{
printTrace( 4, "acEditText: " + $node);

	string $label = acGetLabel( $node);
	string $ann = acGetAnnotation( $node);
	string $specs[] = acGetSpecs( $node);
	int $height = (int)$specs[0];
	string $align = $specs[1];
	string $font = $specs[2];

	setParent $control;
	string $ctrl = `intFieldGrp -label "Height" -numberOfFields 1 -v1 $height -cw 2 50`;
	intFieldGrp -e -cc ("acGetEditValue( \"" + $node + "\", 0, \"intFieldGrp -q -v1 " + $ctrl + "\");") $ctrl;

	string $ctrl = `optionMenuGrp -label "Align" -columnAlign 1 "right"`;
		menuItem -label "left";
		menuItem -label "right";
		menuItem -label "center";
	optionMenuGrp -e -v $align $ctrl;
	optionMenuGrp -e -cc ("acGetEditValue( \"" + $node + "\", 1, \"optionMenuGrp -q -v " + $ctrl + "\");") $ctrl;

	string $ctrl = `optionMenuGrp -label "Font" -columnAlign 1 "right"`;
		menuItem -label "boldLabelFont";
		menuItem -label "smallBoldLabelFont";
		menuItem -label "tinyBoldLabelFont";
		menuItem -label "plainLabelFont";
		menuItem -label "smallPlainLabelFont";
		menuItem -label "obliqueLabelFont";
		menuItem -label "smallObliqueLabelFont";
		menuItem -label "fixedWidthFont";
		menuItem -label "smallFixedWidthFont";
	optionMenuGrp -e -v $font $ctrl;
	optionMenuGrp -e -cc ("acGetEditValue( \"" + $node + "\", 2, \"optionMenuGrp -q -v " + $ctrl + "\");") $ctrl;


endTrace();
}

//------------------- Text Set UI---------------------------------------
global proc acEditTextUI( string $node)
{
printTrace( 4, "acEditTextUI: " + $node);

	string $label = acGetLabel( $node);
	string $ann = acGetAnnotation( $node);
	string $specs[] = acGetSpecs( $node);
	int $height = (int)$specs[0];
	string $align = $specs[1];
	string $font = $specs[2];

	string $uiName = acGetUIName( $node);
	text -e -label $label -ann $ann -h $height -font $font -align $align $uiName;

endTrace();
}


//-----------------Draw Separator ------------------------------------

global proc string[] acDrawSeparatorEntry( string $node)
{
printTrace( 4, "acDrawSeparatorEntry: " + $node);

	string $ann = acGetAnnotation( $node);
	string $specs[] = acGetSpecs( $node);
	string $uiName = `separator -ann $ann -h ((int)$specs[0]) -style $specs[1]`;
endTrace();
	return {$uiName};
}

//------------------- Separator Edit UI---------------------------------------
global proc acEditSeparator( string $node, string $control)
{
printTrace( 4, "acEditSeparator: " + $node);

	string $specs[] = acGetSpecs( $node);
	int $height = (int)$specs[0];
	string $style = $specs[1];

	setParent $control;
	string $ctrl = `intFieldGrp -label "Separator Height" -numberOfFields 1 -v1 $height -cw 2 50`;
	intFieldGrp -e -cc ("acGetEditValue( \"" + $node + "\", 0, \"intFieldGrp -q -v1 " + $ctrl + "\");") $ctrl;

	string $ctrl = `optionMenuGrp -label "Separator Style" -columnAlign 1 "right"`;
		menuItem -label "none";
		menuItem -label "single";
		menuItem -label "double";
		menuItem -label "singleDash";
		menuItem -label "doubleDash";
		menuItem -label "in";
		menuItem -label "out";
	optionMenuGrp -e -v $style $ctrl;
	optionMenuGrp -e -cc ("acGetEditValue( \"" + $node + "\", 1, \"optionMenuGrp -q -v " + $ctrl + "\");") $ctrl;

endTrace();
}

//------------------- Separator Set UI---------------------------------------
global proc acEditSeparatorUI( string $node)
{
printTrace( 4, "acEditSeparatorUI: " + $node);

	string $ann = acGetAnnotation( $node);
	string $specs[] = acGetSpecs( $node);
	int $height = (int)$specs[0];
	string $style = $specs[1];

	string $uiName = acGetUIName( $node);
	separator -e -ann $ann -h $height -style $style $uiName;

endTrace();
}

//-----------------Draw Button ------------------------------------

global proc string[] acDrawButtonEntry( string $node)
{
printTrace( 4, "acDrawButtonEntry: " + $node);

	string $label = acGetLabel( $node);
	string $ann = acGetAnnotation( $node);
	string $specs[] = acGetSpecs( $node);

	string $findCmd = "proc string findConnection( int $index) { return (acFindConnection( \"" + $node + "\", $index)); }\n";
	string $scr[];
	string $command = $findCmd + $specs[2];

//	string $uiName = `rowLayout -numberOfColumns 1
////								-columnWidth1 ((int)$specs[2])
////								-adjustableColumn 1
//								-columnAlign  1 "center"
//								-columnAttach 1 "left" ((int)$specs[1])`;
//
//	button -label $specs[0] -w ((int)$specs[2]) -command $command;
	string $uiName = `button -label $label -ann $ann -rs false -w ((int)$specs[1]) -command $command`;
endTrace();
	return {$uiName};
}

//------------------- Button Edit UI---------------------------------------
global proc string acEditButton( string $node, string $control)
{
printTrace( 4, "acEditButton: " + $node);

	string $label = acGetLabel( $node);
	string $ann = acGetAnnotation( $node);
	string $specs[] = acGetSpecs( $node);
	int $hPos = (int)$specs[0];
	int $width = (int)$specs[1];
	string $command = $specs[2];


	string $oldNames[];
	tokenize $specs[3] " " $oldNames;
	string $command = acDecodeExpression( $node, $specs[2], $oldNames);

	setParent $control;
//	string $ctrl = `intFieldGrp -label "Horizontal Position" -numberOfFields 1 -v1 $hPos -cw 2 50`;
//	intFieldGrp -e -cc ("acGetEditValue( \"" + $node + "\", 1, \"intFieldGrp -q -v1 " + $ctrl + "\");") $ctrl;
	string $ctrl = `intFieldGrp -label "Button Width" -numberOfFields 1 -v1 $width -cw 2 50`;
	intFieldGrp -e -cc ("acGetEditValue( \"" + $node + "\", 1, \"intFieldGrp -q -v1 " + $ctrl + "\");") $ctrl;

	separator -style "none" -h 10;
	text -align "left" -label "     Command(s):";

// go up one step for the formLayout - this is not nice
	setParent ..;
	string $ctrl = `scrollField -h 150 -text $command`;
	string $cmd = ("acGetEditValue( \"" + $node + "\", 2, encodeString(\"scrollField -q -text " + $ctrl + "\"));");
	scrollField -e -cc $cmd $ctrl;

// this return causes the Edit Win to attach the scrollField to the top and bottom
endTrace();
	return $ctrl;

}

//------------------- Button Set UI---------------------------------------
global proc acEditButtonUI( string $node)
{
printTrace( 4, "acEditButtonUI: " + $node);

	string $label = acGetLabel( $node);
	string $ann = acGetAnnotation( $node);
	string $specs[] = acGetSpecs( $node);

//--------------------------------------------------------------------
//--------------------------------------------------------------------
//--------------------------------------------------------------------
// hier muessen nun die scripte nach attribut namen durchsucht werden

// die ehemaligen Namen der Attribute
	string $oldNames[];
	tokenize $specs[3] " " $oldNames;
	$specs[3] = "";

// alle connections in ein array laden
	string $c1[] = acGetIndexConnections( $node);

// printn("liste der Connections VOR der ERSTEN Runde (anz = " + size($c1) + ") :");
// if (acDoPrint()) print $c1;
// printn("-----------------------------");

// alle vier commands nach "findConnection" durchsuchen, und die gefundenen indizies in ein zweites array

	// acEncodeExpression subsitutes the "findConnection" calls with the names of the attributes
	$specs[2] = acDecodeExpression( $node, $specs[2], $oldNames);

// alle connections loeschen
	for ( $i=0 ; $i<size($c1) ; $i++ ) acDeletePlug( $node, $i);
		

// --- IMPORTANT!! ONLY those Attribute are found and replaced, which are properly enclosed in Double-Quotes (")

	string $tmp[] = acEncodeExpression( $node, $specs[2]);
	$specs[2] = $tmp[0];
	$specs[3] = $tmp[1];

	acSetSpecs( $node, $specs);


// der String im Fenster bleibt, wie er ist

//--------------------------------------------------------------------
//--------------------------------------------------------------------
//--------------------------------------------------------------------

	string $findCmd = "proc string findConnection( int $index) { return (acFindConnection( \"" + $node + "\", $index)); }\n";
	string $command = $findCmd + $specs[2];

	string $button = acGetUIName( $node);
//	string $uiName = acGetUIName( $node);

//	string $button;
//	{	// find the name of the button's parent, which is a rowLayout
//		string $tmp[] = `rowLayout -q -ca $uiName`;
//		$button = $tmp[0];
//	}

//	rowLayout -e -columnAttach 1 "left" ((int)$specs[1]) $uiName;
	button -e -label $label -ann $ann -w ((int)$specs[1]) -command $command $button;

endTrace();
}




global proc acRebuildTextList( string $node)
{

	string $textList = acGetEditWinName( $node);
	if (`textScrollList -exists	$textList`) {
		string $children[] = acGetNodeChildren( $node);
		string $str;

		textScrollList -e -removeAll $textList;
		for ( $c in $children ) {
			$str = " " + acFixedLengthStr( acGetLabel( $c), 17) + "  ";
			$str += acFixedLengthStr( acGetNodeType( $c), 15) + "  ";
			$str += acFixedLengthStr( $c, 18);
			textScrollList -e -append $str $textList;
		}
	}
}

global proc acNewSelectInTextList( string $node, int $sel[])
{
// printn("Selct in Textlist of node " + $node);
// print $sel;
// printn("----");

	string $textList = acGetEditWinName( $node);
	if (`textScrollList -exists	$textList`) {
		int $count = `textScrollList -q -ni $textList`;
		if ($count) for ( $i in $sel ) textScrollList -e -sii (clamp( 1, $count, $i)) $textList;
	}
}

global proc int[] acIndexList( string $nodes[])
{
	int $list[];
	for ( $n in $nodes ) $list[size($list)] = acGetParentIndex( $n) + 1;
	return $list;
}


//-------------------------------------------------------------------

global proc string[] acDragEditCBButton( string $info[], string $control, int $x, int $y, int $mods)
{
printn("\nacDragEditCBButton CB");
printn("node = " + $info[0] );
printn("control = " + $info[1]);
printn("x = " + $x);
printn("y = " + $y);
printn("mods = " + $mods);

// return ist hier der typ und eine liste der children
	return stringArrayCatenate( {"acEditWin", (string)$mods}, acGetNodesFromTextList( $info[0], $info[1]));
}
global proc string[] acDragEditCB( string $node, string $control, int $x, int $y, int $mods)
{
// printn("\neditWinDrag CB");
// printn("node = " + $node );
// printn("control = " + $control);
// printn("x = " + $x);
// printn("y = " + $y);
// printn("mods = " + $mods);

// return ist hier der typ und eine liste der children
	return stringArrayCatenate( {"acEditWin", (string)$mods}, acGetNodesFromTextList( $node, $control));
}

global proc string[] acDragDirectCB( string $node, string $control, int $x, int $y, int $mods)
{
// printn("\ndirectDrag CB");
// printn("node = " + $node );
// printn("control = " + $control);
// printn("x = " + $x);
// printn("y = " + $y);
// printn("mods = " + $mods);

// return ist hier der typ und eine liste der children
	return {"acDirect", (string)$mods, $node};
}


//-------------------------------------------------------------------

global proc acDropEditCB( string $node, string $dragControl, string $dropControl, string $msgs[], int $x, int $y, int $type)
{

printn("\neditWinDROP CB");
printn("node = " + $node );
printn("dragControl = " + $dragControl);
printn("dropControl = " + $dropControl);
printStrings( $msgs);
printn("x = " + $x);
printn("y = " + $y );
printn("type = " + $type);


// this function is called, if something is dropped INTO an edit window

	string $dragType = $msgs[0];						// the type of DRAG
	string $ch[] = stringArrayRemoveElement( $msgs, 0);
	int $mods = $ch[0];								// the modifier keys
	string $ch[] = stringArrayRemoveElement( $ch, 0);
	string $fromParent = acGetParentNode( $ch[0]);

	string $newParent = $node;
	int $insertIndex = -1;

	if (size($ch) && $fromParent != $newParent) {

		acMoveChildren( $ch, $newParent, $insertIndex);
	
	}
}

global proc acDropFrameListCB( string $node, string $dragControl, string $dropControl, string $msgs[], int $x, int $y, int $type)
{

// this function is called, if something is dropped into the Hierarchy (FrameList) Window
// in this case, NO special rules for Groups, Grids and ColumnLayout are applied

	string $dragType = $msgs[0];						// the type of DRAG
	string $ch[] = stringArrayRemoveElement( $msgs, 0);
	int $mods = $ch[0];								// the modifier keys
	string $ch[] = stringArrayRemoveElement( $ch, 0);

// if the drop entry is an empty parent, then do not indert, but drop INTO the parent
// if the user holds control, then always insert

	string $newParent = acGetParentNode( $node);
	int $insertIndex = acGetParentIndex( $node);

	if ($mods == 2) {		// user holds control
		// always insert
	} else if (acTypeDef( acGetNodeType( $node)) < 5			// this is a parent
				&& !size( acGetNodeChildren( $node))) {				// and is empty

		$newParent = $node;
		$insertIndex = 0;
	}

	if (size($ch) && ($insertIndex != acGetParentIndex($ch[0]) || $newParent != acGetParentNode($ch[0]))) {

		acMoveChildren( $ch, $newParent, $insertIndex);

	}

}


global proc acDropDirectCB( string $node, string $dragControl, string $dropControl, string $msgs[], int $x, int $y, int $type)
{
// this function is called, if something is dropped directly on the UI

// printn("\nacDropDirectCB CB");
// printn("node = " + $node );
// printn("dragControl = " + $dragControl);
// printn("dropControl = " + $dropControl);
// printStrings( $msgs);
// printn("x = " + $x);
// printn("y = " + $y );
// printn("type = " + $type);

	string $dragType = $msgs[0];						// the type of DRAG
	string $ch[] = stringArrayRemoveElement( $msgs, 0);
	int $mods = $ch[0];								// the modifier keys
	string $ch[] = stringArrayRemoveElement( $ch, 0);

	string $newParent = acGetParentNode( $node);
	int $insertIndex = acGetParentIndex( $node);

	// - if the dropNode is an EMPTY group, then the dragNode goes INSIDE that group
	string $nodeType = acGetNodeType( $node);
	if (($nodeType == "Group" || $nodeType == "Grid") && !size(acGetNodeChildren( $node))) {
		$newParent = $node;
		$insertIndex = 0;
	}

	// - if the dropNode is a columnLayout AND the direct child of a tabLayout
	//   then the columnLayout should be the dropParent and the dropIndex should be 0
	if ($nodeType == "ColumnLayout" && acGetNodeType( $newParent) == "TabLayout") {
		$newParent = $node;
		$insertIndex = 0;
	}

	// - if the dropNode is a tabLayout AND it has children AND the current tab is a columnLayout
	//   then the columnLayout should be the dropParent and the dropIndex should be 0
	if ($nodeType == "TabLayout" && !size(acGetNodeChildren( $node))) {
		$activeTabNode = acGetActiveTabChild( $node);
		if (size($activeTabNode) && acGetNodeType( $activeTabNode) == "ColumnLayout") {
			$newParent = $activeTabNode;
			$insertIndex = 0;
		}
	}

	if (size($ch) && ($insertIndex != acGetParentIndex($ch[0]) || $newParent != acGetParentNode($ch[0]))) {

		acMoveChildren( $ch, $newParent, $insertIndex);

	}
}

global proc acMoveChildren( string $children[], string $dropParent, int $dropIndex)
{
//eine node wurde auf sich selbst getragen
// ein parent wurde auf sein child getragen
// printn("this is the NEW moveChildren");
// printn("moving these children:");
// print $children;
// printn("---");
// printn("to node :" + $dropParent + " at index " + $dropIndex);
	string $dragParent = acGetParentNode( $children[0]);
	int $selectInDragEW = acGetParentIndex( $children[0])+1;

	string $delUI[];

// printn("m1");
	for ( $dragNode in $children ) {
		if (!acIsChildOf( $dropParent, $dragNode)
			&& $dropParent != $dragNode) {
	
// printn("m2");
			string $dragUI = acGetUIDeleteName( $dragNode);
			int $dragIndex = acGetParentIndex( $dragNode);

			acRemovePlug( $dragParent, $dragIndex);

			if ($dragParent != $dropParent) $delUI[size($delUI)] = $dragUI;

			if ($dragParent == $dropParent && $dragIndex < $dropIndex) $dropIndex--;
			int $to = acInsertEntryPlug( $dropParent, $dropIndex);
	
			evalEcho( acConnect( $dropParent, $to, ($dragNode + ".message")));
	
			if ($dropIndex > -1) $dropIndex ++;
		} else warning "Cannot drag parent onto one of its children";
	}

	// redraw for the EditWindows

// printn("m3");
	acRebuildTextList( $dropParent);
	acNewSelectInTextList( $dropParent, acIndexList( $children));

	if ($dragParent != $dropParent) {
		acRebuildTextList( $dragParent);
		acNewSelectInTextList( $dragParent, { $selectInDragEW});
	}

// printn("m4");
	// Cleanup and Redraw
	// unfortunately Maya crashes in some drag&drop operations + deleteUI
	// so I am NOT just deleting the UI elements in the dragParent, I better do a redraw
	// --- i'm trying to avoid flickering here (double redraws)
	string $type = acGetNodeType( $dragParent);
	if (`exists ("ac" + $type + "ChildDeleted")`) eval("ac" + $type + "ChildDeleted(\"" + $dragParent + "\", 1, 1)");
	else acChildDeleted( $dragParent, 1, 1);

// printn("m5");
//	if (!acIsChildOf( $dropParent, $dragParent)) 
	evalDeferred( "acRedrawEntry( \"" + $dropParent + "\");");
	if ($dragParent != $dropParent && !acIsChildOf( $dragParent, $dropParent)) {
// printn("m6");
		string $del = acStringArrayToString( $delUI);
		evalDeferred( "deleteUI " + $del);
//		evalDeferred( "acRedrawEntry( \"" + $dragParent + "\");");
		acUpdateOtherViews( $dragParent);
	} else printn("no delete");
// printn("m7");




}






//---------------------------------------------------------------------------------------------
//---------------------acEdit---------------------------------------------------------------
//---------------------------------------------------------------------------------------------

proc acBuildTextListItems( string $node, string $textList)
{
printTrace( 5, "acBuildTextListItems: " + $node);

	string $item[];
	string $child[] = acGetNodeChildren( $node);
	int $listsize = size( $child);
	string $str;

	for ( $i=0 ; $i<$listsize ; $i++ ) {
// 		string $specs[] = acGetSpecs( $child[$i]);
		$str = " " + acFixedLengthStr( acGetLabel( $child[$i]), 17) + "  ";
		$str += acFixedLengthStr( acGetNodeType( $child[$i]), 15) + "  ";
		$str += $child[$i];
//		$str += acFixedLengthStr( $child[$i], 15);
		textScrollList -e -append $str $textList;
	}
endTrace();
}

global proc string acFixedLengthStr( string $text, int $maxLength)
{
// fucking bullshit -maya crashes with these trace calls
// printTrace( 6, "acFixedLengthStr");

	string	$leer = "                                                                                                    ";

	int $s = size( $text);
	if ($s < $maxLength) $text = $text + substring( $leer, $s+1, $maxLength);
	else $text = ".." + substring( $text, $s-$maxLength+3, $s);

// endTrace();

	return $text;
}

global proc acEditEntry( string $node)
{
printTrace( 3, "acEditEntry: " + $node);

// calls the edit function for a specific node type in the for acEdit-type-Entry( $node);

	string $nodeType = acGetNodeType( $node);
	string $cmd = "acEdit" + $nodeType + "Entry( \"" + $node + "\");";
	eval( $cmd);
endTrace();
}

global proc string[] acGetNodesFromTextList( string $node, string $textList)
{
printTrace( 5, "acGetNodesFromTextList: " + $node);

// $textList is a "textScrollList"
// this function queries, which entries in the list are selected and returns
// the children of $node, which correspond

	int $selList[] = `textScrollList -q -sii $textList`;
	string $chList[] = acGetNodeChildren( $node);
	string $selCh[]; int $i = 0;
	for ( $s in $selList ) $selCh[$i++] = $chList[$s-1];
endTrace();
	return $selCh;
}

global proc acSelectInTextList( string $textList, int $sel[])
{
printTrace( 5, "acSelectInTextList: ");

// how Many Items are in textList?
// printn("das ALTE select in textlist");
// printn("selektiert werden sollen");
// print $sel;
// printn("---");
	int $count = `textScrollList -q -ni $textList`;
	if ($count) for ( $i in $sel ) textScrollList -e -sii (clamp( 1, $count, $i)) $textList;
endTrace();
}

global proc acEditMoveUp( string  $node, string $textList)
{
printTrace( 4, "acEditMoveUp: " + $node);

	int $sel[] = `textScrollList -q -sii $textList`;
	string $type = acGetNodeType( $node);
	string $uiName = acGetUIName( $node);

	if (size($sel)>0 && $sel[0]>1) {
		for ( $i=0 ; $i<size($sel) ; $i++ ) {
			acSwapEntries( $node, $sel[$i]-1, $sel[$i]-2);
			if ($type == "TabLayout") tabLayout -e -moveTab ($sel[$i]) ($sel[$i]-1) $uiName;
			$sel[$i]-=1;
		}
		if ($type != "TabLayout") acRedrawEntry( $node);
		textScrollList -e -removeAll $textList;
		acBuildTextListItems( $node, $textList);
		acSelectInTextList( $textList, $sel);
		if ($type == "TabLayout") acGetTab( $node);
	}
endTrace();
}

global proc acEditMoveDown( string  $node, string $textList)
{
printTrace( 4, "acEditMoveDown: " + $node);

	string $child[] = acGetNodeChildren( $node);
	int $sel[] = `textScrollList -q -sii $textList`;
	int $ss = size($sel);
	string $type = acGetNodeType( $node);
	string $uiName = acGetUIName( $node);

// printn("acEditMoveDown");
// printn("size($sel) = " + size($sel) );
// printn("size($child) = " + size($child) );
// if (acDoPrint()) print $sel;

	if ($ss>0 && ($sel[$ss-1]<size($child))) {
		for ( $i=size($sel)-1 ; $i>=0 ; $i-- ) {
			acSwapEntries( $node, $sel[$i], $sel[$i]-1);
			if ($type == "TabLayout") tabLayout -e -moveTab ($sel[$i]+1) ($sel[$i]) $uiName;
			$sel[$i]+=1;
		}
		if ($type != "TabLayout") acRedrawEntry( $node);
		textScrollList -e -removeAll $textList;
		acBuildTextListItems( $node, $textList);
		acSelectInTextList( $textList, $sel);
		if ($type == "TabLayout") acGetTab( $node);
	}
endTrace();
}



global proc acEditChild( string $node, string $textList, string $win)
{
printTrace( 4, "acEditChild: " + $node);

	string $child[] = acGetNodesFromTextList( $node, $textList);
//PROBLEM hier muessen noch die entspr. Typen eingefuegt werden
	for ( $ch in $child ) acEditWin( $ch, ($win=acNewEditWin( $win)), {});

endTrace();
}

global proc acEditDelete( string $node, string $textList)
{
printTrace( 4, "acEditDelete: " + $node);

	string $children[] = acGetNodeChildren( $node);
	int $sel[] = `textScrollList -q -sii $textList`;

	for ( $i in $sel ) acRemoveEntry( $children[$i-1], 1, 1);

// und die Liste neu aufbauen
	textScrollList -e -removeAll $textList;
	acBuildTextListItems( $node, $textList);
	acSelectInTextList( $textList, {$sel[0]});

// und ggf. das Hierarchy Win neu aufbauen
	evalDeferred("acUpdateFLChildren( \"" + $node + "\")");

endTrace();
}

global proc acInsertNew( string $parent, string $textList, string $type)
{
printTrace( 4, "acInsertNew: " + $parent);

	global string $acActiveParent;
	global string $acActiveChild;

	int $index = -1;
	int $selList[] = `textScrollList -q -sii $textList`;
	if (size($selList)) $index = $selList[0]-1;

	string $label = $type;
	string $ann = "";
	string $specs[] = acTypeOptions( $type);

// printn("insert new :" + $type);
// if (acDoPrint()) print $specs;
// printn("-----------------");
 	string $node = acCreateNode( $parent, $index, $type, $label, $ann, $specs);
 	$label = substituteAllString( $node, "_", " ");
 	acSetLabel( $node, $label);

	int $typeDef = acTypeDef( $type);
	if ($typeDef < 5) $acActiveParent = $node;
	else $acActiveChild = $node;

	acSelectInTextList( $textList, {(int)(acGetParentIndex( $node)+1)});
	acRedrawEntry( $parent);

endTrace();
}

global proc acAddInsertMenuItems( string $node, string $textList)
{
printTrace( 5, "acAddInsertMenuItems: " + $node);

// Creates the "Insert>>" popup menu in the edit window
// checks the available types in $acTypes (defined in global proc ac()

	global string $acTypes[];
	int $lastType = -1;

	for ( $i=0 ; $i<size($acTypes) ; $i+=3 ) {
		int $type = (int)$acTypes[$i+1];
		if ($type != 0 && $type != 5) {				// no windows, no attrCTRLs
			if ($lastType > 0 && $type != $lastType) menuItem  -divider true ;
			$lastType = $type;
			menuItem -label $acTypes[$i] -c ("acInsertNew( \"" + $node + "\", \"" + $textList + "\", \"" + $acTypes[$i] + "\");");
		}
	}
endTrace();
}

global proc string acNewEditWin( string $win)
{
printTrace( 5, "acNewEditWin: ");

// 	int $mainW = `window -q -w MayaWindow`;
// 	int $mainH = `window -q -h MayaWindow`;
// 	int $mainX = `window -q -le MayaWindow`;
// 	int $mainY = `window -q -te MayaWindow`;


	int $w = 450;   // problem fix in Qt, window would be too big
	int $h = 430;
	int $x = 426;
	int $y = 300;


// offset a small amount, if an existing windowname was given
// this is the case, if the user hit the "Edit..." button and
// wants to edit children in separate windows
	if (`window -exists $win`) {
		$w = `window -q -w $win`;
		$h = `window -q -h $win`;
		$x = `window -q -le $win`;
		$y = `window -q -te $win`;
		$win = `window -le ($x+10) -te ($y+10) -h $h -rtf true -t ("Edit ")`;
//		$win = `window -le ($x+10) -te ($y+10) -h $h -rtf true -t ("Edit ")`;
	} else {
		$win = `window -le $x -te $y -h $h -rtf true -t ("Edit ")`;
//		$win = `window -le $x -te $y -w $w -h $h -rtf true -t ("Edit ")`;

// reposition the edit Window if there's already one in the default position
// this is to prevent the windows to all pop up in the exact same place
// the "sort" method works in most cases
		string $allWins[] = sort (acGetAllEditWindows());
		for ( $wi in $allWins ) {
			int $a, $b;
			$a = `window -q -le $wi`;
			$b = `window -q -te $wi`;
	
			if ($x == $a && $y == $b) {
				$x += 20;
				$y += 20;
			}
		}
		window -e -le $x -te $y $win;
	}
endTrace();
	return $win;
}

global proc acGetEditValue( string $node, int $specIndex, string $cmd)
{
printTrace( 4, "acGetEditValue: " + $node);

	string $specs[] = acGetSpecs( $node);
//printn("GetEditValue von " + $node + ", Index = " + $specIndex);
	string $value = eval( $cmd);
//printn("Value = " + $value);
	switch ((string)$specIndex) {
		case "-1" :
			acSetLabel( $node, $value);
			break;
		case "-2" :
			acSetAnnotation( $node, $value);
			break;
		default :
			$specs[$specIndex] = $value;
			acSetSpecs( $node, $specs);
			break;
	}


// if the parent is a tabLayout and the UI exists then set the tab label
// this should better be a callback for the specific types, not only for tabLayouts
	string $parent = acGetParentNode( $node);
	if (size($parent)) {
		acSetRedrawStack( $parent );
		if (acGetNodeType( $parent) == "TabLayout") {
			int $index = acGetParentIndex( $node) + 1;
			string $parentUI = acGetUIName( $parent);
			if (`layout -exists $parentUI`) {
				tabLayout -e -tli $index (acGetLabel( $node)) $parentUI;
			} else error( "The UI for TabLayout " + $node + " does not exist!");
		}
	
		// if the parent edit window is open, redraw its list to reflect the label change
		// should also be handled in the callback
		if ($specIndex == 0) acRedrawTextList( $parent);
	} else acSetRedrawStack( $node );

	$cmd = ("acEdit" + acGetNodeType( $node) + "UI");
	if (`exists $cmd`) eval( $cmd + "( \"" + $node + "\");");

	acUpdateFLUILabel( $node);

endTrace();
}

global proc string[] acGetAllEditWindows()
{
printTrace( 5, "acGetAllEditWindows");

	global string $acMasterNode;

	string $editWindows[];
	string $scriptNodes[] = acScriptNodes();
	for ( $s in $scriptNodes ) {
		string $allNodes[] = acGetAllChildren( $s);
		for ($node in $allNodes) {
			string $win = acTopLevelUI( acGetEditWinName( $node));
			string $type = acGetNodeType( $node);
			int $typeDef = acTypeDef( $type);
			if (`window -q -exists $win`) $editWindows[size($editWindows)] = $win;
		}
	}
endTrace();
	return $editWindows;
}

global proc acShowEditWin( string $node)
{
printTrace( 5, "acShowEditWin: " + $node);

//printn("--this is acShowEditWin");
	string $type = acGetNodeType( $node);
	int $typeDef = acTypeDef( $type);
	string $win= acTopLevelUI( acGetEditWinName( $node));
//printn("windowName = >" + $win + "<");
	if (size($win) && `window -exists $win`) {
		showWindow $win;
	}
endTrace();
}

global proc acDeleteEditWin( string $node)
{
printTrace( 5, "acDeleteEditWin: " + $node);

//printn("--this is acDeleteEditWin");
	string $type = acGetNodeType( $node);
	int $typeDef = acTypeDef( $type);
	string $win= acTopLevelUI( acGetEditWinName( $node));
	if (size($win) && `window -exists $win`) {
		deleteUI $win;
	}
endTrace();
}

global proc acCheckEditWinName( string $node)
{
printTrace( 5, "acCheckEditWinName: " + $node);

// cleanup EditWindow Name (e.g. after an undo it might have a value, but the window is gone)
	if (!`window -exists (acTopLevelUI( acGetEditWinName( $node)))`) acSetEditWinName( $node, "");
endTrace();
}

global proc acRedrawTextList( string $node)
{
printTrace( 5, "acRedrawTextList: " + $node);

// printn("--this is acRedrawTextList -- node = >" + $node + "<");
	string $textList = acGetEditWinName( $node);
	if (size($textList) && `textScrollList -exists $textList`) {
		int $sel[] = `textScrollList -q -sii $textList`;
// printn("VOR dem Zeichen selektiert:");
// print $sel;
// printn("----");
if (!size($sel)) $sel[0] = 1;
		int $ni = `textScrollList -q -ni $textList`;
		textScrollList -e -removeAll $textList;
		acBuildTextListItems( $node, $textList);
// printn("size vorher = " + $ni);
// printn("size der neuen liste = " + `textScrollList -q -ni $textList`);

		//if ($ni == `textScrollList -q -ni $textList`) 
		acSelectInTextList( $textList, $sel);
	}
endTrace();
}


global proc string acEditWin( string $node, string $win, int $select[])
{
printTrace( 2, "acEditWin: " + $node);


	string $label = acGetLabel( $node);
	string $annotation = acGetAnnotation( $node);
	string $specs[] = acGetSpecs( $node);
	string $type = acGetNodeType( $node);
	int $typeDef = acTypeDef( $type);
	string $parent = acGetParentNode( $node);

	string $list[] = acGetNodeChildren( $node);
	int	$listSize = size( $list);


 // printn("--this is acEditWin");


	string $editWin = acTopLevelUI( acGetEditWinName( $node));
	if (size($editWin) && `window -q -exists $editWin`) {
		print( "Attribute Collection: The Edit Window for " + $node + " is already open.\n");
		acShowEditWin( $node);
endTrace();
		return $editWin;
	} acSetEditWinName( $node, "");

	if (`window -q -exists $win`) {
		// save the window's position and size - then delete it
		//   (this also clears the previous owner's editUIName and kills the scriptJob)
		int $xy[] = `window -q -tlc $win`;
		int $wh[] = `window -q -wh $win`;
		deleteUI -window $win;

		// Create a new window - this will flicker a bit - but this is the easiest way with the scriptJob
		$win = `window -h ($wh[1]) -tlc ($xy[0]) ($xy[1]) -rtf true`;
//		$win = `window -wh ($wh[0]) ($wh[1]) -tlc ($xy[0]) ($xy[1]) -rtf true`;
		if (`windowPref -exists $win`) windowPref -r $win;
//		window -e -wh ($wh[0]) ($wh[1]) $win;
		window -e -tlc ($xy[0]) ($xy[1]) $win;
		scriptJob -kws -cu true -uiDeleted $win ("acSetEditWinName( \"" + $node + "\", \"\")");
	}
	window -e -t ("Edit " + $node) $win;


	$form = `formLayout -numberOfDivisions 100`;

		$colName = `columnLayout -adj true`;
			separator -h 10 -style "none";

//-----------The first row in the editWin-------------------
 			$row = `rowLayout -nc 5
					-columnAttach5 "both" "both" "both" "both" "both"
					-columnAlign5 "right" "left" "left" "right" "left"
					-columnWidth5 70 70 70 30 70
					-adjustableColumn5 5`;
					
				text -align "right" -label ("This is a ");
				text -align "left" -label ($type + ".   ") -font "boldLabelFont";

		// on windows create an orange button, all others are grey
				string $pb, $t3, $t4;
				if (`about -nt`) $pb = `button -w 80 -label "Parent" -bgc .9 .7 0 -en (size($parent)) -c ("acEditWin( acGetParentNode(\"" + $node + "\"), \"" + $win + "\", {acGetParentIndex(\"" + $node + "\")+1});")`;
				else $pb = `button -w 80 -label "Parent" -en (size($parent)) -c ("acEditWin( acGetParentNode(\"" + $node + "\"), \"" + $win + "\", {acGetParentIndex(\"" + $node + "\")+1});")`;

				if (size($parent)) {
					text -align "right" -label (" is a ");
					text -align "left" -label (acGetNodeType( $parent)) -font "boldLabelFont";
				}

//-----------end of the first row in the editWin-------------------

			setParent $colName;
			separator -style "none" -h 10;
			$text = `textFieldGrp -label "Label" -text $label`;
			textFieldGrp -e -cc ("acGetEditValue( \"" + $node + "\", -1, \"textFieldGrp -q -text " + $text + "\");") $text;

			if (acGetOpt( "acPrefAnnotation", 1)) {
				$ann = `textFieldGrp -label "Annotation" -text $annotation`;
				textFieldGrp -e -cc ("acGetEditValue( \"" + $node + "\", -2, \"textFieldGrp -q -text " + $ann + "\");") $ann;
			}

			separator -style "none" -h 10;

			setParent $colName;

// the following "extras" may be created by the "acEdit-type-" function of the different types
// the "acEdit-type-" function first draws input fields for the options
//   if nessessary it will then do a "setParent.." (go up to the formLayout) and draw a list or a scrollField for text input
//   if there is an "extra" returned, it will be attached to $colName (top) and to the buttons (children entries only, parent entries have the children list at the bottom)

			string $extra;
			if (`exists ("acEdit" + $type)`) $extra = eval( "acEdit" + $type + "( \"" + $node + "\", \"" + $colName + "\")");

			if (!size($extra)) separator -style "in" -h 20;

		string $pane, $textList, $bmup, $bmdn, $bedt, $bdel, $bcls, $bins, $upButton;

		if ($typeDef >= 5) {

			// these are buttons for a CHILD Control (no List)

			setParent $form;

		// on windows create an orange button, all others are grey
			if (`about -nt`) $upButton = `button -bgc .9 .7 0 -en (size($parent)) -l "Up" -w 30 -c ("acEditWin( \"" + $parent + "\", \"" + $win + "\", {acGetParentIndex(\"" + $node + "\")+1});")`;
			else $upButton = `button -en (size($parent)) -l "Up" -w 30 -c ("acEditWin( \"" + $parent + "\", \"" + $win + "\", {acGetParentIndex(\"" + $node + "\")+1});")`;

			$bcls = `button -l "Close" -c ("deleteUI " + $win) `;

			formLayout -edit
				-attachForm		$colName	"top"	5
				-attachForm		$colName	"left"	5
				-attachForm		$colName	"right"	5
				-attachNone		$colName	"bottom"

				-attachPosition	$upButton	"left" 2 80
				-attachForm		$upButton 	"bottom" 5
				-attachForm		$upButton 	"right"	5
				-attachNone		$upButton 	"top"
	
				-attachForm		$bcls	"left"	5
				-attachForm		$bcls 	"bottom"	5
				-attachPosition	$bcls 	"right"	2 80
				-attachNone		$bcls 	"top"
			$form;
	
			if (size($extra)) {
				formLayout -edit
					-attachControl	$extra	"top"	5 $colName
					-attachForm		$extra	"left"	5
					-attachForm		$extra	"right"	5
					-attachControl	$extra	"bottom" 5 $bcls
				$form;
			}

			// for leaf entries the name of the edit window is simply the name of the window
			acSetEditWinName( $node, $win);

		} else {
			// this is a parent node
			// the list of children with the labels above

			setParent $colName;
			text -label "  Label              Type             Node Name" -align "left" -font "smallFixedWidthFont";

			// the list of the Children of this Node

			setParent $form;
			// $pane = `paneLayout`;
				string $textList = `textScrollList
									-font "smallFixedWidthFont"
									-numberOfRows (max( 1, $listSize))
									-allowMultiSelection true
									-dragCallback ("acDragEditCB \"" + $node + "\"")
									-dropCallback ("acDropEditCB \"" + $node + "\"")`;
// 									-dragCallback ("acDragCB \"" + $node + "\"")
// 									-dropCallback ("acDropCB \"" + $node + "\"")`;
				acBuildTextListItems( $node, $textList);
				if (size($select)) acSelectInTextList( $textList, $select);
				else if ($listSize > 0) textScrollList -e -sii 1 $textList;
//				textScrollList -e -dcc ("string $acCh[] = acGetNodesFromTextList( \"" + $node + "\",\"" + $textList + "\");acEditWin( $acCh[0], \"" + $win + "\", {});print(\"DCC Cmd is FINISHED\\n\");") $textList;
				textScrollList -e -dcc ("evalDeferred( \"string $acCh[] = acGetNodesFromTextList( \\\"" + $node + "\\\",\\\"" + $textList + "\\\");acEditWin( $acCh[0], \\\"" + $win + "\\\", {})\");") $textList;
				textScrollList -e -dkc ("acEditDelete( \"" + $node + "\", \"" + $textList + "\");") $textList;

			$dragDropBtn = `button -l "Drag Selected Items with MMB from here" -dragCallback ("acDragEditCBButton {\"" + $node + "\",\"" + $textList + "\"}")`;

			setParent $form;
			$bmup = `button -l "Move Up" -c ("acEditMoveUp( \"" + $node + "\", \"" + $textList + "\");")`;
			$bmdn = `button -l "Move Down" -c ("acEditMoveDown( \"" + $node + "\", \"" + $textList + "\");")`;
			$bedt = `button -l "Edit..." -c ("acEditChild( \"" + $node + "\", \"" + $textList + "\", \"" + $win + "\");")`;
			$bdel = `button -l "Delete" -c ("acEditDelete( \"" + $node + "\", \"" + $textList + "\");")`;
			$bcls = `button -l "Close" -c ("deleteUI " + $win) `;


			$bins = `button -l "Insert..."`;
			    popupMenu -button 1;
				acAddInsertMenuItems( $node, $textList);

			formLayout -edit

				-attachControl	$textList	"top"	5 $colName
				-attachForm		$textList	"left"	5
				-attachForm		$textList	"right"	5
				-attachControl	$textList	"bottom" 5 $dragDropBtn

				-attachNone		$dragDropBtn	"top"
				-attachForm		$dragDropBtn	"left"	5
				-attachPosition	$dragDropBtn 	"right"	2 50
				-attachControl	$dragDropBtn	"bottom" 5 $bedt

				-attachForm		$bins 	"left"	5
				-attachForm		$bins 	"bottom"	5
				-attachPosition	$bins 	"right"	2 33
				-attachNone		$bins 	"top"

				-attachForm		$bedt 	"left"	5
				-attachControl	$bedt 	"bottom" 5 $bins
				-attachPosition	$bedt 	"right"	2 33
				-attachNone		$bedt 	"top"

				-attachPosition	$bmdn		"left" 2 33
				-attachForm		$bmdn		"bottom"	5
				-attachPosition	$bmdn		"right"	2 66
				-attachNone		$bmdn		"top"

				-attachPosition	$bmup		"left" 2 33
				-attachControl	$bmup		"bottom" 5 $bmdn
				-attachPosition	$bmup		"right"	2 66
				-attachNone		$bmup		"top"

				-attachPosition	$bcls		"left" 2 66
				-attachForm		$bcls		"bottom"	5
				-attachForm		$bcls		"right"	5
				-attachNone		$bcls		"top"

				-attachPosition	$bdel		"left" 2 66
				-attachControl	$bdel		"bottom" 5 $bcls
				-attachForm		$bdel		"right"	5
				-attachNone		$bdel		"top"
			$form;

			// for controls the name of the edit window will be the name of the textList (for easier update)
			acSetEditWinName( $node, $textList);
		}





	showWindow;
endTrace();
	return $colName;

}





global proc acExportAll()
{
	global string $acMasterNode;
	global string $acActiveParent;

	string $parent = $acMasterNode;
	print("\n//--------------------------------------------------------\n");
	print("// Execute these commands to create the same UI in another Scene\n");
	print("//   (Object Names count!!)\n");
	print("//--------------------------------------------------------\n");
	print( "source ac.mel;\n");
	print( "string $parent = acCreateMainNode();\n");
	acPrintNode( $acMasterNode);
	print( "ac;\n");

}

global proc acExport( string $node)
{
	print("\n//--------------------------------------------------------\n");
	print("// Execute these commands to create the same UI in another Scene\n");
	print("//   (Object Names count!!)\n");
	print("//--------------------------------------------------------\n");
	print("   string $parent = \"INSERT A VALID PARENT NODE HERE\";\n");
	print("//--------------------------------------------------------\n");
	acPrintNode( $node);
}


global proc acPrintNode( string $node)
{
	global string $acMasterNode;

	if ($node != $acMasterNode) {
		string $type = acGetNodeType( $node);
		string $label = acGetLabel( $node);
		string $ann = acGetAnnotation( $node);
		string $specs[] = acGetSpecs( $node);
//		string $parent = acGetParentNode( $node);

		string $cmd = "$parent = acCreateNode( $parent , -1, \"" + $type + "\", ";
		$cmd += "\"" + encodeString( $label) + "\", ";
		$cmd += "\"" + encodeString( $ann) + "\", { ";
		for ( $i=0 ; $i<size($specs) ; $i++ ) {
			$cmd += "\"" + encodeString( $specs[$i]) + "\"";
			if ($i<size($specs)-1) $cmd +=  ", ";
		}
		print( $cmd + "} );\n");
		if (acTypeDef( $type) > 4) {
			string $c[] = acGetIndexConnections( $node);
			for ( $i=0 ; $i<size($c) ; $i++ ) print( "acConnect( $parent, " + $i + ", \"" + $c[$i] + "\");\n");
		}
	}
	string $ch[] = acGetNodeChildren( $node);
	for ( $c in $ch ) acPrintNode( $c);
	print( "$parent = acGetParentNode( $parent);\n");
}









global proc acFLWin( string $node)
{
	if (`objExists $node`) {
		string $winName = ($node + "HWin");
		if (!`window -exists $winName`) {
			window -w 410 -h 500 -title ("Hierarchy View of \"" + $node + "\"") $winName;
			scrollLayout -cr true -mcw 400;
			$col = `columnLayout -adj 1`;
			$acFLMain = acFrameListChildren( $node, $col);
			window -e -w 420 $winName;
			window -e -w 430 $winName;
		}
		showWindow $winName;
	}
}


global proc string acFrameListChildren( string $node, string $parentLayout)
{
	global string $acFLNames[];

// printn(" acFrameListChildren: node = " + $node);
	string $type = acGetNodeType( $node);
	int $typeDef = acTypeDef( $type);
	string $label = acGetLabel( $node);
	string $children[] = `acGetNodeChildren( $node)`;
//	string $font = "boldLabelFont";
	string $font = "smallFixedWidthFont";
	string $fr;
	setParent $parentLayout;
	string $text = (acFixedLengthStr( $label, 20) + "  (" + $type + ") -- " + $node);
	if ($typeDef > 4) {
		$fr = `text -font $font -align "left" -label ($text)`;
		text -e -dragCallback ("acDragDirectCB \"" + $node + "\"")
				-dropCallback ("acDropFrameListCB \"" + $node + "\"") $fr;
	} else {
		string $uiName;
		if ($typeDef == 0) $fr = `frameLayout -label ($text) -font $font -borderStyle "etchedIn" -cll 1 -cl 0 ($node + "FLMain")`;
		else $fr = `frameLayout -label ($text)
								-font $font
								-borderStyle "etchedIn"
								-cll 1
								-cl 0`;
		frameLayout -e -dragCallback ("acDragDirectCB \"" + $node + "\"")
				-dropCallback ("acDropFrameListCB \"" + $node + "\"") $fr;

		acSetNodeData( $node, $fr, $acFLNames);

		string $chCol = `columnLayout -adj 1 -columnOffset "left" (20)`;
		columnLayout -e -dragCallback ("acDragDirectCB \"" + $node + "\"")
				-dropCallback ("acDropFrameListCB \"" + $node + "\"") $chCol;
		for ( $ch in $children ) acFrameListChildren( $ch, $chCol);
		setParent $chCol;
		separator -style "none" -h 10;
	}
	acAddRMBPopup( $node, $fr);


	return $fr;
}

global proc string acFindFLUI( string $node)
{
	global string $acFLNames[];
	return acGetNodeData( $node, $acFLNames);

// // printn("acFindFLUI von: " + $node);
// 	int $index[];
// 	string $parent = acGetParentNode( $node);
// 	string $scriptNode;
// 	while(size($node)) {
// 		$parent = acGetParentNode( $node);
// 		if (size($parent)) $index[size($index)] = acGetParentIndex( $node);
// 		if (acTypeDef( acGetNodeType( $node)) == 0) $scriptNode = $node;
// 		$node = $parent;
// 	}
// // printn("index:");
// // print $index;
// 	$current = $scriptNode + "FLMain";
// 	if (`frameLayout -exists $current`) {
// 		for ( $i=size($index)-1 ; $i>=0 ; $i-- ) {
// 			string $chUI[] = acFLUIChildren( $current);
// 			$current = $chUI[$index[$i]];
// 		}
// 		return $current;
// 	} else return "";
}

global proc string[] acFLUIChildren( string $frame)
{
// printn("acFLUIChildren von: " + $frame);
	string $chUI[] = `frameLayout -q -ca $frame`;		// das formLayout
	$chUI = `columnLayout -q -ca $chUI[0]`;				// children of the first columnLayout
// printStrings( $chUI);
	return $chUI;
}

global proc acUpdateFLChildren( string $node)
{
// printn("updateFLChildren: node = >" + $node + "<");
	string $frame = acFindFLUI( $node);
	if (size($frame) && `frameLayout -exists $frame` && `objectTypeUI -isType "frameLayout" $frame`) {

//-------------------------------------------
// find collapse status of all children
		string $children[] = acGetAllChildren( $node);
		string $pCh[];		// layouts
		int $pCs[];			// collapse status
		for ( $ch in $children ) {
			if (acTypeDef( acGetNodeType( $ch)) < 5) {
				$pCh[size($pCh)] = $ch;
				$fr = acFindFLUI( $ch);
				if (`frameLayout -exists $fr`) $pCs[size($pCs)] = `frameLayout -q -cl $fr`;
				else $pCs[size($pCs)] = 0;
			}
		}


//-------------------------------------------
//printn("updateFLChildren: frame = >" + $frame + "<");
		string $chUI[] = `frameLayout -q -ca $frame`;		// das formLayout
		string $col = $chUI[0];
		$chUI = acFLUIChildren( $frame);
		frameLayout -e -vis 0 $frame;
		if (size($chUI)) deleteUI $chUI;
		string $children[] = `acGetNodeChildren( $node)`;
		for ( $ch in $children ) acFrameListChildren( $ch, $col);
		setParent $col;
		separator -style "none" -h 10;

// now set the stored collapse status for all children
		for ( $i=0 ; $i<size($pCh); $i++ ) frameLayout -e -cl ($pCs[$i]) (acFindFLUI( $pCh[$i]));

		frameLayout -e -vis 1 $frame;
	}

}

global proc acUpdateFLUILabel( string $node)
{
	string $uiName = acFindFLUI( $node);
	if (size($uiName)) {
		string $type = acGetNodeType( $node);
		int $typeDef = acTypeDef( $type);
		string $label = acGetLabel( $node);
		string $text = (acFixedLengthStr( $label, 20) + "  (" + $type + ") -- " + $node);
		if ($typeDef > 4) text -e -label ($text) $uiName;
		else frameLayout -e -label ($text) $uiName;
	}
}






global proc acGridChildDeleted( string $node, int $cleanup, int $deleteUI)
{
// this function is called, if one of the Grid's children was just deleted
// it was thought to redraw the gridLAyout, but this may cause Maya to crash
// 	if ($deleteUI) evalDeferred( "acRedrawEntry( \"" + $node + "\");");
}


//------------------ CREATE Grid------------------------------
global proc string acCreateGridEntry( string $parentNode, int $index, string $label, int $cellWidth, int $cellHeight, int $constrainWidth, int $numberOfColumns)
{
// specs are:
// - label
// - cell width
// - cell height
// - constrain width to the width of the sliders
// - number of Columns

global string	$acActiveParent;

	string $ann;
	string $node = acCreateNode( $parentNode, $index, "Grid", $label, $ann, {(string)$cellWidth, (string)$cellHeight, (string)$constrainWidth, (string)$numberOfColumns});
	$acActiveParent = $node;
	return $node;
}


//-----------------Draw Grid ------------------------------------

global proc string[] acDrawGridEntry( string $node)
{
	int	$labelSize = max( 1, acGetOpt( "acPrefLabelSize", 140));
	int	$fieldSize = max( 1, acGetOpt( "acPrefFieldSize", 80));
	int	$sliderSize = max( 1, acGetOpt( "acPrefSliderSize", 160)
				* acGetOpt( "acPrefEnableSliders", 1));
	int	$totalSize = $labelSize + $fieldSize + $sliderSize;

	string $ann = acGetAnnotation( $node);
	string $specs[] = acGetSpecs( $node);
	int $x = (int)$specs[0];
	int $y = (int)$specs[1];
	int $constrainWidth = (int)$specs[2];
	int $gridWidth = (int)$specs[3];

	string $gridLayout;
	if ($constrainWidth) {
		int $nc = $totalSize / $x;
		$gridLayout = `gridLayout -ann $ann
								  -nc $nc
								  -cwh $x $y
								  -cr true
								  -w $totalSize
								  -nr 1
								  `;
	} else {
		$gridLayout = `gridLayout -ann $ann
								  -nc $gridWidth
								  -cw $x
								  -ch $y
								  -cr true
								  -w ($gridWidth * $x)
//								  -nr 1
								  `;
	}
	return {$gridLayout};
}

//------------------- grid Edit UI---------------------------------------
global proc acEditGrid( string $node, string $control)
{
	string $specs[] = acGetSpecs( $node);
	int $x = (int)$specs[0];
	int $y = (int)$specs[1];
	int $constrainWidth = (int)$specs[2];
	int $gridWidth = (int)$specs[3];

	setParent $control;
	$ctrl = `intFieldGrp -label "Cell Size X/Y" -numberOfFields 2 -v1 $x -v2 $y -cw 2 50 -cw 3 50`;
	separator -h 10 -style "none";
	$cw = `checkBoxGrp -label "Constrain Width" -l1 "to Slider Width" -ncb 1 -v1 $constrainWidth`;
	$hgs = `intFieldGrp -en (!$constrainWidth) -label "Horizontal Grid Size" -numberOfFields 1 -v1 $gridWidth -cw 2 50`;

	intFieldGrp -e -cc ("acGetEditValue( \"" + $node + "\", 0, \"intFieldGrp -q -v1 " + $ctrl + "\");acGetEditValue( \"" + $node + "\", 1, \"intFieldGrp -q -v2 " + $ctrl + "\");") $ctrl;
	checkBoxGrp -e -cc ("acGetEditValue( \"" + $node + "\", 2, \"checkBoxGrp -q -v1 " + $cw + "\");intFieldGrp -e -en (!`checkBoxGrp -q -v1 " + $cw + "`) " + $hgs + ";") $cw;
	intFieldGrp -e -cc ("acGetEditValue( \"" + $node + "\", 3, \"intFieldGrp -q -v1 " + $hgs + "\");") $hgs;

}

//------------------- grid Set UI---------------------------------------
global proc acEditGridUI( string $node)
{
// printn("Grid Set UI");
	int	$labelSize = max( 1, acGetOpt( "acPrefLabelSize", 140));
	int	$fieldSize = max( 1, acGetOpt( "acPrefFieldSize", 80));
	int	$sliderSize = max( 1, acGetOpt( "acPrefSliderSize", 160)
				* acGetOpt( "acPrefEnableSliders", 1));
	int	$totalSize = $labelSize + $fieldSize + $sliderSize;

	string $ann = acGetAnnotation( $node);
	string $specs[] = acGetSpecs( $node);
	string $uiName = acGetUIName( $node);
	int $x = (int)$specs[0];
	int $y = (int)$specs[1];
	int $constrainWidth = (int)$specs[2];
	int $gridWidth = (int)$specs[3];

	if ($constrainWidth) {
		int $nch = size(`gridLayout -q -ca $uiName`);
		int $nc = max( 1, $totalSize / $x);
		int $nr = $nch / $nc + 1;
		gridLayout -e -ann $ann
					  -nc $nc
					  -cw $x
					  -ch $y
					  -cr true
					  -w $totalSize
					  -nr $nr
					   $uiName;
	} else {
		gridLayout -e -ann $ann
					  -nc $gridWidth
					  -cw $x
					  -ch $y
					  -cr true
					  -w ($gridWidth * $x)
					  $uiName;
	}
}


//----------------------------------------------------------------------

global proc acCollapseGroup( string $node)
{
	string $specs[] = acGetSpecs( $node);
	$specs[0] = "1";
	acSetSpecs( $node, $specs);
}

global proc acUncollapseGroup( string $node)
{
// this sets the group to "not collapsed"
	string $specs[] = acGetSpecs( $node);
	$specs[0] = "0";
	acSetSpecs( $node, $specs);
}





//---------------------- CREATE GROUP-----------------------
global proc string acCreateGroupEntry( string $parentNode, int $index, string $label)
{
// specs are:
// - label
// - is collapsed
// - display buttons: 0=invisible; 1=all (use prefs);
// - Border Style

global string	$acActiveParent;
global string	$acActiveGroup;

	string $ann;

	string $node = acCreateNode( $parentNode, $index, "Group", $label, $ann, {"0", "1", "etchedIn"});

	// set a different label for the new group
	$label = substituteAllString( $node, "_", " ");
	acSetLabel( $node, $label);

	$acActiveParent = $acActiveGroup = $node;
	return $node;
}

//-----------------Draw Group ------------------------------------

global proc string[] acDrawGroupEntry( string $node)
{

	int	$labelSize = acGetOpt( "acPrefLabelSize", 140);
	int	$fieldSize = acGetOpt( "acPrefFieldSize", 80);
	int	$sliderSize = acGetOpt( "acPrefSliderSize", 160)
				* acGetOpt( "acPrefEnableSliders", 1);
	if ($sliderSize < 1) $sliderSize = 1;
	int $totalWidth = $labelSize + $fieldSize + $sliderSize;

// PROBLEM: the returned UI is not the main UI
// if I wanted to delete a groupLayout then I had to delete the parent of the stored layout

	string $label = acGetLabel( $node);
	string $ann = acGetAnnotation( $node);
	string $specs[] = acGetSpecs( $node);
	string $groupFrameLayout = `frameLayout -ann $ann
				-label $label
				-collapse ((int)$specs[0])
				-collapsable true
				-borderStyle "etchedIn"`;
	frameLayout -e -preExpandCommand ("acUncollapseGroup( \"" + $node + "\")") $groupFrameLayout;
	frameLayout -e -preCollapseCommand ("acCollapseGroup( \"" + $node + "\")") $groupFrameLayout;


// this first columnLayout contains:
// - a columnLayout for the enties
// - the groupButtons

	string $buttonLayout = `columnLayout -adj 1`;

// and this is the columnLayout for the entries

	string $groupLayout = `columnLayout -adj true`;
//	string $groupLayout = `columnLayout -w $totalWidth`;

	setParent ..;
	acMakeGroupButtons( $node);

//	int $w = `frameLayout -q -w $groupFrameLayout`;
//	frameLayout -e -lw ($w-30) $groupFrameLayout;
//	frameLayout -e -label $specs[0] $groupFrameLayout;

	acAddRMBPopup( $node, $groupFrameLayout);
	acAddRMBPopup( $node, $buttonLayout);

	return {$groupLayout, $buttonLayout, $groupFrameLayout};
}

//-----------------Draw Group Buttons ------------------------------------

global proc acMakeGroupButtons( string $node)
{
	string $specs[] = acGetSpecs( $node);
	int	$labelSize = acGetOpt( "acPrefLabelSize", 140);
	int	$fieldSize = acGetOpt( "acPrefFieldSize", 80);
	int	$sliderSize = acGetOpt( "acPrefSliderSize", 160)
				* acGetOpt( "acPrefEnableSliders", 1);
	if ($sliderSize < 1) $sliderSize = 1;
	int $textureButton = acGetOpt( "acPrefEnableColorButtons", 0);


	int	$b1 = acGetOpt( "acPrefSetKBtn", 1);
	int	$b2 = acGetOpt( "acPrefDelKBtn", 1);
	int	$b3 = acGetOpt( "acPrefBreakCBtn", 1);
	int	$b4 = acGetOpt( "acPrefSelectBtn", 1);
	int	$b5 = acGetOpt( "acPrefEditBtn", 1) * (!acIsLocked( $node));
	int	$b6 = acGetOpt( "acPrefDeleteBtn", 1) * (!acIsLocked( $node));


	int	$bAnz = $b1 + $b2 + $b3 + $b4 + $b5 + $b6;


	string	$bLabels[];


    if ($bAnz) {
		int	$bs = ($labelSize + $fieldSize + $sliderSize + (30 * $textureButton)) / $bAnz;
		$bLabels = { "Set Key", "Del Key", "Brk Conn", "Select", "Edit...", "Delete"};
		if ($bs < 61) $bLabels = { "SetK", "DelK", "BrkC", "Sel", "Ed..", "Del"};
		if ($bs < 33) $bLabels = { "SK", "DK", "BC", "S", "Ed.", "Del"};
		if ($bs < 25) $bLabels = { "K", "D", "B", "S", "E.", "D"};
	
	
		string	$cmd = "rowLayout -vis " + ((int)$specs[1]) + " -h 22 -numberOfColumns " + $bAnz + " ";
	
	
		for ( $i = 1 ; $i <= $bAnz ; $i++ ) {
			$cmd += (" -columnWidth " + $i + " " + $bs);
			$cmd += (" -columnAttach " + $i + " \"left\" 3");
			$cmd += (" -rowAttach " + $i + " \"bottom\" 1");
		}
		separator -vis ((int)$specs[1]) -style "none" -h 5;
		eval( $cmd);

	
		if ($b1) button -w $bs -h 22 -al "center" -l $bLabels[0] -c ("acGroupSetKey( \"" + $node + "\")") -ann "Set a Key for the Channels in this Group";
		if ($b2) button -w $bs -h 22 -al "center" -l $bLabels[1] -c ("acGroupDeleteKey( \"" + $node + "\")") -ann "Delete the Key from Channels in this Group";
		if ($b3) button -w $bs -h 22 -al "center" -l $bLabels[2] -c ("acGroupBreakConnections( \"" + $node + "\")") -ann "Breaks the connections (Keys, Expressions) for Channels in this Group";
		if ($b4) button -w $bs -h 22 -al "center" -l $bLabels[3] -c ("acGroupSelect( \"" + $node + "\")") -ann "Select the Objects (to see Keyframes in the Timeline)";
		if ($b5) button -w $bs -h 22 -al "center" -l $bLabels[4] -c ("acEditWin( \"" + $node + "\", acNewEditWin(\"\"), {});") -ann "Edit this Group";
		if ($b6) button -w $bs -h 22 -al "center" -l $bLabels[5] -c ("acDeleteEntry( \"" + $node + "\", 1, 1);") -ann "Delete this Group";
	}
}

// ----------------------Set Drag&Drop Callback------------------------------------------
global proc acGroupDDCallback( string $node)
{
	string $uiName = acGetUIName( $node);
	setParent $uiName;
	setParent ..;
	setParent ..;
	$uiName = `setParent -q`;
	layout -e -dragCallback ("acDragDirectCB \"" + $node + "\"")
			  -dropCallback ("acDropDirectCB \"" + $node + "\"") ($uiName );
}


//--------------------------SetKey---------------------------------
global proc acGroupSetKey( string $node)
{
	string $children[] = acGetAllChildren( $node);
	string $allAttribs[];
	for ( $ch in $children ) {
		int $typeDef = acTypeDef( acGetNodeType( $ch));
		if ($typeDef == 5 || $typeDef == 6) $allAttribs = stringArrayCatenate( $allAttribs, (acGetAllConnections( $ch)));
	}
	$allAttribs = stringArrayRemoveDuplicates( $allAttribs);
	for ( $a in $allAttribs ) {
		setKeyframe $a;
		print( "setKeyframe " + $a + ";\n");
	}
}


//--------------------------DeleteKey---------------------------------
global proc acGroupDeleteKey( string $node)
{
	string $children[] = acGetAllChildren( $node);
	float $t = `currentTime -q`;
	for ( $ch in $children ) {
		string $type = acGetNodeType( $ch);
		int $typeDef = acTypeDef( $type);
		if (($typeDef == 5 || $typeDef == 6) && size(acGetAllConnections( $ch))) cutKey -time ($t + ":" + ($t + 0.99)) -option keys (acGetAllConnections( $ch));
	}
}


//--------------------------BrkConnections---------------------------------
global proc acGroupBreakConnections( string $node)
{
	string $children[] = acGetAllChildren( $node);
	for ( $ch in $children ) {
		string $type = acGetNodeType( $ch);
		int $typeDef = acTypeDef( $type);
		if (($typeDef == 5 || $typeDef == 6) && size(acGetAllConnections( $ch))) delete -icn (acGetAllConnections( $ch));
	}
}


//--------------------------Select---------------------------------
global proc acGroupSelect( string $node)
{
	string $children[] = acGetAllChildren( $node);
	select -cl;
	for ( $ch in $children ) {
		string $type = acGetNodeType( $ch);
		int $typeDef = acTypeDef( $type);
		if ($typeDef == 5 || $typeDef == 6) {
			string $attrs[] = acGetAllConnections( $ch);
			for ( $at in $attrs ) {
				string $tmp[];
				tokenize $at "." $tmp;
				select -add $tmp[0];
			}
		}
	}
}

//-----------------------------------------------------------------------
//-----------------------------------------------------------------------



global proc acEditGroup( string $node, string $control)
{
	string $specs[] = acGetSpecs( $node);

	string $cb = `checkBoxGrp -ncb 1 -label "Show Buttons" -v1 ((int)$specs[1])`;
	checkBoxGrp -e -cc ("acGetEditValue( \"" + $node + "\", 1, \"checkBoxGrp -q -v1 " + $cb + "\");") $cb;

	string $style = `optionMenuGrp -label "Border Style" -columnAlign 1 "right"`;
		menuItem -label "in";
		menuItem -label "out";
		menuItem -label "etchedIn";
		menuItem -label "etchedOut";
	optionMenuGrp -e -v $specs[2] $style;
	optionMenuGrp -e -cc ("acGetEditValue( \"" + $node + "\", 2, \"optionMenuGrp -q -v " + $style + "\");") $style;
}

//--------------Set Group UI (from EditWin)------------------------
global proc acEditGroupUI( string $node)
{
	string $label = acGetLabel( $node);
	string $ann = acGetAnnotation( $node);
	string $specs[] = acGetSpecs( $node);
	string $uiName = acGetUIName( $node);
	setParent $uiName;
	setParent ..;

	string $col = `setParent -q`;
	string $ch[] = `columnLayout -q -ca $col`;
	separator -e -vis ((int)$specs[1]) $ch[1];
	rowLayout -e -vis ((int)$specs[1]) $ch[2];

	setParent ..;
	string $frame = `setParent -q`;
//	int $w = `frameLayout -q -w $frame`;
//	frameLayout -e -lw ($w-30) $frame;
	frameLayout -e -label $label -ann $ann $frame;
	frameLayout -e -borderStyle $specs[2] $frame;

	int $cl = `frameLayout -q -cl $frame`;
	frameLayout -e -cl (1-$cl) $frame;
	frameLayout -e -cl ($cl) $frame;


}


//=========================================================================
// This creates the scripted panel type
// It is nessessary if you want to use this panel in a panel layout
// without calling "attrCollection" before
//
global proc acPanelType()
{
printTrace( 6, "acPanelType" );

	if (!`scriptedPanelType -exists acPanelType`) {
print("defining scriptedPanelType\n");
		scriptedPanelType
			-createCallback "acCreatePanel" 
			-addCallback "acAddPanel" 
			-removeCallback "acRemovePanel"
			-deleteCallback "acDeletePanel"
			-unique false
		acPanelType;
	
	
	}
endTrace();
}



//=========================================================================
// This creates a panel configuration for the Attribute Collection
//
global proc acCreatePanelConfig()
{
printTrace( 6, "acCreatePanelConfig");

    string $panelConfig = `getPanel -cwl "AttrCollectionLayout"`;
    if ($panelConfig == "") {
print("defining panelConfiguration\n");
		panelConfiguration -label "AttrCollectionLayout"
			-sc false
			-configString "paneLayout -e -cn \"vertical2\" -ps 1 40 100 -ps 2 60 100 $gMainPane;"
			-ap false
				"Attribute Collection"
				"scriptedPanel"
				"$panelName = `scriptedPanel -unParent -type \"acPanelType\" -l \"Attribute Collection\" -mbv true `;"
				"scriptedPanel -edit -l \"Attribute Collection\" -mbv true  $panelName"
			-ap true
				"Persp View"
				"modelPanel"
				"$panelName = `modelPanel -unParent -l \"Persp View\" -mbv $menusOkayInPanels `;modelEditor -e -cam `findStartUpCamera persp` $panelName"
				"modelPanel -edit -l \"Persp View\" $panelName;";
//				"modelPanel -edit -l \"Persp View\" -mbv $menusOkayInPanels  $panelName;\n$editorName = $panelName;\nmodelEditor -e \n    -cam `findStartUpCamera persp` \n    -useInteractiveMode 0\n  $editorName";
    }
endTrace();
}

acPanelType();
acCreatePanelConfig();
//
//
//===========================================================================
global proc string acFindScriptNode( string $panelName)
{
printTrace( 3, "acFindScriptNode: " + $panelName);

// find a scriptNode that has the $panelName set
	string $acScriptNodes[] = acScriptNodes();
	for ( $s in $acScriptNodes ) {
		string $uiDeleteName = acGetUIDeleteName( $s);
		string $specs[] = acGetSpecs( $s);
		if ($uiDeleteName == $panelName && $specs[2]) {
			endTrace();
			return $s;
		}
	}
endTrace();
	return "";
}

global proc string acFindAnyScriptNode( string $panelName)
{
printTrace( 4, "acFindAnyScriptNode: " + $panelName);

	// couldn't find anything - lets try to find ANY node that has no panel yet
	string $acScriptNodes[] = acScriptNodes();
	for ( $s in $acScriptNodes ) {
		$nodePanel = acGetUIDeleteName( $s);
		string $specs[] = acGetSpecs( $s);
		if ($nodePanel == "" && $specs[2]) {
			endTrace();
			return $s;
		}
	}
endTrace();
	return "";
}

//===========================================================================

global proc acCreatePanel( string $panelName)
{
printTrace( 3, "acCreatePanel: " + $panelName);

	global string $acMasterNode;
	global string $acAttachToNode;
	string $node = $acAttachToNode;
	$acAttachToNode = "";

// printn("acCreatePanel >" + $panelName + "<");
// printn("...mit dem Label >" + (`scriptedPanel -q -l $panelName`) + "<");
// printn("...soll an Node >" + $node + "< angebunden werden");
	if (!`objExists $node`) $node = acFindScriptNode( $panelName);
// printn("...node nach acFindScriptNode: >" + $node + "<");
	if (!`objExists $node`) $node = acFindAnyScriptNode( $panelName);
// printn("...node nach acFindAnyScriptNode: >" + $node + "<");

// 	if (!`objExists $node` && $acMasterNode == "" && size(acScriptNodes())) {
// 		string $nodes[] = acScriptNodes();
// 		$acMasterNode = $node = $nodes[0];
// 	}
// printn("...node nach $masterNode: >" + $node + "<");
	if (!`objExists $node`) $node = acCreateScriptNode();
// printn("... OK, wir haben uns fuer die Node >" + $node + "< entschieden");
	acCheckVersion( $node);
//	string $oldPanel = acGetUIDeleteName( $node);
//printn("...bisheriger Panel Name der Node: >" + $oldPanel + "<");
	acSetUIName( $node, {";", $panelName});
//	if (`panel -exists $oldPanel`) acClosePanel( $oldPanel);

string $nodeName = acGetLabel( $node);
// printn("...createPanel: label der Node >" + $nodeName + "<");
scriptedPanel -e -l ($nodeName) $panelName;

endTrace();
}

global proc acAddPanel( string $panelName)
{
printTrace( 3, "acAddPanel: " + $panelName);

	// UI herstellen - DRAW!!!
	// den uiName in der scriptNode Setzen!!!
	// es muss eine scriptNode geben, in deren specs (!!) dieser $panelName steht
// printn("acAddPanel >" + $panelName + "<");

	string $node = acFindScriptNode( $panelName);
// printn("...acAddPanel node gefunden>" + $node + "<\n");
	string $uiName = `setParent -q`;

// PROBLEM: hier gibts Verwirrung, weil in acDrawEnrty nochmal der uiName gesetzt wird
// und in acDrawPanelEntry wird versucht, ein setParent zu machen
// --- in acDrawPanelEntry gibts aber gar nichts zu tun, weil ich die Infos (uiName und PanelName) nur HIER habe

	// first get the commands that set the prefs (could be empty)
	string $cmd = acGetPrefString( $node);
	if (size($cmd)) eval( $cmd);

	acSetUIName( $node, {$uiName, $panelName});
	int $tornOff = `scriptedPanel -q -tearOff $panelName`;

	string $label = acGetLabel( $node);
	string $ann = acGetAnnotation( $node);
	string $specs[] = acGetSpecs( $node);
// tornOff visible active
	$specs[0] = $tornOff;
	$specs[1] = 1;
	acSetSpecs( $node, $specs);
	scriptedPanel -e -l $label $panelName;
	acDrawEntry( $node);

if ($tornOff) window -e -title $label (acTopLevelUI( $uiName));
$panelLabel = `scriptedPanel -q -l $panelName`;
// printn("===acAddPanel: panel label >" + $panelLabel + "<");
evalDeferred( "scriptedPanel -e -l \"" + $label + "\" \"" + $panelName + "\"");
endTrace();
}


global proc acRemovePanel( string $panelName)
{
printTrace( 3, "acRemovePanel: " + $panelName);

	// UI wird geloescht
	// uiName der scriptNode leeren
// printn("acRemovePanel >" + $panelName + "<");
	string $node = acFindScriptNode( $panelName);
// printn("scriptNode gefunden: >" + $node + "<");

	if (size($node)) {
		acSetUIName( $node, {";", $panelName});
		string $specs[] = acGetSpecs( $node);
		$specs[1] = 0;
		acSetSpecs( $node, $specs);

	// delete the Edit Window of $node and all it"s children
		acDeleteEditWin( $node);
		string $ch[] = acGetAllChildren( $node);
		for ( $c in $ch ) acDeleteEditWin( $c);

	// delete the hierarchy window
		string $hierarchyWin = ($node + "HWin");
		if (`window -exists $hierarchyWin`) deleteUI $hierarchyWin;


	}
endTrace();
}

global proc acDeletePanel( string $panelName)
{
printTrace( 3, "acDeletePanel: " + $panelName);

	// die scriptNode, in deren specs (!!!) diese $panelName steht, wird geloescht
	// (vorsicht, bei undo) - hierzu muessen die Funktionen checkScriptNode und unCheckScriptNode bereit sein
// 	print("acDeletePanel >" + $panelName + "<\n");
	string $node = acFindScriptNode( $panelName);
// 	print("acDeletePanel found script node>" + $node + "<\n");
	if (size($node) && (!`reference -isNodeReferenced $node`)) catch( `delete $node`);
	acCleanupNodeData();
endTrace();
}


//=======================================================================
//=======================================================================
//=======================================================================

//------------HELPERS------------------------
global proc string acTopLevelUI( string $uiName)
{
printTrace( 6, "acTopLevelUI: " + $uiName);

	string $tmp[];
	tokenize $uiName "|" $tmp;
endTrace();
	return $tmp[0];
}

global proc acClosePanel( string $panelName)
{
printTrace( 3, "acClosePanel: " + $panelName);

	if (`scriptedPanel -q -to $panelName`) {		// it is a window, find the top parent and delete it
//		string $tmp[];
//		$tmp[0] = `setParent $panelName`;
//		tokenize $tmp[0] "|" $tmp;
//		deleteUI $tmp[0];
		deleteUI (acTopLevelUI( `setParent $panelName`));
	}								// this is a panel;
	scriptedPanel -e -unParent $panelName;
	deleteUI $panelName;
	fillEmptyPanes;
endTrace();
}

global proc int panelIsVisible( string $panelName)
{
printTrace( 4, "panelIsVisible: " + $panelName);

	$visPanels = `getPanel -vis`;
	for ( $panel in $visPanels ) {
		if ( $panel == $panelName ) {
			endTrace();
			return true;
		}
	}

endTrace();

	return false;
}

global proc acShowAC( string $node)
{
printTrace( 2, "acShowAC: " + $node);


// voellige Verwirrung hier!!!!!!!!!!!!!!!!!!!!
//
// einerseits kommt von der Funktion "ac" die Anforderung, einfach mal "etwas" sichtbar zu machen
// (u.U. gibt's noch gar keine acScript Node)
// andererseits muss ggf. eine MasterNode dargestellt werden (AUCH als TornOff UND spter im PanelLayout)
//
// wenn man das PanelLAyout aufruft, dann wird scheinbar IMMER ein neues Panel hergestellt
// eine vorhandene MasterNode (wenn schon TornOff soll aber zurck in dieses PanelLayout
//
// der User soll auerdem einstellen knnen, welches die MasterNode ist, der er mit dem Kommando "ac" neue Channels zuweist

//-------------------------
// hat die Node schon ein Panel?
// ist das Panel sichtbar?
// soll die Node in einem Fenster dargestellt werden?

// nur die MasterNode wird in dieser Funktion in einem panelConfig dargestellt

// Fall EINS: ein Torn Off Window
//   - optionVar "acAsWindow"
//   - Node als tornOff markiert
//   - das PanelLayout existiert schon und da ist die MasterNode drin (wie finde ich das raus?)
//   - 
// Fall ZWEI: ein Panel im PanelConfig
//   - es gibt noch GARKEINE node
//   - dies ist die MasterNode und sie soll in ein Panel

	global string $gMainPane;
	global string $acMasterNode;
	global string $acAttachToNode;
// printn("This is acShowAC");
// printn("acMakePanelVisible: $node = " + $node);
// printn("acMasterNode ist: = " + $acMasterNode);

	string $panelName;

	acPanelType();
	acCreatePanelConfig();

// printn("acMakeVis... 1");

	string $specs[];
	int $asWindow = (`optionVar -q "acAsWindow"`);
	if (`objExists $node`) {
		$specs = acGetSpecs( $node);
		$asWindow = $asWindow || (int)$specs[0];	// tornOff
	}
	string $panelName;
	int $acNodesExist = size(acScriptNodes());
	int $nodeIsNotMasterNode = ($node != $acMasterNode);

// printn("acMakeVis... 2");
// existiert die node?
	if (`objExists $node`) {
// hat sie evtl schon einen PanelNamen? - falls nicht, dann wird das naechste Panel hier angebunden
		$panelName = acGetUIDeleteName( $node);
		if ($panelName == "" || (!`panel -exists $panelName`)) {
			$acAttachToNode = $node;
			$panelName = "";			// in case it has a value, but the panel doesnt exist
			acSetUIName( $node, {});
		}
// printn("die Node existiert, der bestehende PanelName ist >" + $panelName + "<");
	}


// printn("acMakeVis... 3");
// existiert das ermittelte Panel schon?
// UND ist es ein tornOff Panel, das man mit schowWindow sichtbar machen kann?
	if (`scriptedPanel -exists $panelName` && `scriptedPanel -q -to $panelName`) {
		showWindow (acTopLevelUI( `setParent $panelName`));
printn("End of acShowAC");
endTrace();
		return;
	}

// printn("acMakeVis... 4");
// war's das evtl. schon?
	if (panelIsVisible( $panelName)) {
printn("End of acShowAC");
endTrace();
		return;
	}

// printn("acMakeVis... 5 leer");

// printn("acMakeVis... 6");
// soll das neue Panel sowieso in ein Window
// oder gibt"s vielleicht schon eine Masternode?
	if ($asWindow || $nodeIsNotMasterNode) {
// printn("acMakeVis... 7");
		if (`scriptedPanel -exists $panelName`) {
			scriptedPanel -menuBarVisible true -e -tearOff $panelName;
//			scriptedPanel -e -l $panelName $panelName;
		} else {
			$panelName = `scriptedPanel -menuBarVisible true -parent $gMainPane -l "anyLabel" -tearOff -type "acPanelType"`;
//			scriptedPanel -e -l $panelName $panelName;
		}

// nagut, dann versuchen wir's mal mit einem PanelLayout
	} else {
// printn("acMakeVis... 8");
		// der wirkliche Name der panelConfig
		string $panelConfig = `getPanel -configWithLabel "AttrCollectionLayout"`;
// printn("acMakeVis... 9");

		// findet die Position des acPanelType Panels in dieser Config (0-based index)
		int $acPanelIndex = findPanelInConfiguration( $panelConfig, "acPanelType");
// printn("acMakeVis... 10  panelIndex = " + $acPanelIndex);
if ($acPanelIndex == -1) {
	warning "No AC Panel found in configuration";
printn("End of acShowAC");
endTrace();
	return;
}

		// alle weiteren Operationen sind 1-based
//		$acPanelIndex += 1;
// printn("acMakeVis... 11");

		// nun tausche ich das Panel in der Configuration gegen das Panel der MasterNode aus
//		panelConfiguration -e -replaceLabel $acPanelIndex $panelName $panelConfig;
// printn("acMakeVis... 12");

		setNamedPanelLayout "AttrCollectionLayout";
// printn("neue Panel Labels NACH Herstellen des Layouts");
// print (`panelConfiguration -q -ls $panelConfig`);

	string $tmp[] = `panelConfiguration -q -ls $panelConfig`;
// printn("panelIndex ist jetzt = " + $acPanelIndex);
	string $oldPanel = `getPanel -withLabel $tmp[$acPanelIndex]`;
printn("VOR dem austauschen : panelName = " + $panelName + ", oldPanel = " + $oldPanel);
	if ($panelName != $oldPanel && $panelName != "" && $oldPanel != "") {
		scriptedPanel -e -replacePanel $oldPanel $panelName;
//?		scriptedPanel -e -l (`scriptedPanel -q -l $panelName`) $oldPanel;
//		scriptedPanel -e -l "AC Main Panel" $panelName;
	}
// printn("acMakeVis... 13");
	}

	$acAttachToNode = "";
// printn("End of acShowAC");

endTrace();
}




global proc string acCreateBasePose( string $node, string $attrs[])
{
// creates a new Pose Node with plugs for attribute connections
// and with attributes to store poseName and values for these attributes
// connects the new pose to the "poses" attribute of $node (which is an acScript Node)

	string $pose = `createNode -n "pose#" network`;

	addAttr -sn "bn" -ln "baseName" -dt "string" $pose;
	addAttr -sn "pa" -ln "poseAttribute" -multi -at "message" $pose;

	addAttr -sn "po" -ln "pose"				-multi	-at compound -nc 3 $pose;
	addAttr -sn "pn" -ln "poseName"					-dt "string"	-parent "pose" $pose;
	addAttr -sn "av" -ln "attributeValue"	-multi	-at double		-parent "pose" $pose;
	addAttr -sn "ub" -ln "usedBy"			-multi	-at message		-parent "pose" $pose;

	int $index = size( `listConnections ($node + ".pose")`);
	connectAttr ($pose + ".message") ($node + ".pose[" + $index + "]");

// now connect the attributes to the pose node
	int $index = 0;
	for ( $a in $attrs ) {
		connectAttr $a ($pose + ".poseAttribute[" + $index++ + "]");
	}

	return $pose;
}



global proc int acCreatePose( string $poseNode, string $poseName)
{
// creates a new pose entry at an existing pose node
// the attributes are already connected
// This only grabs the values and stores them under a given name

	int $index = `getAttr -s ($poseNode + ".pose")`;
	setAttr -type "string" ($poseNode + ".pose[" + $index + "].poseName") $poseName;
	acSavePose( $poseNode, $index);
	return $index;
}

global proc acSavePose( string $poseNode, int $index)
{
// grabs the value of the connected attributes and stores them under the given index pose

	string $attr[] = `listConnections -d false -s true -p true ($poseNode + ".poseAttribute")`;
	for ( $i=0 ; $i<size($attr) ; $i++ ) {
		float $value = `getAttr $attr[$i]`;
		setAttr ($poseNode + ".pose[" + $index + "].attributeValue[" + $i + "]") $value;
	}
}

global proc acGetPose( string $poseNode, int $index)
{
// gets the stored values of the pose and puts them back into the attributes

	string $attr[] = `listConnections -d false -s true -p true ($poseNode + ".poseAttribute")`;
	for ( $i=0 ; $i<size($attr) ; $i++ ) {
		float $value = `getAttr ($poseNode + ".pose[" + $index + "].attributeValue[" + $i + "]")`;
		setAttr $attr[$i] $value;
	}
}



//-----------------------------------------------------------------------------------
//-----------------------------------------------------------------------------------
//-----------------------------------------------------------------------------------

proc acRebuildMenus( string $node)
{
	string $uiName = acGetUIName( $node);
	string $panelName = acGetUIDeleteName( $node);

// printn("+++++ac rebuild menus: uiName = >" + $uiName + "<");
// printn("+++ is the menuBarLayout here?");
	if (size( $panelName)) {
		string $menuBar = `panel -q -ctl ($panelName)`;
// printn("+++ panel ctl:: " + $menuBar);
		if (size($menuBar) && (`objectTypeUI -isType "menuBarLayout" $uiName`)) {
			string $menu[] = `menuBarLayout -q -ma $menuBar`;

			menu -e -deleteAllItems $menu[0];
			setParent -menu $menu[0];
			acDrawFileMenuItems( $node, $menu[0]);

			menu -e -deleteAllItems $menu[1];
			setParent -menu $menu[1];
			acDrawEditMenuItems( $node);
		}

	}

}

//------------------------------------------------------------------
// if the UI was locked, then the TD can unlock it with this command
//------------------------------------------------------------------
global proc acUnlockUI()
{
	optionVar -iv "acPrefLockUI" 0;
	string $acScriptNodes[] = acScriptNodes();
	for ( $s in $acScriptNodes ) {
		acRedrawEntry( $s);
		acRebuildMenus( $s);
	}
}

//------------------------------------------------------------------
// Expert Mode 1 opens up editing of referenced UI (careful please)
//------------------------------------------------------------------
global proc acExpertMode( int $mode)
{
	optionVar -iv "acExpertMode" $mode;
	string $acScriptNodes[] = acScriptNodes();
	for ( $s in $acScriptNodes ) {
		acRedrawEntry( $s);
		acRebuildMenus( $s);
	}
}

//-----------------------------------------------------------------------------------
global proc acPrefs()
{
	if (`window -exists acPrefWin`) showWindow acPrefWin;
	else {
	    window
		-title "Attribute Collection Preferences"
		-w 425
		-h 673
	    acPrefWin;


		$form = `formLayout -numberOfDivisions 100`;
		    $col = `tabLayout
				    -tabsVisible false
				    -scrollable true
				    -verticalScrollBarThickness 18
				    -horizontalScrollBarThickness 0
				    -childResizable true
				    -innerMarginWidth 0
				    -innerMarginHeight 0`;
		    columnLayout -adj true;
			    separator -style "none" -h 20;
			    radioButtonGrp
					-label "Appearence"
					-numberOfRadioButtons 2
					-label1 "As Panel"
					-label2 "As Window"
			      acPrefAsWindow;
//			    separator -h 20;
//			    radioButtonGrp
//					-label "Imported UI as ..."
//					-numberOfRadioButtons 2
//					-label1 "Inline"
//					-label2 "Window"
//			      acPrefImportUI;
			    separator -h 20;
			    rowLayout -numberOfColumns 4
				-columnWidth 1 130
				-columnWidth 2 80
				-columnWidth 3 80
				-columnWidth 4 80
				-columnAlign 1 "right"
				-columnAttach 2 "left" 10
				-columnAttach 3 "left" 10
				-columnAttach 4 "left" 10;
			    text -w 130 -align "right" -label "Presets";
			    button -align "center" -w 80 -label "Large" -c "acPrefSetLarge";
			    button -align "center" -w 80 -label "Small" -c "acPrefSetSmall";
			    button -align "center" -w 80 -label "Very Small" -c "acPrefSetVerySmall";
			   setParent ..;
			    separator -h 20;
			    rowLayout -numberOfColumns 1
				-columnAlign 1 "left"
				-adjustableColumn 1
				-columnAttach 1 "left" 140;
			    	text -h 30 -font "boldLabelFont" -label "Sizes";
			    setParent ..;
			    intFieldGrp -label "Label" acPrefLabelSize;
			    intFieldGrp -label "Field" acPrefFieldSize;
			    intFieldGrp -label "Slider" acPrefSliderSize;
			    checkBoxGrp
					-l1 ""
					-label "Enable Sliders"
					-v1 1 acPrefEnableSliders;
			    checkBoxGrp
					-l1 ""
					-label "Color Texture Buttons"
					-v1 1 acPrefEnableColorButtons;
			    separator -h 20;

				optionMenuGrp -label "Initial Attribute Label" -columnAlign 1 "right" acPrefNameStyle;
					menuItem -label "objName.shortName";
					menuItem -label "shortName";
					menuItem -label "objName.longName";
					menuItem -label "longName";
					menuItem -label "Nice Names";

			    separator -h 20;
			    checkBoxGrp
					-l1 ""
					-label "Allow Annotations"
					-v1 1 acPrefAnnotation;
			    checkBoxGrp
					-l1 "for Attribute Entries"
					-label "Initial Annotation"
					-en (acGetOpt( "acPrefAnnotation", 1))
					-v1 1 acPrefInitAnnotation;
				checkBoxGrp -e -cc "checkBoxGrp -e -en (`checkBoxGrp -q -v1 acPrefAnnotation`) acPrefInitAnnotation" acPrefAnnotation;
			    separator -h 20;
			    rowLayout -numberOfColumns 1
				-columnAlign 1 "left"
				-adjustableColumn 1
				-columnAttach 1 "left" 140;
			    	text -h 30 -font "boldLabelFont" -label "Buttons";
			    setParent ..;
			    checkBoxGrp -l1 "  \"Set Key\"" -label "Set Keyframe" acPrefSetKBtn;
			    checkBoxGrp -l1 "  \"Del Key\"" -label "Delete Keyframe" acPrefDelKBtn;
			    checkBoxGrp -l1 "  \"Brk Conn\"" -label "Break Connections" acPrefBreakCBtn;
			    checkBoxGrp -l1 "  \"Select\"" -label "Select" acPrefSelectBtn;
			    checkBoxGrp -l1 "  \"Edit...\"" -label "Edit..." acPrefEditBtn;
			    checkBoxGrp -l1 "  \"Delete...\"" -label "Delete..." acPrefDeleteBtn;
			    separator -h 20;
//			    rowColumnLayout -numberOfColumns 1
//			    				-columnWidth 1 180
//			    				-columnAlign 1 "left"
//			    				-columnAttach 1 "left" 90;
			    rowLayout -numberOfColumns 1
							-columnAlign 1 "left"
							-adjustableColumn 1
							-columnAttach 1 "left" 90;
				columnLayout -adj 1;
			    	text -align "left" -label "Caution:" -font "boldLabelFont";
			    	text -align "left" -label "This switch stops the user from changing the UI.";
			    	text -align "left" -label "The functions for Add, Edit, Delete, etc. are no longer offered.";
			    	text -align "left" -label "Use the command \"acUnlockUI\" to switch back." -font "boldLabelFont";
				setParent ..;
				setParent ..;
				separator -style "none" -h 10;
			    checkBoxGrp -l1 "  (no more Edit)" -label "Lock UI" acPrefLockUI;
			    separator -h 20;
			    checkBoxGrp -l1 "  with Prefs" -label "Save Collection..." acPrefSave;
			    separator -h 20;
			    setParent ..;
			    setParent ..;
			    $b1 = `button -label "OK" -c "acSetPrefs()"`;
			    $b2 = `button -label "Reset" -c "acGetPrefs(1)"`;
			    $b3 = `button -label "Cancel" -c "deleteUI acPrefWin"`;


		formLayout -edit
			-attachForm		$col	"top" 5
			-attachForm		$col	"left" 5
			-attachForm		$col	"right" 5
			-attachControl	$col	"bottom" 10 $b1


			-attachNone		$b1     "top"
			-attachForm		$b1	"left" 5
			-attachForm		$b1	"bottom" 5
			-attachPosition	$b1	"right" 2 33


			-attachNone		$b2     "top"
			-attachPosition	$b2	"left" 3 33
			-attachForm		$b2	"bottom" 5
			-attachPosition	$b2	"right" 2 67


			-attachNone		$b3     "top"
			-attachPosition	$b3	"left" 3 67
			-attachForm		$b3	"bottom" 5
			-attachForm		$b3	"right" 5
		$form;
	    acGetPrefs(0);
	    showWindow;
	}
}


global proc acPrefSetLarge()
{
	intFieldGrp -e -v1 140 acPrefLabelSize;
	intFieldGrp -e -v1 80 acPrefFieldSize;
	intFieldGrp -e -v1 240 acPrefSliderSize;
	checkBoxGrp -e -v1 1 acPrefEnableSliders;
	checkBoxGrp -e -v1 1 acPrefEnableColorButtons;
	optionMenuGrp -e -select 5 acPrefNameStyle;
}


global proc acPrefSetSmall()
{
	intFieldGrp -e -v1 80 acPrefLabelSize;
	intFieldGrp -e -v1 60 acPrefFieldSize;
	intFieldGrp -e -v1 120 acPrefSliderSize;
	checkBoxGrp -e -v1 1 acPrefEnableSliders;
	checkBoxGrp -e -v1 0 acPrefEnableColorButtons;
	optionMenuGrp -e -select 4 acPrefNameStyle;
}


global proc acPrefSetVerySmall()
{
	intFieldGrp -e -v1 40 acPrefLabelSize;
	intFieldGrp -e -v1 60 acPrefFieldSize;
	intFieldGrp -e -v1 1 acPrefSliderSize;
	checkBoxGrp -e -v1 0 acPrefEnableSliders;
	checkBoxGrp -e -v1 0 acPrefEnableColorButtons;
	optionMenuGrp -e -select 2 acPrefNameStyle;
}


global proc acGetPrefs( int $reset)
{
int	$asWindow	= $reset ? 0   : acGetOpt( "acAsWindow", 0);
//int	$importUI	= $reset ? 0   : acGetOpt( "acImportUI", 0);
int	$labelSize	= $reset ? 140 : acGetOpt( "acPrefLabelSize", 140);
int	$fieldSize	= $reset ? 80  : acGetOpt( "acPrefFieldSize", 80);
int	$sliderSize	= $reset ? 160 : acGetOpt( "acPrefSliderSize", 160);
int	$enableSliders	= $reset ? 1   : acGetOpt( "acPrefEnableSliders", 1);
int	$enableColorButtons	= $reset ? 0   : acGetOpt( "acPrefEnableColorButtons", 0);
int	$nameStyle = $reset ? 3   : acGetOpt( "acPrefNameStyle", 3);
int	$annotation	= $reset ? 1   : acGetOpt( "acPrefAnnotation", 1);
int	$initAnnotation	= $reset ? 0   : acGetOpt( "acPrefInitAnnotation", 0);
int	$setKBtn	= $reset ? 1   : acGetOpt( "acPrefSetKBtn", 1);
int	$delKBtn	= $reset ? 1   : acGetOpt( "acPrefDelKBtn", 1);
int	$breakCBtn	= $reset ? 1   : acGetOpt( "acPrefBreakCBtn", 1);
int	$selectBtn	= $reset ? 1   : acGetOpt( "acPrefSelectBtn", 1);
int	$editBtn	= $reset ? 1   : acGetOpt( "acPrefEditBtn", 1);
int	$deleteBtn	= $reset ? 1   : acGetOpt( "acPrefDeleteBtn", 1);
int	$lockUI		= $reset ? 0   : acGetOpt( "acPrefLockUI", 0);
int	$savePref	= $reset ? 1   : acGetOpt( "acPrefSave", 1);


	radioButtonGrp -e -select ($asWindow + 1) acPrefAsWindow;
//	radioButtonGrp -e -select ($importUI + 1) acPrefImportUI;
	intFieldGrp -e -v1 $labelSize acPrefLabelSize;
	intFieldGrp -e -v1 $fieldSize acPrefFieldSize;
	intFieldGrp -e -v1 $sliderSize acPrefSliderSize;
	checkBoxGrp -e -v1 $enableSliders acPrefEnableSliders;
	checkBoxGrp -e -v1 $enableColorButtons acPrefEnableColorButtons;
	optionMenuGrp -e -select $nameStyle acPrefNameStyle;
	checkBoxGrp -e -v1 $annotation acPrefAnnotation;
	checkBoxGrp -e -v1 $initAnnotation acPrefInitAnnotation;
	checkBoxGrp -e -v1 $setKBtn acPrefSetKBtn;
	checkBoxGrp -e -v1 $delKBtn acPrefDelKBtn;
	checkBoxGrp -e -v1 $breakCBtn acPrefBreakCBtn;
	checkBoxGrp -e -v1 $selectBtn acPrefSelectBtn;
	checkBoxGrp -e -v1 $editBtn acPrefEditBtn;
	checkBoxGrp -e -v1 $deleteBtn acPrefDeleteBtn;
	checkBoxGrp -e -v1 $lockUI acPrefLockUI;
	checkBoxGrp -e -v1 $savePref acPrefSave;
}


global proc acSetPrefs()
{
global string	$acAttr[];		// names of the registered attributes
global string	$acAttrLabel[];	// additional Labels fot the Attributes
global string	$acTab;		// the name of the current tabLayout


int	$asWindow	= (`radioButtonGrp -q -select acPrefAsWindow`) - 1;
//int	$importUI	= (`radioButtonGrp -q -select acPrefImportUI`) - 1;
int	$labelSize	= `intFieldGrp -q -v1 acPrefLabelSize`;
int	$fieldSize	= `intFieldGrp -q -v1 acPrefFieldSize`;
int	$sliderSize	= `intFieldGrp -q -v1 acPrefSliderSize`;
int	$enableSliders	= `checkBoxGrp -q -v1 acPrefEnableSliders`;
int	$enableColorButtons	= `checkBoxGrp -q -v1 acPrefEnableColorButtons`;
int	$nameStyle	= `optionMenuGrp -q -select acPrefNameStyle`;
int	$annotation	= `checkBoxGrp -q -v1 acPrefAnnotation`;
int	$initAnnotation	= `checkBoxGrp -q -v1 acPrefInitAnnotation`;
int	$setKBtn	= `checkBoxGrp -q -v1 acPrefSetKBtn`;
int	$delKBtn	= `checkBoxGrp -q -v1 acPrefDelKBtn`;
int	$breakCBtn	= `checkBoxGrp -q -v1 acPrefBreakCBtn`;
int	$selectBtn	= `checkBoxGrp -q -v1 acPrefSelectBtn`;
int	$editBtn	= `checkBoxGrp -q -v1 acPrefEditBtn`;
int	$deleteBtn	= `checkBoxGrp -q -v1 acPrefDeleteBtn`;
int	$lockUI		= `checkBoxGrp -q -v1 acPrefLockUI`;
int	$savePref	= `checkBoxGrp -q -v1 acPrefSave`;


	optionVar -iv "acAsWindow" $asWindow;
//	optionVar -iv "acImportUI" $importUI;
	optionVar -iv "acPrefLabelSize" $labelSize;
	optionVar -iv "acPrefFieldSize" $fieldSize;
	optionVar -iv "acPrefSliderSize" $sliderSize;
	optionVar -iv "acPrefEnableSliders" $enableSliders;
	optionVar -iv "acPrefEnableColorButtons" $enableColorButtons;
	optionVar -iv "acPrefNameStyle" $nameStyle;
	optionVar -iv "acPrefAnnotation" $annotation;
	optionVar -iv "acPrefInitAnnotation" $initAnnotation;
	optionVar -iv "acPrefSetKBtn" $setKBtn;
	optionVar -iv "acPrefDelKBtn" $delKBtn;
	optionVar -iv "acPrefBreakCBtn" $breakCBtn;
	optionVar -iv "acPrefSelectBtn" $selectBtn;
	optionVar -iv "acPrefEditBtn" $editBtn;
	optionVar -iv "acPrefDeleteBtn" $deleteBtn;
	optionVar -iv "acPrefLockUI" $lockUI;
	optionVar -iv "acPrefSave" $savePref;


	deleteUI acPrefWin;

	string $acScriptNodes[] = acScriptNodes();
	string $prefString = acSavePrefs();
	for ( $s in $acScriptNodes ) {
		if ($savePref) {
			acSetPrefString( $s, $prefString);
		} else acSetPrefString( $s, "");
		acSetNewNodeID( $s);
		acRedrawEntry( $s);
		acRebuildMenus( $s);
	}




}

global proc string acSavePrefs()
{

    int	$savePref	= acGetOpt( "acPrefSave", 1);
	if ($savePref) {
		int	$asWindow	= acGetOpt( "acAsWindow", 0);
//		int	$importUI	= acGetOpt( "acImportUI", 0);
	    int	$labelSize	= acGetOpt( "acPrefLabelSize", 140);
	    int	$fieldSize	= acGetOpt( "acPrefFieldSize", 80);
	    int	$sliderSize	= acGetOpt( "acPrefSliderSize", 160);
	    int	$enableSliders	= acGetOpt( "acPrefEnableSliders", 1);
		int	$enableColorButtons	= acGetOpt( "acPrefEnableColorButtons", 0);
	    int	$nameStyle	= acGetOpt( "acPrefNameStyle", 3);
	    int	$annotation	= acGetOpt( "acPrefAnnotation", 1);
	    int	$initAnnotation	= acGetOpt( "acPrefInitAnnotation", 0);
	    int	$setKBtn	= acGetOpt( "acPrefSetKBtn", 1);
	    int	$delKBtn	= acGetOpt( "acPrefDelKBtn", 1);
	    int	$breakCBtn	= acGetOpt( "acPrefBreakCBtn", 1);
	    int	$selectBtn	= acGetOpt( "acPrefSelectBtn", 1);
	    int	$editBtn	= acGetOpt( "acPrefEditBtn", 1);
	    int	$deleteBtn	= acGetOpt( "acPrefDeleteBtn", 1);
	    int	$lockUI		= acGetOpt( "acPrefLockUI", 0);
	
	
	string	$cmd = 
		"optionVar -iv \"acAsWindow\" " + $asWindow + ";\n" +
//		"optionVar -iv \"acImportUI\" " + $importUI + ";\n" +
		"optionVar -iv \"acPrefLabelSize\" " + $labelSize + ";\n" +
		"optionVar -iv \"acPrefFieldSize\" " +  $fieldSize + ";\n" +
		"optionVar -iv \"acPrefSliderSize\" " +  $sliderSize + ";\n" +
		"optionVar -iv \"acPrefEnableSliders\" " +  $enableSliders + ";\n" +
		"optionVar -iv \"acPrefEnableColorButtons\" " + $enableColorButtons + ";\n" +
		"optionVar -iv \"acPrefNameStyle\" " +  $nameStyle + ";\n" +
		"optionVar -iv \"acPrefAnnotation\" " +  $annotation + ";\n" +
		"optionVar -iv \"acPrefInitAnnotation\" " +  $initAnnotation + ";\n" +
		"optionVar -iv \"acPrefSetKBtn\" " +  $setKBtn + ";\n" +
		"optionVar -iv \"acPrefDelKBtn\" " +  $delKBtn + ";\n" +
		"optionVar -iv \"acPrefBreakCBtn\" " +  $breakCBtn + ";\n" +
		"optionVar -iv \"acPrefSelectBtn\" " +  $selectBtn + ";\n" +
		"optionVar -iv \"acPrefEditBtn\" " +  $editBtn + ";\n" +
		"optionVar -iv \"acPrefDeleteBtn\" " +  $deleteBtn + ";\n" +
		"optionVar -iv \"acPrefLockUI\" " +  $lockUI + ";\n";
	//	"optionVar -iv \"acPrefSave\" " +  $savePref + ";\n" +
	
	
	    return $cmd;
	} else return "";


}

global proc string acCreateReferenceEntry( string $parent, int $index, string $specs[])
{
printTrace( 4, "acCreateReferenceEntry: " + $parent);

// specs are:
// - Referenced Node

	string $type = "Reference";
	string $label = "Reference";
	string $ann = "";
 	string $node = acCreateNode( $parent, $index, $type, $label, $ann, $specs);

	// set a different label for the new group
	$label = substituteAllString( $node, "_", " ");
	acSetLabel( $node, $label);

endTrace();
	return $node;

}


global proc string[] acDrawReferenceEntry( string $node)
{
printTrace( 4, "acDrawReferenceEntry: " + $node);

	global string $acUINames[];

	string $specs[] = acGetSpecs( $node);
	if (`objExists $specs[0]`) {

		// set the UI to *locked* - references should *not* be edited
		int $wasLocked = acGetOpt( "acPrefLockUI", 0);
		optionVar -iv "acPrefLockUI" 1;

		string $type = acGetNodeType( $specs[0]);
		string $cmd = "acDraw" + $type + "Entry( \"" + $specs[0] + "\")";
	
		string $label = acGetLabel( $specs[0]);
		acSetLabel( $specs[0], acGetLabel( $node));
		string $ret[] = eval( $cmd);
		acSetLabel( $specs[0], $label);
	
		// restore the "locked" state
		optionVar -iv "acPrefLockUI" $wasLocked;

endTrace();
		return $ret;
	} else {
		string $uiDeleteName = `columnLayout`;
		string $uiName = `text -label ("Reference Enty \"" + $node + "\" could not finde the specified node")`;
endTrace();
		return {$uiName, $uiDeleteName};
	}

}

global proc acReferenceDrawChildren( string $node, string $children[])
{
printTrace( 4, "acReferenceDrawChildren: " + $node);

	global string $acUINames[];

	string $specs[] = acGetSpecs( $node);
	if (`objExists $specs[0]`) {
		$children = acGetNodeChildren( $specs[0]);

		// store the uiNames of the *original* entry
		string $tmp[] = $acUINames;

		// transfer the uiNames for the reference - children will query the uiName of their *parent*
		acSetNodeData( $specs[0], acGetNodeData( $node, $acUINames), $acUINames);

		// set the UI to *locked* - references should *not* be edited
		int $wasLocked = acGetOpt( "acPrefLockUI", 0);
		optionVar -iv "acPrefLockUI" 1;

		acDrawChildren( $specs[0], $children);

		// restore the "locked" state
		optionVar -iv "acPrefLockUI" $wasLocked;

		// restore the original uiNames
		$acUINames = $tmp;
	}
endTrace();
}

//-----------------Edit CheckBox UI------------------------------------
global proc acEditReference( string $node, string $control)
{
printTrace( 4, "acEditReference: " + $node);


	string $specs[] = acGetSpecs( $node);
	string $refNode = $specs[0];

	setParent $control;

	string $ctrl = `textFieldGrp -label "Referenced Node" -text $refNode`;
	textFieldGrp -e -cc ("acGetEditValue( \"" + $node + "\", 0, \"textFieldGrp -q -text " + $ctrl + "\");") $ctrl;

endTrace();
}

//------------------- AttrCheckBox Set UI---------------------------------------
global proc acEditReferenceUI( string $node)
{
printTrace( 4, "acEditReferenceUI: " + $node);

	acRedrawEntry( acGetParentNode( $node));

endTrace();
}


//------------------ RowLayout------------------------------

global proc acRowLayoutChildDeleted( string $node, int $cleanup, int $deleteUI)
{
// this function is called, if one of the RowLayouts children was just deleted
	if ($deleteUI) acRedrawEntry( $node);
}



global proc acRowLayoutDrawChildren( string $node, string $children[])
{
	string $uiName = acGetUIName( $node);
	int $chCount = `rowLayout -q -nch $uiName`;
	int $j = 0;
	for ( $i=$chCount ; $i<6 && $j<size($children) ; $i++ ) acDrawEntry( $children[$j++]);
	if (size( acGetNodeChildren( $node)) > 6 ) {
		warning ("RowLayout \"" + $node + "\" does not accept more that 6 children! Please move some children to other layouts.");
		acEditWin( $node, acNewEditWin(""), {});
	}
}

//----------------------RowLayout------------------------
global proc string acCreateRowLayoutEntry( string $parentNode, int $index, string $label)
{
// specs are:
// - label
// - number of columns
// - widthType (automatic or specified)
// - width1-6
// - adjustable column
// - offset betwee the columns


global string	$acActiveParent;

	string $specs[] = acTypeOptions( "RowLayout");
	string $ann;

	string $node = acCreateNode( $parentNode, $index, "RowLayout", $label, $ann, $specs);

	$acActiveParent = $node;
	return $node;
}

//-----------------Draw RowLayout ------------------------------------

global proc string[] acDrawRowLayoutEntry( string $node)
{
	int	$labelSize = acGetOpt( "acPrefLabelSize", 140);
	int	$fieldSize = acGetOpt( "acPrefFieldSize", 80);
	int	$sliderSize = acGetOpt( "acPrefSliderSize", 160)
				* acGetOpt( "acPrefEnableSliders", 1);
	if ($sliderSize < 1) $sliderSize = 1;
	int $totalWidth = $labelSize + $fieldSize + $sliderSize;

	string $ann = acGetAnnotation( $node);
	string $specs[] = acGetSpecs( $node);

	string $rowName = `rowLayout -ann $ann
								-numberOfColumns ((int)$specs[0])
								-columnWidth 1 ((int)$specs[2])
								-columnWidth 2 ((int)$specs[3])
								-columnWidth 3 ((int)$specs[4])
								-columnWidth 4 ((int)$specs[5])
								-columnWidth 5 ((int)$specs[6])
								-columnWidth 6 ((int)$specs[7])
								-adjustableColumn ((int)$specs[8])
								-columnAttach 1 "both" 	((int)$specs[9])
								-columnAttach 2 "both" 	((int)$specs[9])
								-columnAttach 3 "both" 	((int)$specs[9])
								-columnAttach 4 "both" 	((int)$specs[9])
								-columnAttach 5 "both" 	((int)$specs[9])
								-columnAttach 6 "both" 	((int)$specs[9])`;

	return {$rowName};
}


//---------------------------------------------------------------


global proc acEditRowLayout( string $node, string $control)
{
	string $specs[] = acGetSpecs( $node);

	string $w1 = `intFieldGrp -numberOfFields 3 -v1 ((int)$specs[2]) -v2 ((int)$specs[3]) -v3 ((int)$specs[4]) -label "Column Width"`;
	$cmd = ("acGetEditValue( \"" + $node + "\", 2, \"intFieldGrp -q -v1 " + $w1 + "\");");
	$cmd += ("acGetEditValue( \"" + $node + "\", 3, \"intFieldGrp -q -v2 " + $w1 + "\");");
	$cmd += ("acGetEditValue( \"" + $node + "\", 4, \"intFieldGrp -q -v3 " + $w1 + "\");");
	intFieldGrp -e -cc $cmd $w1;
	string $w2 = `intFieldGrp -numberOfFields 3 -v1 ((int)$specs[5]) -v2 ((int)$specs[6]) -v3 ((int)$specs[7]) -label ""`;
	$cmd = ("acGetEditValue( \"" + $node + "\", 5, \"intFieldGrp -q -v1 " + $w2 + "\");");
	$cmd += ("acGetEditValue( \"" + $node + "\", 6, \"intFieldGrp -q -v2 " + $w2 + "\");");
	$cmd += ("acGetEditValue( \"" + $node + "\", 7, \"intFieldGrp -q -v3 " + $w2 + "\");");
	intFieldGrp -e -cc $cmd $w2;

	string $adj = `intFieldGrp -numberOfFields 1 -v1 ((int)$specs[8]) -label "Adjustable Column"`;
	intFieldGrp -e -cc ("acGetEditValue( \"" + $node + "\", 8, \"intFieldGrp -q -v1 " + $adj + "\");") $adj;

	string $offset = `intFieldGrp -numberOfFields 1 -v1 ((int)$specs[9]) -label "Column Offset"`;
	intFieldGrp -e -cc ("acGetEditValue( \"" + $node + "\", 9, \"intFieldGrp -q -v1 " + $offset + "\");") $offset;
}

//--------------Set RowLayout UI (from EditWin)------------------------
global proc acEditRowLayoutUI( string $node)
{
	string $specs[] = acGetSpecs( $node);
	string $ann = acGetAnnotation( $node);
	string $uiName = acGetUIName( $node);

	rowLayout -e -ann $ann
				-numberOfColumns ((int)$specs[0])
				-columnWidth 1 ((int)$specs[2])
				-columnWidth 2 ((int)$specs[3])
				-columnWidth 3 ((int)$specs[4])
				-columnWidth 4 ((int)$specs[5])
				-columnWidth 5 ((int)$specs[6])
				-columnWidth 6 ((int)$specs[7])
				-adjustableColumn ((int)$specs[8])
				-columnAttach 1 "both" 	((int)$specs[9])
				-columnAttach 2 "both" 	((int)$specs[9])
				-columnAttach 3 "both" 	((int)$specs[9])
				-columnAttach 4 "both" 	((int)$specs[9])
				-columnAttach 5 "both" 	((int)$specs[9])
				-columnAttach 6 "both" 	((int)$specs[9])
		$uiName;


}




// -----------------Child Deleted --------------------------------

global proc acTabLayoutChildDeleted( string $node, int $cleanup, int $deleteUI)
{
printTrace( 4, "acTabLayoutChildDeleted: " + $node);

// this function is called, if one of the tablayouts children was just deleted

	acGetTab( $node);
endTrace();
}

// ------------------GET TAB und SET TAB-----------------------------------------

global proc string acGetActiveTabChild( string $node)
{
printTrace( 5, "acGetActiveTabChild: " + $node);

// this function returns the active tab of the tabLayout $node
// reads from the UI which tab is selected and returns the CHILD NODE in the active tab

	string $uiName = acGetUIName( $node);

	if (acGetNodeType( $node) == "TabLayout") {
		int $currentTab = `tabLayout -q -selectTabIndex $uiName`;
		string $ch[] = acGetNodeChildren( $node);
		if ($currentTab > 0) $acActiveTab = $ch[$currentTab-1];
		else $acActiveTab = "";
endTrace();
		return $acActiveTab;
	}
endTrace();
	return "";
}

global proc acGetTab( string $node)
{
printTrace( 5, "acGetTab: " + $node);

// this function is called when the user switches the tabs
// reads from the UI which tab is selected and stores that in the node

	global string $acActiveTab;

	string $uiName = acGetUIName( $node);
	string $specs[] = acGetSpecs( $node);
	int $currentTab = `tabLayout -q -selectTabIndex $uiName`;
	$specs[0] = $currentTab;
	undoInfo -stateWithoutFlush 0;
	acSetSpecs( $node, $specs);
	undoInfo -stateWithoutFlush 1;

	string $ch[] = acGetNodeChildren( $node);
	if ($currentTab > 0) $acActiveTab = $ch[$currentTab-1];
	else $acActiveTab = "";
endTrace();
}

global proc acSetTab( string $node)
{
printTrace( 5, "acSetTab: " + $node);

// reads from the node, what the current tab should be and sets that in the UI
	string $uiName = acGetUIName( $node);
	string $specs[] = acGetSpecs( $node);
	int $tabCount = `tabLayout -q -numberOfChildren $uiName`;
// printn("acSetTab: anzahl children = " + $tabCount);
	int $sel = min( $tabCount, (int)$specs[0]);
// printn("acSetTab: setze tab # " + $sel);
	if ( $sel > 0) tabLayout -e -selectTabIndex $sel $uiName;
	$specs[0] = $sel;
	undoInfo -stateWithoutFlush 0;
	acSetSpecs( $node, $specs);
	undoInfo -stateWithoutFlush 1;
endTrace();
}

//-----------------------ADD TAB----------------------------------
global proc string acAddTab( string $node, string $label)
{
printTrace( 4, "acAddTab: " + $node);

// appends a new columnLayout to the existing children of a tabLayout
// draws it and sets this new one visible

	string $uiName = acGetUIName( $node);
	int $ch = `tabLayout -q -nch $uiName`;
	string $new = acCreateColumnLayoutEntry( $node, -1, $label, "");
	acDrawEntry( $new);
	tabLayout -e -sti ($ch+1) $uiName;
	acDrawTabLayoutEntryPost( $node);
endTrace();
	return $new;
}

//---------------------- CREATE TAB------------------------
global proc string acCreateTabLayoutEntry( string $parentNode, int $index, string $label)
{
printTrace( 4, "acCreateTabLayoutEntry: " + $parentNode);

// specs are:
// - label (unused)
// - selected tab index
// - margin width
// - margin height
// - pre-select Command

global string	$acActiveParent;

	string $ann;
	string $node = acCreateNode( $parentNode, $index, "TabLayout", $label, $ann, {"0", "2", "2", "// Pre-Select Command"});
	$acActiveParent = $node;
endTrace();
	return $node;
}

//-----------------Draw TabLayout ------------------------------------
global proc string[] acDrawTabLayoutEntry( string $node)
{
printTrace( 3, "acDrawTabLayoutEntry: " + $node);

	string $label = acGetLabel( $node);
	string $ann = acGetAnnotation( $node);
	string $specs[] = acGetSpecs( $node);
	string $tabName = `tabLayout -ann $ann -tabsVisible true
						-innerMarginWidth ((int)$specs[1]) -innerMarginHeight ((int)$specs[2])
						-cc ("acGetTab(\"" + $node +"\")")
//						-childResizable true
						-scrollable true
						-horizontalScrollBarThickness 18
						-verticalScrollBarThickness 18`;

endTrace();
	return {$tabName};
}

//-----------------Draw TabLayout Post------------------------------------
global proc acDrawTabLayoutEntryPost( string $node)
{
printTrace( 4, "acDrawTabLayoutEntryPost: " + $node);

	string $tabUIName = acGetUIName( $node);
	string $child[] = acGetNodeChildren( $node);
	for ( $i=0 ; $i<size($child) ; $i++ ) {
		string $chLabel = acGetLabel( $child[$i]);
		tabLayout -edit -tabLabelIndex ($i+1) ($chLabel) $tabUIName;
	}

	acSetTab( $node);
	acGetTab( $node);
endTrace();
}

//------------------- Tab Edit UI---------------------------------------
global proc acEditTabLayout( string $node, string $control)
{
printTrace( 4, "acEditTabLayout: " + $node);

	string $label = acGetLabel( $node);
	string $ann = acGetAnnotation( $node);
	string $specs[] = acGetSpecs( $node);
	int $x = ((int)$specs[1]);
	int $y = ((int)$specs[2]);
	string $command = $specs[3];
//$x = 5;
//$y = 5;
//	setParent $control;
//	string $ctrl = `intFieldGrp -label "Margin Size X/Y" -numberOfFields 2 -v1 $x -v2 $y -cw 2 50 -cw 3 50`;
//	intFieldGrp -e -cc ("acGetEditValue( \"" + $node + "\", 2, \"intFieldGrp -q -v1 " + $ctrl + "\");acGetEditValue( \"" + $node + "\", 3, \"intFieldGrp -q -v2 " + $ctrl + "\");") $ctrl;

//	separator -style "none" -h 10;
//	text -align "left" -label "     Pre-Select Command(s):";
//
//	string $ctrl = `scrollField -h 50 -text $command`;
//	string $cmd = ("acGetEditValue( \"" + $node + "\", 4, encodeString(\"scrollField -q -text " + $ctrl + "\"));");
//	scrollField -e -cc $cmd $ctrl;

endTrace();
}

//------------------- Tab Set UI---------------------------------------
global proc acEditTabLayoutUI( string $node)
{
printTrace( 4, "acEditTabLayoutUI: " + $node);


	string $ann = acGetAnnotation( $node);
	string $specs[] = acGetSpecs( $node);

	string $uiName = acGetUIName( $node);
	tabLayout -e -ann $ann -imw ((int)$specs[1])
					-imh ((int)$specs[1])
					-psc $specs[3] $uiName;

endTrace();
}



global proc string acVisibleTab( string $node)
{
printTrace( 4, "acVisibleTab: " + $node);

// finds the visible tab in the given acScriptNode hierarchy
// assume that there"s a tabLayout connected to the acScriptNode

	string $children[] = acGetNodeChildren( $node);

	if (size( $children) == 1 && acGetNodeType( $children[0]) == "TabLayout") {
		int $visibleTab = `tabLayout -q -selectTabIndex (acGetUIName( $children[0]))`;
		$children = acGetNodeChildren( $children[0]);
endTrace();
		return $children[$visibleTab -1];
	} else {
endTrace();
		return $node;
	}

}


//--------------------------------------------------------------------
global proc acCreateAddMenuItems( string $node, string $menu)
{
printTrace( 6, "acCreateAddMenuItems: " + $node);

//global string $acActiveTab;

// hier muss herausgefunden werden, was der User grade vor sich hat, welches Fenster, welches Tab
// $node sollte eine window node sein
// - wenn unter dieser Node ein TabLayout haengt, dann werden alle Groups im sichtbaren Tab gelistet
// - ansonsten ALLE Groups

	string $groups[];

	menu -e -deleteAllItems $menu;
	string $groups[] = acGetAllTypeChildren( $node, "Group");
	setParent -menu $menu;
	for ( $g in $groups ) {
		menuItem -label (acGetLabel($g)) -c ("acAddSelectedAttrsToGroup( \"" + $g + "\", -1);");
	}
endTrace();
}

global proc acCreateExportMenuItems( string $node, string $menu)
{
printTrace( 6, "acCreateExportMenuItems: " + $node);

//global string $acActiveTab;

// hier muss herausgefunden werden, was der User grade vor sich hat, welches Fenster, welches Tab
// $node sollte eine window node sein
// - wenn unter dieser Node ein TabLayout haengt, dann werden alle Groups im sichtbaren Tab gelistet
// - ansonsten ALLE Groups

	string $groups[];

	menu -e -deleteAllItems $menu;
	string $groups[] = acGetAllTypeChildren( $node, "Group");
	setParent -menu $menu;
	for ( $g in $groups ) {
		menuItem -label (acGetLabel($g)) -c ("acExport( \"" + $g + "\");");
	}
endTrace();
}

global proc acCreateShowMenuItems( string $node, string $menu)
{
printTrace( 6, "acCreateShowMenuItems: " + $node);

	string $nodes[] = acScriptNodes();

	menu -e -deleteAllItems $menu;
	setParent -menu $menu;
	for ( $n in $nodes ) {
		string $specs[] = acGetSpecs( $n);
		if ($specs[2]) menuItem -enable ($n != $node) -label (acGetLabel($n)) -c ("acShowAC( \"" + $n + "\");");
	}
endTrace();
}

// global proc acCreateSetDefaultMenuItems( string $node, string $menu)
// {
// printTrace( 4, "acCreateSetDefaultMenuItems: " + $node);

// 	global string $acMasterNode;
// 	string $nodes[] = acScriptNodes();

// 	menu -e -deleteAllItems $menu;
// 	setParent -menu $menu;
// 	for ( $n in $nodes ) {
// //		string $specs[] = acGetSpecs( $g);
// 		menuItem -checkBox ($n == $acMasterNode) -label $n -c ("global string $acMasterNode = \"" + $n + "\";acShowAC( $acMasterNode);");
// 	}
// }

global proc acDeleteAll()
{
printTrace( 2, "acDeleteAll" );

	global string $acMasterNode;
	
    string $confirm = `confirmDialog -title "Delete Custom UI" -message "Delete Attibute Collection from this Scene?"
  					  	-button "Yes" -button "No" -defaultButton "Yes"
    					-cancelButton "No" -dismissString "No"`;

	if ($confirm == "Yes") {
		string $wins[] = acGetAllEditWindows();
		for ( $w in $wins ) deleteUI $w;
		delete $acMasterNode;
	}
endTrace();
}

global proc acCreateDelGroupMenuItems( string $menu)
{
printTrace( 6, "acCreateDelGroupMenuItems: " + $menu);

global string $acActiveTab;

	menu -e -deleteAllItems $menu;
	string $groups[] = acGetAllTypeChildren( $acActiveTab, "Group");
	setParent -menu $menu;
	for ( $g in $groups ) {
		menuItem -label (acGetLabel( $g)) -c ("acDeleteEntry( \"" + $g + "\", 1, 1);");
	}
endTrace();
}



global proc acSetNewNodeID( string $node)
{
printTrace( 4, "acSetNewNodeID: " + $node);


	int $nodeId = (int)(`timerX`*1000);
printn("acSetNewNodeId for node:" + $node);
	$before = ("source ac.mel; acCheckScriptNode( " + $nodeId + ");");
	setAttr -type "string" ($node + ".before") $before;
	setAttr -type "string" ($node + ".after") ("acUncheckScriptNode( " + $nodeId + ");");
	setAttr ($node + ".nodeId") $nodeId;

endTrace();
}

//-----------------------Create Panel (Master) Node-------------------------------
global proc string acCreatePanelNode( string $parent, int $index, string $label)
{
printTrace( 2, "acCreatePanelNode: " + $parent);

	global string	$acActiveParent;

// I should first check, if there's already a "main" acScript Node
	int $nodeId = (int)(`timerX`*1000);
	
	string $before = "source ac.mel;";

	$before += "acCheckScriptNode( " + $nodeId + ");";
	string $after = "acUncheckScriptNode( " + $nodeId + ");";
//	string $node = `scriptNode -st 2 -bs $before -as $after -n "acScript#"`;
	string $node = `scriptNode -st 2 -n "acScript#"`;
	setAttr ($node + ".ihi") 0;

	acCreateEntryPlug( $node);
	acSetNodeType( $node, "Panel");

// set the specs and the label ("Panel " + the number of the scriptNode)
// Specs are:
// - Label (used for the window)
// - tornOff
// - visible
// - active
	string $specs[] = acTypeOptions( "Panel");
	string $tmp[];
	$tmp[0] = interToUI( $node);
	tokenize $tmp[0] " " $tmp;

	acSetLabel( $node, ("AC: Panel " + $tmp[size($tmp)-1]));
	acSetAnnotation( $node, "");
	acSetSpecs( $node, $specs);

// 	if (size($parent)) {
// 		$index = acInsertEntryPlug( $parent, $index);
// 		acConnect( $parent, $index, ($node + ".message"));
// 		if (acGetNodeType( $parent) == "TabLayout") $acActiveTab = $node;
// 	}
// printn("=== neue Panel Node hergestellt. Label = >" + $specs[0] + "<");

// Specs are:
// - Label (used for the window)
//
//	string $specs[] = stringArrayCatenate( {$label}, acTypeOptions( "Panel"));
//	acSetSpecs( $node, $specs);
	$acActiveParent = $node;

endTrace();
	return $node;
}


//---------------------- Drawing and other UI Stuff ----------------------
global proc acDrawFileMenuItems( string $node, string $fileMenu)
{
printTrace( 4, "acDrawFileMenuItems: " + $node);

	if (!acIsLocked( $node)) {
    	menuItem -label "New..." -en false;
    	menuItem -label "Import..." -en false;
    	menuItem -label "Export" -ann "Print UI Creation Commands in the Script Editor (Execute to Import)" -c "acExportAll();";
    	$exportMenu = `menuItem -label "Export Group..." -ann "Exports a single Group" -subMenu true`;
		menuItem -e -postMenuCommand ("acCreateExportMenuItems( acVisibleTab( \"" + $node + "\"), \"" + $exportMenu + "\");") $exportMenu;
		setParent -menu ..;
    	menuItem -divider true;
    }
	$showMenu = `menuItem -label "Show UI ..." -ann "Show the UI of an Attribute Collection Node" -subMenu true`;
	menuItem -e -postMenuCommand ("acCreateShowMenuItems( \"" + $node + "\", \"" + $showMenu + "\");") $showMenu;
	if (!acIsLocked( $node)) {
		setParent -menu ..;
    	$setDefaultMenu = `menuItem -checkBox false -label "Default UI" -ann "The Command \"ac\" always adds to the Default UI" -c ("acSetMasterNode( \"" + $node + "\");acShowAC( $acMasterNode);")`;
    	menu -e -postMenuCommand ("menuItem -e -checkBox (\"" + $node + "\"==$acMasterNode) " + $setDefaultMenu) $fileMenu;
		setParent -menu ..;
    	menuItem -divider true;
    	menuItem -label "Preferences..." -c "acPrefs()";
    	menuItem -divider true;
    	menuItem -label "Delete this UI" -ann "Remove this UI from the Database" -c ("acClosePanel(acGetUIDeleteName( \"" + $node + "\"));");
//    	menuItem -divider true;
//    	menuItem -label "Close" -en false;
	} else {
	   	menu -e -postMenuCommand "" $fileMenu;
	}

endTrace();
}

global proc acDrawEditMenuItems( string $node)
{
printTrace( 4, "acDrawEditMenuItems: " + $node);

	if (!acIsLocked( $node)) {
    	menuItem -label "Add Attribs to New Group" -c ("acAddSelToNewGroup( acVisibleTab( \"" + $node + "\"), \"New Group\");");
    	$addMenu = `menuItem -label "Add Attribute(s) to ..." -subMenu true`;
		menuItem -e -postMenuCommand ("acCreateAddMenuItems( acVisibleTab( \"" + $node + "\"), \"" + $addMenu + "\");") $addMenu;
		setParent -menu ..;
    	menuItem -divider true;
    	menuItem -label "Create New ..." -subMenu true;
    		menuItem -label " Window " -c ("scriptedPanel -tearOff -menuBarVisible true -type acPanelType");
    		menuItem -label " Tab " -c ("string $tabLayout = acGetParentNode( acVisibleTab( \"" + $node + "\"));acAddTab( $tabLayout, \"New Tab\"); acUpdateOtherViews( $tabLayout);");
    		menuItem -label " Group " -c ("string $tab = acVisibleTab( \"" + $node + "\");string $node=acCreateGroupEntry( $tab, -1, \"New Group\");acDrawEntry( $node);acUpdateOtherViews( $tab);");
		setParent -menu ..;
    	menuItem -divider true;
    	$addMenu = `menuItem -label "Delete Group..." -subMenu true`;
		menuItem -e -postMenuCommand ("acCreateDelGroupMenuItems( \"" + $addMenu + "\");") $addMenu;
		setParent -menu ..;
    	menuItem -divider true;
    	menuItem -label "Edit ..." -subMenu true;
	    	menuItem -label "Groups in this Tab..." -c ("acEditWin( acVisibleTab( \"" + $node + "\"), acNewEditWin(\"\"), {})");
	    	menuItem -label "Tabs..." -c ("acEditWin( acGetParentNode( acVisibleTab( \"" + $node + "\")), acNewEditWin(\"\"), {})");
	    	menuItem -label "All (Advanced)..." -c ("acEditWin( \"" + $node + "\", acNewEditWin(\"\"), {})");
		setParent -menu ..;
    	menuItem -divider true;
    	menuItem -label "Hierarchy Window" -c ("acFLWin( \"" + $node + "\")");
    	menuItem -label "Display UI Tree" -c "{string $tmp[] = acScriptNodes();select -cl;for ($n in $tmp) select -add (acGetAllChildren( $n));hyperGraphWindow \"\" \"DG\";}";
//    	menuItem -label "Display UI Tree" -c "{HypergraphDGWindow;string $tmp[] = acScriptNodes();select -cl;for ($n in $tmp) select -add (acGetAllChildren( $n));showDGLevel hyperGraphPanel1HyperGraphEd;}";
    	menuItem -divider true;
		menuItem -label "Cleanup" -ann "Find and remove lost Connections and empty Plugs" -c ("global int $acAllowCleanup; $acAllowCleanup=1; acCleanupConnections( \"" + $node + "\");");
    	menuItem -divider true;
    }
	menuItem -label "Redraw" -ann "Simple Redraw in case of Object deletion etc." -c ("acRedrawEntry( \"" + $node + "\");");
endTrace();
}

proc acMainMenu( string $node)
{
printTrace( 4, "acMainMenu: " + $node);

	global string $acMasterNode;

    $fileMenu = `menu -label "AC2.0" -tearOff true`;
	acDrawFileMenuItems( $node, $fileMenu);
    menu -label "Edit" -tearOff true;
	acDrawEditMenuItems( $node);
//     menu -label "Help" -helpMenu true;
//     	menuItem -label "About Attribute Collection..." -en false;

endTrace();
}

global proc string[] acDrawWindowEntry( string $node)
{
printTrace( 3, "acDrawWindowEntry: " + $node);

// what should I do with imported or referenced "windows"???
//	string $specs[] = acGetSpecs( $node);

//string $win = acCreatePanel( ($specs[0]));
	string $win = `window -title (acGetLabel( $node))
							-menuBar true
							-retain $node`;
	acMainMenu( $node);
endTrace();
	return {$win};
}


global proc string[] acDrawPanelEntry( string $node)
{
printTrace( 3, "acDrawPanelEntry: " + $node);

// what should I do with imported or referenced "windows"???
// 	string $specs[] = acGetSpecs( $node);
	string $uiName = acGetUIName( $node);
	string $panelName = acGetUIDeleteName( $node);

	setParent $uiName;
	acMainMenu( $node);
endTrace();
	return {$uiName, $panelName};
}


global proc acDrawWindowEntryPost( string $node)
{
printTrace( 3, "acDrawWindowEntryPost: " + $node);


	showWindow (acGetUIName( $node));
endTrace();
}

global proc acEditPanel( string $node, string $control)
{
printTrace( 4, "acEditPanel: " + $node);

	string $specs[] = acGetSpecs( $node);

	string $cb = `checkBoxGrp -ncb 1 -label "Panel is active" -v1 ((int)$specs[2])`;
	checkBoxGrp -e -cc ("acGetEditValue( \"" + $node + "\", 2, \"checkBoxGrp -q -v1 " + $cb + "\");") $cb;
endTrace();
}


global proc acEditPanelUI( string $node)
{
printTrace( 4, "acEditPanelUI: " + $node);


	string $uiName = acGetUIName( $node);
	string $panelName = acGetUIDeleteName( $node);

	string $label = acGetLabel( $node);
	scriptedPanel -e -label $label $panelName;

	string $win = acTopLevelUI( $uiName);
	if (`window -exists $win`) window -e -title $label $win;
endTrace();
}

global proc acEditWindowUI( string $node)
{
printTrace( 4, "acEditWindowUI: " + $node);

	string $uiName = acGetUIName( $node);

	window -e -title (acGetLabel($node)) $uiName;
endTrace();
}


//-----------------------------------------------------------------------------------
//-----------------------------
//----------------------VSlider------------------------
global proc string acCreateVSliderLayoutEntry( string $parentNode, int $index, string $label, string $numberOfColumns, string $columnWidth, string $offset)
{
printTrace( 4, "acCreateVSliderLayoutEntry: " + $parentNode);

// specs are:
// - label (used as a tab label)
// - # of columns
// - column width
// - offset

global string	$acActiveParent;

	string $ann;
	string $node = acCreateNode( $parentNode, $index, "VSliderLayout", $label, $ann, {$numberOfColumns, $columnWidth, $offset});

	$label = substituteAllString( $node, "_", " ");
	acSetLabel( $node, $label);

	$acActiveParent = $node;
endTrace();
	return $node;
}

//-----------------Draw VSliderLayout ------------------------------------

global proc string[] acDrawVSliderLayoutEntry( string $node)
{
printTrace( 4, "acDrawVSliderLayoutEntry: " + $node);

	int	$labelSize = acGetOpt( "acPrefLabelSize", 140);
	int	$fieldSize = acGetOpt( "acPrefFieldSize", 80);
	int	$sliderSize = acGetOpt( "acPrefSliderSize", 160)
				* acGetOpt( "acPrefEnableSliders", 1);
	if ($sliderSize < 1) $sliderSize = 1;
	int $totalWidth = $labelSize + $fieldSize + $sliderSize;

	string $ann = acGetAnnotation( $node);
	string $specs[] = acGetSpecs( $node);

	string $cmd = "rowColumnLayout -ann \"" + $ann + "\" -numberOfColumns " + $specs[0];
	for ( $i=1 ; $i<=(int)$specs[0] ; $i++ ) $cmd += " -columnWidth " + $i + " " + $specs[1] + " -columnOffset " + $i + " \"left\" " + $specs[2];
	string $uiName = `eval $cmd`;


endTrace();
	return {$uiName};
}

//------------------- VSliderLayout Edit UI---------------------------------------
global proc acEditVSliderLayout( string $node, string $control)
{
printTrace( 4, "acEditVSliderLayout: " + $node);

	string $specs[] = acGetSpecs( $node);
	int $numberOfColumns = (int)$specs[0];
	int $columnWidth = (int)$specs[1];
	int $offset = (int)$specs[2];

	setParent $control;
	$ctrl = `intFieldGrp -label "Number of Columns" -numberOfFields 1 -v1 $numberOfColumns`;
	intFieldGrp -e -cc ("acGetEditValue( \"" + $node + "\", 0, \"intFieldGrp -q -v1 " + $ctrl + "\");") $ctrl;
	$ctrl = `intFieldGrp -label "Column Width" -numberOfFields 1 -v1 $columnWidth`;
	intFieldGrp -e -cc ("acGetEditValue( \"" + $node + "\", 1, \"intFieldGrp -q -v1 " + $ctrl + "\");") $ctrl;
	$ctrl = `intFieldGrp -label "Offset" -numberOfFields 1 -v1 $offset`;
	intFieldGrp -e -cc ("acGetEditValue( \"" + $node + "\", 2, \"intFieldGrp -q -v1 " + $ctrl + "\");") $ctrl;
endTrace();
}


//------------------- VSliderLayout Set UI---------------------------------------
global proc acEditVSliderLayoutUI( string $node)
{
printTrace( 4, "acEditVSliderLayoutUI: " + $node);

	string $specs[] = acGetSpecs( $node);
	string $uiName = acGetUIName( $node);

	if (`rowColumnLayout -q -numberOfColumns $uiName` != (int)$specs[0]) acRedrawEntry( acGetParentNode( $node));
	else {
		string $cmd = "rowColumnLayout -e";
		for ( $i=1 ; $i<=(int)$specs[0] ; $i++ ) $cmd += " -columnWidth " + $i + " " + $specs[1]
													   + " -columnAttach " + $i + " \"both\" " + $specs[2];
//													   + " -columnOffset " + $i + " \"left\" " + $specs[3];
		$cmd += " " + $uiName;
		eval $cmd;
	
		acRedrawEntry( $node);
	}
	
endTrace();

}

