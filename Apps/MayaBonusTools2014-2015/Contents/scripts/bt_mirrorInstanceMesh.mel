// Copyright (C) 1997-2013 Autodesk, Inc., and/or its licensors.
// All rights reserved.
//
// The coded instructions, statements, computer programs, and/or related
// material (collectively the "Data") in these files contain unpublished
// information proprietary to Autodesk, Inc. ("Autodesk") and/or its licensors,
// which is protected by U.S. and Canadian federal copyright law and by
// international treaties.
//
// The Data is provided for use exclusively by You. You have the right to use,
// modify, and incorporate this Data into other products for purposes authorized 
// by the Autodesk software license agreement, without fee.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. AUTODESK
// DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTIES
// INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF NON-INFRINGEMENT,
// MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR ARISING FROM A COURSE 
// OF DEALING, USAGE, OR TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS
// LICENSORS BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL,
// DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK AND/OR ITS
// LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY OR PROBABILITY OF SUCH DAMAGES.

/////////////////////////////////////////////////////////////////////////////////////////////////	bt_mirrorInstanceMesh;//// This tool can be used to cut an existing mesh, instance it and mirror it along the specified axis.// It can be used in conjunction with the poly smooth workflow for modeling symetrical characters// and/or other objects that require symetry.//// The newly created mirror object will be an instance of the original mesh and it's transform// will be connected to the original mesh via a series of constraints.  In order to move, rotate// or scale the meshes you must select the original as the constraints are not bi-directional.//// The tool will also automatically run a series of polygon cleanup scripts for removing unwanted // artifacts along the mirror border such as zero area faces, zero length edges, coincident vertices  // and other unnecissary verts that may sometimes get added with the polyCut node.//// In order to re-combine the pair use the companion bonusTool called MergeCombineMeshes, which will// not only combine them but will also stitch up their adjacent border edges.//// NOTE : This tool is meant to be used for world space mirroring only.  If you are noticing any // odd results when mirroring, undo and try moving your mesh to the origin before mirroring.  /////////////////////////////////////////////////////////////////////////////////////////////////// Author:	Steven T. L. Roselle                //// Creation Date:      ( 08/01/07 )//// Modified 03/12/08 (fixed selection constraint bug that prevented editing the instanced mesh)global proc bt_convertToMirrorInstanceMesh(int $direction){	$obj = `ls -sl`;		if (`size $obj` != 1)		error "Select a single polygon object.";	///////////////////////////////////	//Check for rotation before continuing	//	select -r $obj[0];	$rot = `getAttr ($obj[0]+".r")`;		//If a rotation is not aligned to world 				if (($rot[0] != 0) || ($rot[1] != 0) || ($rot[2] != 0))			{			print ("Objects rotation needs to be oriented to the world. ");			string $checkResponse = `confirmDialog -title "Confirm" -message "WARNING: Objects rotation needs to be oriented to the world.  Rotation will be frozen.  Do you want to continue?" -button "Yes" -button "No" -defaultButton "Yes" -cancelButton "No" -dismissString "No"`;			if ($checkResponse == "No") 				{				select -r $obj;				error "Operation  Cancelled";				}			else				{				makeIdentity -apply true -t 0 -r 1 -s 0 -n 0;				}			}	///////////////////////////////////	//Cut mesh	//	$cutNode = `polyCut  -ws 1  -cd "X" -df 1 -ch 1`;		if (`size $cutNode` == 0)		error "MeshCut node not found.";	setAttr ($cutNode[0]+".cutPlaneCenterX") 0;	setAttr ($cutNode[0]+".cutPlaneCenterY") 0;	setAttr ($cutNode[0]+".cutPlaneCenterZ") 0;	setAttr ($cutNode[0]+".cutPlaneRotateX") 0;	setAttr ($cutNode[0]+".cutPlaneRotateY") 0;	setAttr ($cutNode[0]+".cutPlaneRotateZ") 0;	switch ($direction){		case 0 :				{				// +X				setAttr ($cutNode[0]+".cutPlaneRotateY") -90;				break;				}		case 1 :				{				// +Y				setAttr ($cutNode[0]+".cutPlaneRotateX") 90;				break;				}		case 2 :				{				// +Z				setAttr ($cutNode[0]+".cutPlaneRotateX") 180;				setAttr ($cutNode[0]+".cutPlaneRotateZ") 90;				break;				}		case 3 :				{				// -X				setAttr ($cutNode[0]+".cutPlaneRotateX") 90;				setAttr ($cutNode[0]+".cutPlaneRotateZ") 90;				break;				}		case 4 :				{				// -Y				setAttr ($cutNode[0]+".cutPlaneRotateX") -90;				setAttr ($cutNode[0]+".cutPlaneRotateY") 180;				break;				}		case 5 :				{				// -Z				break;				}		}	///////////////////////////////////	//Clean up cut mesh borders	//		//clean up zero length edges, zero area faces and lamina faces	//Took out because of weirdness after cleanup	polyCleanupArgList 3 { "0","1","1","0","0","0","0","0","1","1e-005","1","1e-005","0","1e-005","0","-1","0" };		//isolate border	select -r $obj[0];	ConvertSelectionToEdges;	polySelectConstraint -m 2 -t 0x8000 -w 1;	resetPolySelectConstraint;           // turn off location constraint	//clean up extra unnecissary verts on border edges	bt_cleanUpInteriorVerts;	//isolate border	select -r $obj[0];	ConvertSelectionToEdges;	polySelectConstraint -m 2 -t 0x8000 -w 1;	resetPolySelectConstraint;           // turn off location constraint	//clean up coincident verts	polyMergeVertex  -d 0.001 -am 1 -ch 1;	///////////////////////////////////	//Create Mirror - Inverted Instance	//	select -r $obj[0];	duplicatePreset(1,0,1,0,0,0,0,0,0,0,0,0,0,0,1,1,1);	rename ($obj[0]+"_mirroredInstance");	$dup = `ls -sl`;		//constrain inverted instance to original and lock transform	select -r $obj[0] $dup[0];	pointConstraint -offset 0 0 0 -weight 1;	orientConstraint -offset 0 0 0 -weight 1;	//invert	switch ($direction){		case 0 :				{				// +X				scaleConstraint -offset -1 1 1 -weight 1;				break;				}		case 1 :				{				// +Y				scaleConstraint -offset 1 -1 1 -weight 1;				break;				}		case 2 :				{				// +Z				scaleConstraint -offset 1 1 -1 -weight 1;				break;				}		case 3 :				{				// -X				scaleConstraint -offset -1 1 1 -weight 1;				break;				}		case 4 :				{				// -Y				scaleConstraint -offset 1 -1 1 -weight 1;				break;				}		case 5 :				{				// -Z				scaleConstraint -offset 1 1 -1 -weight 1;				break;				}		}// bi-directional breaks undo :(////	select -r $dup[0] $obj[0] ;//	pointConstraint -offset 0 0 0 -weight 1;//	orientConstraint -offset 0 0 0 -weight 1;//	scaleConstraint -offset -1 1 1 -weight 1;	setAttr -lock true ($dup[0]+".tx");	setAttr -lock true ($dup[0]+".ty");	setAttr -lock true ($dup[0]+".tz");	setAttr -lock true ($dup[0]+".rx");	setAttr -lock true ($dup[0]+".ry");	setAttr -lock true ($dup[0]+".rz");	setAttr -lock true ($dup[0]+".sx");	setAttr -lock true ($dup[0]+".sy");	setAttr -lock true ($dup[0]+".sz");	}global proc bt_cleanUpInteriorVerts()		{	float $tolerance, $xyz[];	string $neighborVerts[], $vertList[], $vert, $removeVerts;	vector $vector1, $vector2, $vector3;	int $count;		$tolerance = 0.001;	$count = 0;	$removeVerts = "";	ConvertSelectionToVertices;	$vertList = `ls -long -sl -fl`;	if (`size $vertList` < 1)		error ("No verts to check.  Select a mesh object or components.");	//Check each vert in selection	for ($vert in $vertList)	{		select -r $vert;		//Get neighboring edges		ConvertSelectionToEdges;		//Get corresponding verts		ConvertSelectionToVertices;		select -d $vert;		$neighborVerts = `ls -sl -fl`;				if (size($neighborVerts) == 2)		{			//convert position to vector and compare angle of corresponding edges			select -r $vert;			$xyz = `pointPosition`;			$vector1 = <<$xyz[0],$xyz[1],$xyz[2]>>;			select $neighborVerts[0];			$xyz = `pointPosition`;			$vector2 = <<$xyz[0],$xyz[1],$xyz[2]>>;			select $neighborVerts[1];			$xyz = `pointPosition`;			$vector3 = <<$xyz[0],$xyz[1],$xyz[2]>>;			//if edges are in line then delete the middle vert			if(angle($vector1-$vector2, $vector3-$vector1) < $tolerance)				{				$removeVerts += " "+$vert;				//delete $vert; //doesn't work because vert IDs change				$count ++;				}		}		select -cl;	}	//remove all verts at once	if (size($removeVerts) > 0)		eval ("delete"+$removeVerts);	print ("Removed " + $count + " extra interior verts from mesh \n");}///////////////////////////////////////////////////// OptionVarsglobal proc bt_setMirrorInstanceOptionVars(){	if (`optionVar -ex mirrorInstanceAxis` == 0)		optionVar -intValue mirrorInstanceAxis 0;   // 0=x : 1=y : 2=z	if (`optionVar -ex mirrorInstanceSpace` == 0)		optionVar -intValue mirrorInstanceSpace 0;  // 0=object : 1:world }global proc bt_deleteMirrorInstanceOptionVars(){	optionVar -rm mirrorInstanceAxis;	optionVar -rm mirrorInstanceSpace;}	///////////////////////////////////////////////////// UI Proc	global proc bt_mirrorInstanceMesh(){	global string $mirrorInstanceAxisID;	global string $mirrorInstanceSpaceID;	bt_setMirrorInstanceOptionVars;			if( `window -exists mirrorInstanceWin` )		{		deleteUI mirrorInstanceWin;		//windowPref -remove mirrorInstanceWin;		}	window -w 338 -h 118 -menuBar true -title "Mirror Instance Mesh" mirrorInstanceWin;		menu -tearOff 0 -l "Edit";	    menuItem -l "Reset Settings" -ann "Reset all setting to default values." -c "bt_deleteMirrorInstanceOptionVars ; mirrorInstanceMeshUI";	columnLayout -adjustableColumn 1;					//////////////////////////	// Axis and Space toggles	//	rowColumnLayout  -numberOfColumns 4 -columnWidth 1 140 -columnWidth 2 67 -columnWidth 3 67 -columnWidth 4 68; 				separator -style "none";separator -style "none";separator -style "none";separator -style "none";			//Space - currently only working in world space		//		/*		text -label "Mirror Space     " -align "right";									$mirrorInstanceSpaceID = `radioCollection`;		radioButton -label "Object" -align "left"			-onc "optionVar -intValue mirrorInstanceSpace 0";				radioButton -label "World" 	-align "left" 			-onc "optionVar -intValue mirrorInstanceSpace 1";				separator -style "none";		//select correct radio button for stored type		$buttonList = `radioCollection -q -collectionItemArray $mirrorInstanceSpaceID`;		int $buttonNumber = (`optionVar -q mirrorInstanceSpace`);		radioCollection -e -sl $buttonList[$buttonNumber] $mirrorInstanceSpaceID ;		*/				//Axis		//				text -label "Mirror Axis     " -align "right";													$mirrorInstanceAxisID = `radioCollection`;		radioButton -label "+ X" -align "left"			-onc "optionVar -intValue mirrorInstanceAxis 0";				radioButton -label "+ Y" 	-align "left" 			-onc "optionVar -intValue mirrorInstanceAxis 1";				radioButton -label "+ Z" -align "left" 			-onc "optionVar -intValue mirrorInstanceAxis 2";		separator -style "none";		radioButton -label " - X" -align "left"			-onc "optionVar -intValue mirrorInstanceAxis 3";				radioButton -label " - Y" 	-align "left" 			-onc "optionVar -intValue mirrorInstanceAxis 4";				radioButton -label " - Z" -align "left" 			-onc "optionVar -intValue mirrorInstanceAxis 5";				//select correct radio button for stored type		$buttonList = `radioCollection -q -collectionItemArray $mirrorInstanceAxisID`;		int $buttonNumber = (`optionVar -q mirrorInstanceAxis`);		radioCollection -e -sl $buttonList[$buttonNumber] $mirrorInstanceAxisID;				setParent ..;				//separator -style "none";separator -style "none";separator -style "none";separator -style "none";		//////////////				rowColumnLayout  -numberOfColumns 2 -columnWidth 1 165  -columnWidth 2 165 ;				separator -style none;separator -style none;		separator -style none;separator -style none;		button -label "Apply" -c (" bt_convertToMirrorInstanceMesh(`optionVar -q mirrorInstanceAxis`)");		button -label "Close" -c "deleteUI mirrorInstanceWin";			showWindow;	}